{
  "version": 3,
  "sources": ["../src/types.ts", "../src/grid.ts", "../src/validator.ts", "../src/generator.ts", "../src/index.ts"],
  "sourcesContent": ["export enum Direction {\n\tUp = 0,\n\tRight = 1,\n\tDown = 2,\n\tLeft = 3,\n}\n\nexport enum CellType {\n\tNone = 0,\n\tSquare = 1, // \u8272\u5206\u3051\u304C\u5FC5\u8981\u306A\u30D6\u30ED\u30C3\u30AF\n\tStar = 2, // \u540C\u3058\u8272\u306E\u30DA\u30A2\u4F5C\u6210 (\u661F)\n\tTetris = 3, // \u30C6\u30C8\u30EA\u30B9\n\tTetrisRotated = 4, // \u30C6\u30C8\u30EA\u30B9\uFF08\u56DE\u8EE2\u53EF\u80FD\uFF09\n}\n\nexport enum EdgeType {\n\tNormal = 0,\n\tBroken = 1, // \u7DDA\u306E\u771F\u3093\u4E2D\u3067\u65AD\u7DDA (\u901A\u884C\u4E0D\u53EF)\n\tAbsent = 2, // \u305D\u3082\u305D\u3082\u5206\u5C90\u3082\u306A\u3057 (\u901A\u884C\u4E0D\u53EF)\n\tHexagon = 3, // \u901A\u904E\u5FC5\u9808\n}\n\nexport enum NodeType {\n\tNormal = 0,\n\tStart = 1,\n\tEnd = 2,\n}\n\nexport enum Color {\n\tNone = 0,\n\tBlack = 1,\n\tWhite = 2,\n\tRed = 3,\n\tBlue = 4,\n\t// \u62E1\u5F35\u53EF\u80FD\n}\n\nexport interface Point {\n\tx: number;\n\ty: number;\n}\n\nexport interface CellConstraint {\n\ttype: CellType;\n\tcolor: Color;\n\tshape?: number[][]; // [row][col] 0 or 1\n}\n\nexport interface EdgeConstraint {\n\ttype: EdgeType;\n}\n\nexport interface NodeConstraint {\n\ttype: NodeType;\n}\n\n/**\n * \u30D1\u30BA\u30EB\u306E\u9759\u7684\u306A\u5B9A\u7FA9\u30C7\u30FC\u30BF\n */\nexport interface PuzzleData {\n\trows: number;\n\tcols: number;\n\tcells: CellConstraint[][]; // [row][col]\n\tvEdges: EdgeConstraint[][]; // Vertical edges [row][col] (row: 0..rows-1, col: 0..cols)\n\thEdges: EdgeConstraint[][]; // Horizontal edges [row][col] (row: 0..rows, col: 0..cols-1)\n\tnodes: NodeConstraint[][]; // [row][col]\n}\n\n/**\n * \u30E6\u30FC\u30B6\u30FC\u306E\u5165\u529B\uFF08\u56DE\u7B54\u30D1\u30B9\uFF09\n */\nexport interface SolutionPath {\n\tpoints: Point[]; // \u901A\u904E\u3057\u305F\u30CE\u30FC\u30C9\u306E\u5EA7\u6A19\u914D\u5217\n}\n\nexport interface ValidationResult {\n\tisValid: boolean;\n\terrorReason?: string;\n}\n\n/**\n * \u30D1\u30BA\u30EB\u751F\u6210\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\n */\nexport interface GenerationOptions {\n\tuseHexagons?: boolean;\n\tuseSquares?: boolean;\n\tuseStars?: boolean;\n\tuseTetris?: boolean;\n\tuseBrokenEdges?: boolean;\n\tcomplexity?: number; // 0.0 - 1.0 (\u5236\u7D04\u306E\u5BC6\u5EA6)\n\tdifficulty?: number; // 0.0 (Easy) - 1.0 (Hard) (\u89E3\u30D1\u30BF\u30FC\u30F3\u306E\u6570\u306B\u57FA\u3065\u304F)\n}\n", "import { type CellConstraint, CellType, Color, type EdgeConstraint, EdgeType, type NodeConstraint, NodeType, type PuzzleData } from \"./types\";\n\nexport class Grid {\n\tpublic readonly rows: number;\n\tpublic readonly cols: number;\n\n\t// \u30C7\u30FC\u30BF\u30DE\u30C8\u30EA\u30AF\u30B9\n\tpublic cells: CellConstraint[][] = [];\n\tpublic hEdges: EdgeConstraint[][] = []; // \u6A2A\u68D2\n\tpublic vEdges: EdgeConstraint[][] = []; // \u7E26\u68D2\n\tpublic nodes: NodeConstraint[][] = [];\n\n\tconstructor(rows: number, cols: number) {\n\t\tthis.rows = rows;\n\t\tthis.cols = cols;\n\t\tthis.initializeGrid();\n\t}\n\n\tprivate initializeGrid() {\n\t\t// Cells: rows * cols\n\t\tthis.cells = Array.from({ length: this.rows }, () => Array.from({ length: this.cols }, () => ({ type: CellType.None, color: Color.None })));\n\n\t\t// H-Edges: (rows + 1) * cols\n\t\tthis.hEdges = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols }, () => ({ type: EdgeType.Normal })));\n\n\t\t// V-Edges: rows * (cols + 1)\n\t\tthis.vEdges = Array.from({ length: this.rows }, () => Array.from({ length: this.cols + 1 }, () => ({ type: EdgeType.Normal })));\n\n\t\t// Nodes: (rows + 1) * (cols + 1)\n\t\tthis.nodes = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols + 1 }, () => ({ type: NodeType.Normal })));\n\t}\n\n\tpublic export(): PuzzleData {\n\t\t// \u30C7\u30FC\u30BF\u306E\u30C7\u30A3\u30FC\u30D7\u30B3\u30D4\u30FC\u3092\u8FD4\u3059\n\t\treturn JSON.parse(\n\t\t\tJSON.stringify({\n\t\t\t\trows: this.rows,\n\t\t\t\tcols: this.cols,\n\t\t\t\tcells: this.cells,\n\t\t\t\tvEdges: this.vEdges,\n\t\t\t\thEdges: this.hEdges,\n\t\t\t\tnodes: this.nodes,\n\t\t\t}),\n\t\t);\n\t}\n\n\tpublic static fromData(data: PuzzleData): Grid {\n\t\tconst grid = new Grid(data.rows, data.cols);\n\t\tgrid.cells = data.cells;\n\t\tgrid.vEdges = data.vEdges;\n\t\tgrid.hEdges = data.hEdges;\n\t\tgrid.nodes = data.nodes;\n\t\treturn grid;\n\t}\n}\n", "import { Grid } from \"./grid\";\nimport { CellType, EdgeType, NodeType, type Point, type SolutionPath, type ValidationResult } from \"./types\";\n\nexport class PuzzleValidator {\n\tpublic validate(grid: Grid, solution: SolutionPath): ValidationResult {\n\t\tconst path = solution.points;\n\n\t\t// 1. \u57FA\u672C\u7684\u306A\u30D1\u30B9\u306E\u6709\u52B9\u6027\u30C1\u30A7\u30C3\u30AF (\u9023\u7D9A\u6027\u3001\u59CB\u70B9\u7D42\u70B9)\n\t\tif (path.length < 2) return { isValid: false, errorReason: \"Path too short\" };\n\n\t\tconst start = path[0];\n\t\tconst end = path[path.length - 1];\n\n\t\tif (grid.nodes[start.y][start.x].type !== NodeType.Start) {\n\t\t\treturn { isValid: false, errorReason: \"Must start at Start Node\" };\n\t\t}\n\t\tif (grid.nodes[end.y][end.x].type !== NodeType.End) {\n\t\t\treturn { isValid: false, errorReason: \"Must end at End Node\" };\n\t\t}\n\n\t\t// 2. \u30D1\u30B9\u306E\u9023\u7D9A\u6027\u3068\u81EA\u5DF1\u4EA4\u5DEE\u306E\u30C1\u30A7\u30C3\u30AF\n\t\tconst visitedNodes = new Set<string>();\n\t\tvisitedNodes.add(`${start.x},${start.y}`);\n\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst p1 = path[i];\n\t\t\tconst p2 = path[i + 1];\n\n\t\t\t// \u8DDD\u96E2\u304C1\u3067\u3042\u308B\u3053\u3068\n\t\t\tconst dist = Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n\t\t\tif (dist !== 1) return { isValid: false, errorReason: \"Invalid jump in path\" };\n\n\t\t\t// \u65E2\u306B\u901A\u3063\u305F\u30CE\u30FC\u30C9\u3067\u306F\u306A\u3044\u3053\u3068 (\u81EA\u5DF1\u4EA4\u5DEE\u7981\u6B62)\n\t\t\tconst key = `${p2.x},${p2.y}`;\n\t\t\tif (visitedNodes.has(key)) return { isValid: false, errorReason: \"Self-intersecting path\" };\n\t\t\tvisitedNodes.add(key);\n\n\t\t\t// \u901A\u884C\u4E0D\u53EF\u30A8\u30C3\u30B8(Broken)\u3067\u306A\u3044\u304B\u30C1\u30A7\u30C3\u30AF\n\t\t\tif (this.isBrokenEdge(grid, p1, p2)) {\n\t\t\t\treturn { isValid: false, errorReason: \"Passed through broken edge\" };\n\t\t\t}\n\t\t}\n\n\t\t// 3. \u30EB\u30FC\u30EB\u691C\u8A3C: Hexagon (\u901A\u904E\u5FC5\u9808)\n\t\tif (!this.checkHexagonConstraint(grid, path)) {\n\t\t\treturn { isValid: false, errorReason: \"Missed hexagon constraint\" };\n\t\t}\n\n\t\t// 4. \u30EB\u30FC\u30EB\u691C\u8A3C: \u30BB\u30EB\u5236\u7D04 (Squares & Stars)\n\t\tif (!this.checkCellConstraints(grid, path)) {\n\t\t\treturn { isValid: false, errorReason: \"Cell constraints failed\" };\n\t\t}\n\n\t\treturn { isValid: true };\n\t}\n\n\tprivate isBrokenEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tlet type: EdgeType;\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\ttype = grid.vEdges[y][p1.x].type;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\ttype = grid.hEdges[p1.y][x].type;\n\t\t}\n\t\treturn type === EdgeType.Broken || type === EdgeType.Absent;\n\t}\n\n\tprivate isAbsentEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\treturn grid.vEdges[y][p1.x].type === EdgeType.Absent;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\treturn grid.hEdges[p1.y][x].type === EdgeType.Absent;\n\t\t}\n\t}\n\n\tprivate checkHexagonConstraint(grid: Grid, path: Point[]): boolean {\n\t\t// \u30D1\u30B9\u4E0A\u306E\u30A8\u30C3\u30B8\u30AD\u30FC\u96C6\u5408\u3092\u4F5C\u6210\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t}\n\n\t\t// \u30B0\u30EA\u30C3\u30C9\u4E0A\u306E\u5168\u30D8\u30AD\u30B5\u30B4\u30F3\u30A8\u30C3\u30B8\u3092\u78BA\u8A8D\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r });\n\t\t\t\t\tif (!pathEdges.has(key)) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 });\n\t\t\t\t\tif (!pathEdges.has(key)) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate checkCellConstraints(grid: Grid, path: Point[]): boolean {\n\t\tconst regions = this.calculateRegions(grid, path);\n\n\t\tfor (const region of regions) {\n\t\t\tconst colorCounts = new Map<number, number>();\n\t\t\tconst starColors = new Set<number>();\n\t\t\tconst squareColors = new Set<number>();\n\t\t\tconst tetrisPieces: { shape: number[][]; rotatable: boolean }[] = [];\n\n\t\t\tfor (const cell of region) {\n\t\t\t\tconst constraint = grid.cells[cell.y][cell.x];\n\t\t\t\tif (constraint.type === CellType.None) continue;\n\n\t\t\t\tconst color = constraint.color;\n\t\t\t\tcolorCounts.set(color, (colorCounts.get(color) || 0) + 1);\n\n\t\t\t\tif (constraint.type === CellType.Square) {\n\t\t\t\t\tsquareColors.add(color);\n\t\t\t\t} else if (constraint.type === CellType.Star) {\n\t\t\t\t\tstarColors.add(color);\n\t\t\t\t} else if (constraint.type === CellType.Tetris || constraint.type === CellType.TetrisRotated) {\n\t\t\t\t\tif (constraint.shape) {\n\t\t\t\t\t\ttetrisPieces.push({\n\t\t\t\t\t\t\tshape: constraint.shape,\n\t\t\t\t\t\t\trotatable: constraint.type === CellType.TetrisRotated,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Squares: All squares in a region must be the same color\n\t\t\t\tif (squareColors.size > 1) return false;\n\t\t\t}\n\n\t\t\t// Stars: For each color that has a star, there must be exactly 2 marks of that color\n\t\t\t// Note: Tetris pieces also count as marks for Star rules.\n\t\t\tfor (const color of starColors) {\n\t\t\t\tif (colorCounts.get(color) !== 2) return false;\n\t\t\t}\n\n\t\t\t// Tetris Rule\n\t\t\tif (tetrisPieces.length > 0) {\n\t\t\t\tif (!this.checkTetrisConstraint(region, tetrisPieces)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate checkTetrisConstraint(region: Point[], pieces: { shape: number[][]; rotatable: boolean }[]): boolean {\n\t\tconst totalTetrisArea = pieces.reduce((sum, p) => sum + this.getShapeArea(p.shape), 0);\n\t\tif (totalTetrisArea !== region.length) return false;\n\n\t\t// Convert region to a relative bitmask/grid for easier tiling check\n\t\tconst minX = Math.min(...region.map((p) => p.x));\n\t\tconst minY = Math.min(...region.map((p) => p.y));\n\t\tconst maxX = Math.max(...region.map((p) => p.x));\n\t\tconst maxY = Math.max(...region.map((p) => p.y));\n\t\tconst width = maxX - minX + 1;\n\t\tconst height = maxY - minY + 1;\n\n\t\tconst regionGrid = Array.from({ length: height }, () => Array(width).fill(false));\n\t\tfor (const p of region) {\n\t\t\tregionGrid[p.y - minY][p.x - minX] = true;\n\t\t}\n\n\t\treturn this.canTile(regionGrid, pieces);\n\t}\n\n\tprivate getShapeArea(shape: number[][]): number {\n\t\tlet area = 0;\n\t\tfor (const row of shape) {\n\t\t\tfor (const cell of row) {\n\t\t\t\tif (cell) area++;\n\t\t\t}\n\t\t}\n\t\treturn area;\n\t}\n\n\tprivate canTile(regionGrid: boolean[][], pieces: { shape: number[][]; rotatable: boolean }[]): boolean {\n\t\t// \u898B\u3064\u304B\u3063\u3066\u3044\u306A\u3044\u6700\u521D\u306E\u30DE\u30B9\u3092\u63A2\u3059\n\t\tlet r0 = -1;\n\t\tlet c0 = -1;\n\t\tfor (let r = 0; r < regionGrid.length; r++) {\n\t\t\tfor (let c = 0; c < regionGrid[0].length; c++) {\n\t\t\t\tif (regionGrid[r][c]) {\n\t\t\t\t\tr0 = r;\n\t\t\t\t\tc0 = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r0 !== -1) break;\n\t\t}\n\n\t\t// \u5168\u3066\u306E\u30DE\u30B9\u304C\u57CB\u307E\u3063\u305F\u5834\u5408\n\t\tif (r0 === -1) {\n\t\t\treturn pieces.length === 0;\n\t\t}\n\n\t\t// \u307E\u3060\u30DE\u30B9\u304C\u3042\u308B\u306E\u306B\u30D4\u30FC\u30B9\u304C\u306A\u3044\u5834\u5408\n\t\tif (pieces.length === 0) return false;\n\n\t\t// (r0, c0) \u3092\u57CB\u3081\u308B\u305F\u3081\u306B\u5168\u3066\u306E\u6B8B\u308A\u306E\u30D4\u30FC\u30B9\u3092\u8A66\u3059\n\t\tfor (let i = 0; i < pieces.length; i++) {\n\t\t\tconst piece = pieces[i];\n\t\t\tconst nextPieces = [...pieces.slice(0, i), ...pieces.slice(i + 1)];\n\t\t\tconst rotations = piece.rotatable ? this.getAllRotations(piece.shape) : [piece.shape];\n\n\t\t\tfor (const shape of rotations) {\n\t\t\t\t// \u30D4\u30FC\u30B9\u5185\u306E\u5404\u30D6\u30ED\u30C3\u30AF\u3092 (r0, c0) \u306B\u5408\u308F\u305B\u3066\u307F\u308B\n\t\t\t\tconst blocks: { r: number; c: number }[] = [];\n\t\t\t\tfor (let pr = 0; pr < shape.length; pr++) {\n\t\t\t\t\tfor (let pc = 0; pc < shape[0].length; pc++) {\n\t\t\t\t\t\tif (shape[pr][pc]) blocks.push({ r: pr, c: pc });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const anchor of blocks) {\n\t\t\t\t\tconst dr = r0 - anchor.r;\n\t\t\t\t\tconst dc = c0 - anchor.c;\n\n\t\t\t\t\tif (this.canPlace(regionGrid, shape, dr, dc)) {\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, false);\n\t\t\t\t\t\tif (this.canTile(regionGrid, nextPieces)) return true;\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate canPlace(regionGrid: boolean[][], shape: number[][], r: number, c: number): boolean {\n\t\tfor (let i = 0; i < shape.length; i++) {\n\t\t\tfor (let j = 0; j < shape[0].length; j++) {\n\t\t\t\tif (shape[i][j]) {\n\t\t\t\t\tconst nr = r + i;\n\t\t\t\t\tconst nc = c + j;\n\t\t\t\t\tif (nr < 0 || nr >= regionGrid.length || nc < 0 || nc >= regionGrid[0].length || !regionGrid[nr][nc]) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate placePiece(regionGrid: boolean[][], shape: number[][], r: number, c: number, value: boolean) {\n\t\tfor (let i = 0; i < shape.length; i++) {\n\t\t\tfor (let j = 0; j < shape[0].length; j++) {\n\t\t\t\tif (shape[i][j]) {\n\t\t\t\t\tregionGrid[r + i][c + j] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate getAllRotations(shape: number[][]): number[][][] {\n\t\tconst results: number[][][] = [];\n\t\tconst keys = new Set<string>();\n\n\t\tlet curr = shape;\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tconst key = JSON.stringify(curr);\n\t\t\tif (!keys.has(key)) {\n\t\t\t\tresults.push(curr);\n\t\t\t\tkeys.add(key);\n\t\t\t}\n\t\t\tcurr = this.rotate90(curr);\n\t\t}\n\t\treturn results;\n\t}\n\n\tprivate rotate90(shape: number[][]): number[][] {\n\t\tconst rows = shape.length;\n\t\tconst cols = shape[0].length;\n\t\tconst newShape = Array.from({ length: cols }, () => Array(rows).fill(0));\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tnewShape[c][rows - 1 - r] = shape[r][c];\n\t\t\t}\n\t\t}\n\t\treturn newShape;\n\t}\n\n\tprivate calculateRegions(grid: Grid, path: Point[]): Point[][] {\n\t\tconst regions: Point[][] = [];\n\t\tconst visitedCells = new Set<string>();\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t}\n\n\t\t// \u76E4\u9762\u5916\u306B\u30EA\u30FC\u30AF\u3057\u3066\u3044\u308B\u30BB\u30EB\u3092\u7279\u5B9A\n\t\tconst externalCells = this.getExternalCells(grid);\n\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (visitedCells.has(`${c},${r}`) || externalCells.has(`${c},${r}`)) continue;\n\n\t\t\t\tconst region: Point[] = [];\n\t\t\t\tconst queue: Point[] = [{ x: c, y: r }];\n\t\t\t\tvisitedCells.add(`${c},${r}`);\n\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst curr = queue.shift()!;\n\t\t\t\t\tregion.push(curr);\n\n\t\t\t\t\tconst neighbors = [\n\t\t\t\t\t\t{ nx: curr.x, ny: curr.y - 1, p1: { x: curr.x, y: curr.y }, p2: { x: curr.x + 1, y: curr.y } }, // Up\n\t\t\t\t\t\t{ nx: curr.x, ny: curr.y + 1, p1: { x: curr.x, y: curr.y + 1 }, p2: { x: curr.x + 1, y: curr.y + 1 } }, // Down\n\t\t\t\t\t\t{ nx: curr.x - 1, ny: curr.y, p1: { x: curr.x, y: curr.y }, p2: { x: curr.x, y: curr.y + 1 } }, // Left\n\t\t\t\t\t\t{ nx: curr.x + 1, ny: curr.y, p1: { x: curr.x + 1, y: curr.y }, p2: { x: curr.x + 1, y: curr.y + 1 } }, // Right\n\t\t\t\t\t];\n\n\t\t\t\t\tfor (const n of neighbors) {\n\t\t\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\t\t\tconst neighborKey = `${n.nx},${n.ny}`;\n\t\t\t\t\t\t\tif (!visitedCells.has(neighborKey) && !externalCells.has(neighborKey)) {\n\t\t\t\t\t\t\t\tconst edgeKey = this.getEdgeKey(n.p1, n.p2);\n\t\t\t\t\t\t\t\tconst isAbsent = this.isAbsentEdge(grid, n.p1, n.p2);\n\t\t\t\t\t\t\t\t// \u30D1\u30B9\u307E\u305F\u306FAbsent\u30A8\u30C3\u30B8\u3001\u3042\u308B\u3044\u306F\u300C\u5916\u5468\u306E\u8FC2\u56DE\u300D\u306B\u3088\u308A\u906E\u3089\u308C\u3066\u3044\u306A\u3044\u304B\n\t\t\t\t\t\t\t\tif (!pathEdges.has(edgeKey) && !isAbsent) {\n\t\t\t\t\t\t\t\t\tvisitedCells.add(neighborKey);\n\t\t\t\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregions.push(region);\n\t\t\t}\n\t\t}\n\t\treturn regions;\n\t}\n\n\tprivate getExternalCells(grid: Grid): Set<string> {\n\t\tconst external = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [];\n\n\t\t// 1. \u30B0\u30EA\u30C3\u30C9\u5883\u754C\u304B\u3089\u306E\u30EA\u30FC\u30AF\u3092\u53CE\u96C6\n\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\tif (grid.hEdges[0][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},0`)) {\n\t\t\t\t\texternal.add(`${c},0`);\n\t\t\t\t\tqueue.push({ x: c, y: 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.hEdges[grid.rows][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},${grid.rows - 1}`)) {\n\t\t\t\t\texternal.add(`${c},${grid.rows - 1}`);\n\t\t\t\t\tqueue.push({ x: c, y: grid.rows - 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tif (grid.vEdges[r][0].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`0,${r}`)) {\n\t\t\t\t\texternal.add(`0,${r}`);\n\t\t\t\t\tqueue.push({ x: 0, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.vEdges[r][grid.cols].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${grid.cols - 1},${r}`)) {\n\t\t\t\t\texternal.add(`${grid.cols - 1},${r}`);\n\t\t\t\t\tqueue.push({ x: grid.cols - 1, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 2. Absent\u30A8\u30C3\u30B8\u3092\u901A\u3058\u305F\u30EA\u30FC\u30AF\u306E\u4F1D\u642C\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.hEdges[curr.y][curr.x] }, // Up\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.hEdges[curr.y + 1][curr.x] }, // Down\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x] }, // Left\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x + 1] }, // Right\n\t\t\t];\n\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\tif (!external.has(`${n.nx},${n.ny}`) && n.edge.type === EdgeType.Absent) {\n\t\t\t\t\t\texternal.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn external;\n\t}\n\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u306E\u96E3\u6613\u5EA6\u3092\u8A08\u7B97\u3059\u308B\uFF080.0 - 1.0\uFF09\n\t * \u77E5\u7684\u306A\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\uFF1A\u63A2\u7D22\u7A7A\u9593\u306E\u5E83\u3055\u3001\u5206\u5C90\u6570\u3001\u5F37\u5236\u624B\u3001\u89E3\u306E\u6570\u306A\u3069\u3092\u5206\u6790\n\t */\n\tpublic calculateDifficulty(grid: Grid): number {\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst nodeCols = cols + 1;\n\t\tconst nodeCount = (rows + 1) * nodeCols;\n\n\t\t// \u63A2\u7D22\u7528\u30C7\u30FC\u30BF\u306E\u6E96\u5099\n\t\tconst adj = Array.from({ length: nodeCount }, () => [] as { next: number; isHexagon: boolean; isBroken: boolean }[]);\n\t\tconst startNodes: number[] = [];\n\t\tconst endNodes: number[] = [];\n\t\tconst hexagonEdges = new Set<string>();\n\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tconst u = r * nodeCols + c;\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) startNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.End) endNodes.push(u);\n\t\t\t\tif (c < cols) {\n\t\t\t\t\tconst v = u + 1;\n\t\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBlocked = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r }));\n\t\t\t\t}\n\t\t\t\tif (r < rows) {\n\t\t\t\t\tconst v = u + nodeCols;\n\t\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBlocked = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 }));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst stats = {\n\t\t\ttotalNodesVisited: 0,\n\t\t\tbranchingPoints: 0,\n\t\t\tsolutions: 0,\n\t\t\tmaxDepth: 0,\n\t\t\tbacktracks: 0,\n\t\t};\n\n\t\tconst totalHexagons = hexagonEdges.size;\n\t\tconst fingerprints = new Set<string>();\n\n\t\tfor (const startIdx of startNodes) {\n\t\t\tthis.exploreSearchSpace(grid, startIdx, 1n << BigInt(startIdx), [startIdx], 0, totalHexagons, adj, endNodes, fingerprints, stats, 500);\n\t\t}\n\n\t\tif (stats.solutions === 0) return 0;\n\n\t\t// \u96E3\u6613\u5EA6\u8A08\u7B97\u30ED\u30B8\u30C3\u30AF\n\t\t// 1. \u5236\u7D04\u306E\u6570\u3068\u7A2E\u985E (\u5C11\u306A\u3044\u307B\u3069\u5358\u7D14)\n\t\tlet constraintCount = hexagonEdges.size;\n\t\tconst constraintTypes = new Set<number>();\n\t\tif (hexagonEdges.size > 0) constraintTypes.add(999); // \u30D8\u30AD\u30B5\u30B4\u30F3\u7528\u30C0\u30DF\u30FCID\n\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tconst cell = grid.cells[r][c];\n\t\t\t\tif (cell.type !== CellType.None) {\n\t\t\t\t\tconstraintCount++;\n\t\t\t\t\tconstraintTypes.add(cell.type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 2. \u5206\u5C90\u306E\u591A\u3055\u306F\u601D\u8003\u306E\u8907\u96D1\u3055\u306B\u6BD4\u4F8B\u3059\u308B\n\t\t// 3. \u63A2\u7D22\u7A7A\u9593\u306E\u5E83\u3055\u306F\u7DCF\u5F53\u305F\u308A\u306E\u5927\u5909\u3055\u306B\u6BD4\u4F8B\u3059\u308B\n\t\t// 4. \u89E3\u306E\u6570\u304C\u591A\u3044\u307B\u3069\u3001\u5076\u7136\u6B63\u89E3\u3092\u898B\u3064\u3051\u3084\u3059\u3044\uFF08\u96E3\u6613\u5EA6\u4F4E\u4E0B\uFF09\n\n\t\tconst branchingFactor = stats.branchingPoints / (stats.totalNodesVisited || 1);\n\t\tconst searchComplexity = Math.log10(stats.totalNodesVisited + 1);\n\n\t\t// \u57FA\u672C\u30B9\u30B3\u30A2\u306E\u8A08\u7B97\n\t\tlet difficulty = (branchingFactor * 10 + searchComplexity * 1.0) / (Math.log2(stats.solutions + 1) + 1);\n\n\t\t// \u5BC6\u5EA6\u306E\u8A08\u7B97\u3068\u88DC\u6B63\n\t\t// \u7A7A\u767D\u30DE\u30B9\u304C\u591A\u3059\u304E\u308B\uFF08\u5236\u7D04\u5BC6\u5EA6\u304C\u4F4E\u3044\uFF09\u30D1\u30BA\u30EB\u306F\u4EBA\u9593\u306B\u306F\u975E\u5E38\u306B\u7C21\u5358\u306B\u611F\u3058\u3089\u308C\u308B\n\t\tconst cellCount = rows * cols;\n\t\tconst density = constraintCount / cellCount;\n\n\t\t// \u5BC6\u5EA6\u304C 0.3 (30%) \u3092\u4E0B\u56DE\u308B\u5834\u5408\u3001\u6025\u6FC0\u306B\u96E3\u6613\u5EA6\u3092\u6E1B\u8870\u3055\u305B\u308B\uFF083\u4E57\u30AB\u30FC\u30D6\uFF09\n\t\tconst densityFactor = density < 0.3 ? Math.pow(density / 0.3, 3) : 1.0;\n\n\t\t// \u5236\u7D04\u306E\u7A2E\u985E\u304C\u5C11\u306A\u3044\u5834\u5408\u306E\u66F4\u306A\u308B\u6E1B\u8870\n\t\tconst typeFactor = constraintTypes.size <= 1 ? 0.4 : 1.0;\n\n\t\tdifficulty *= densityFactor * typeFactor;\n\n\t\t// \u30B0\u30EA\u30C3\u30C9\u30B5\u30A4\u30BA\u3067\u6B63\u898F\u5316 (\u5927\u304D\u3044\u30B0\u30EA\u30C3\u30C9\u307B\u3069\u63A2\u7D22\u7A7A\u9593\u304C\u5E83\u3044\u305F\u3081)\n\t\tconst sizeFactor = Math.sqrt(cellCount) / 4;\n\t\tdifficulty *= sizeFactor;\n\n\t\t// \u6700\u7D42\u7684\u306A\u5024\u3092 0.0 - 1.0 \u306B\u53CE\u3081\u308B\n\t\treturn Math.max(0.01, Math.min(1.0, difficulty / 4));\n\t}\n\n\tprivate exploreSearchSpace(grid: Grid, currIdx: number, visitedMask: bigint, path: number[], hexagonsOnPath: number, totalHexagons: number, adj: { next: number; isHexagon: boolean; isBroken: boolean }[][], endNodes: number[], fingerprints: Set<string>, stats: { totalNodesVisited: number; branchingPoints: number; solutions: number; maxDepth: number; backtracks: number }, limit: number): void {\n\t\tstats.totalNodesVisited++;\n\t\tstats.maxDepth = Math.max(stats.maxDepth, path.length);\n\n\t\tif (stats.totalNodesVisited > limit) return;\n\n\t\tif (endNodes.includes(currIdx)) {\n\t\t\tif (hexagonsOnPath === totalHexagons) {\n\t\t\t\tconst solutionPath = {\n\t\t\t\t\tpoints: path.map((idx) => ({\n\t\t\t\t\t\tx: idx % (grid.cols + 1),\n\t\t\t\t\t\ty: Math.floor(idx / (grid.cols + 1)),\n\t\t\t\t\t})),\n\t\t\t\t};\n\t\t\t\tif (this.validate(grid, solutionPath).isValid) {\n\t\t\t\t\tconst fp = this.getFingerprint(grid, solutionPath.points);\n\t\t\t\t\tif (!fingerprints.has(fp)) {\n\t\t\t\t\t\tfingerprints.add(fp);\n\t\t\t\t\t\tstats.solutions++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.canReachEndOptimized(currIdx, visitedMask, adj, endNodes)) {\n\t\t\tstats.backtracks++;\n\t\t\treturn;\n\t\t}\n\n\t\tconst validMoves = [];\n\t\tfor (const edge of adj[currIdx]) {\n\t\t\tif (edge.isBroken) continue;\n\t\t\tif (visitedMask & (1n << BigInt(edge.next))) continue;\n\n\t\t\tlet possible = true;\n\t\t\tfor (const otherEdge of adj[currIdx]) {\n\t\t\t\tif (otherEdge.isHexagon) {\n\t\t\t\t\tconst isAlreadyOnPath = path.length >= 2 && otherEdge.next === path[path.length - 2];\n\t\t\t\t\tconst isNextMove = otherEdge.next === edge.next;\n\t\t\t\t\tif (!isAlreadyOnPath && !isNextMove) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (possible) {\n\t\t\t\tvalidMoves.push(edge);\n\t\t\t}\n\t\t}\n\n\t\tif (validMoves.length > 1) {\n\t\t\tstats.branchingPoints++;\n\t\t}\n\n\t\tfor (const move of validMoves) {\n\t\t\tpath.push(move.next);\n\t\t\tthis.exploreSearchSpace(grid, move.next, visitedMask | (1n << BigInt(move.next)), path, hexagonsOnPath + (move.isHexagon ? 1 : 0), totalHexagons, adj, endNodes, fingerprints, stats, limit);\n\t\t\tpath.pop();\n\t\t\tif (stats.totalNodesVisited > limit) return;\n\t\t}\n\t}\n\n\t/**\n\t * \u5168\u3066\u306E\u6709\u52B9\u306A\u89E3\u7B54\u30D1\u30B9\u306E\u500B\u6570\u3092\u30AB\u30A6\u30F3\u30C8\u3059\u308B\n\t */\n\tpublic countSolutions(grid: Grid, limit: number = 100): number {\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst nodeCols = cols + 1;\n\t\tconst nodeCount = (rows + 1) * nodeCols;\n\n\t\t// \u30CE\u30FC\u30C9\u60C5\u5831\u306E\u4E8B\u524D\u8A08\u7B97\n\t\tconst adj = Array.from({ length: nodeCount }, () => [] as { next: number; isHexagon: boolean; isBroken: boolean }[]);\n\t\tconst startNodes: number[] = [];\n\t\tconst endNodes: number[] = [];\n\t\tconst hexagonEdges = new Set<string>();\n\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tconst u = r * nodeCols + c;\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) startNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.End) endNodes.push(u);\n\n\t\t\t\t// Right\n\t\t\t\tif (c < cols) {\n\t\t\t\t\tconst v = u + 1;\n\t\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBlocked = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r }));\n\t\t\t\t}\n\t\t\t\t// Down\n\t\t\t\tif (r < rows) {\n\t\t\t\t\tconst v = u + nodeCols;\n\t\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBlocked = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 }));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst fingerprints = new Set<string>();\n\t\tconst totalHexagons = hexagonEdges.size;\n\n\t\tfor (const startIdx of startNodes) {\n\t\t\tthis.findPathsOptimized(grid, startIdx, 1n << BigInt(startIdx), [startIdx], 0, totalHexagons, adj, endNodes, fingerprints, limit);\n\t\t\tif (fingerprints.size >= limit) break;\n\t\t}\n\n\t\treturn fingerprints.size;\n\t}\n\n\tprivate findPathsOptimized(grid: Grid, currIdx: number, visitedMask: bigint, path: number[], hexagonsOnPath: number, totalHexagons: number, adj: { next: number; isHexagon: boolean; isBroken: boolean }[][], endNodes: number[], fingerprints: Set<string>, limit: number): void {\n\t\tif (fingerprints.size >= limit) return;\n\n\t\t// \u7D42\u70B9\u306B\u5230\u9054\u3057\u305F\u5834\u5408\n\t\tif (endNodes.includes(currIdx)) {\n\t\t\tif (hexagonsOnPath === totalHexagons) {\n\t\t\t\tconst solutionPath = {\n\t\t\t\t\tpoints: path.map((idx) => ({\n\t\t\t\t\t\tx: idx % (grid.cols + 1),\n\t\t\t\t\t\ty: Math.floor(idx / (grid.cols + 1)),\n\t\t\t\t\t})),\n\t\t\t\t};\n\t\t\t\tif (this.validate(grid, solutionPath).isValid) {\n\t\t\t\t\tfingerprints.add(this.getFingerprint(grid, solutionPath.points));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Note: The Witness\u306E\u30EB\u30FC\u30EB\u4E0A\u3001\u7D42\u70B9\u304B\u3089\u3055\u3089\u306B\u9032\u3080\u3053\u3068\u306F\u3067\u304D\u306A\u3044\n\t\t\treturn;\n\t\t}\n\n\t\t// \u679D\u5208\u308A: \u7D42\u70B9\u3078\u306E\u5230\u9054\u53EF\u80FD\u6027\n\t\tif (!this.canReachEndOptimized(currIdx, visitedMask, adj, endNodes)) return;\n\n\t\tfor (const edge of adj[currIdx]) {\n\t\t\tif (edge.isBroken) continue;\n\t\t\tif (visitedMask & (1n << BigInt(edge.next))) continue;\n\n\t\t\t// Hexagon pruning:\n\t\t\t// \u73FE\u5728\u306E\u30CE\u30FC\u30C9(currIdx)\u306B\u63A5\u7D9A\u3055\u308C\u3066\u3044\u308B\u30D8\u30AD\u30B5\u30B4\u30F3\u30A8\u30C3\u30B8\u306E\u3046\u3061\u3001\n\t\t\t// \u307E\u3060\u4F7F\u3063\u3066\u304A\u3089\u305A\u3001\u304B\u3064\u6B21\u306E\u79FB\u52D5(next)\u3067\u3082\u4F7F\u308F\u306A\u3044\u3082\u306E\u306F\u3001\u3082\u3046\u4E8C\u5EA6\u3068\u4F7F\u3048\u306A\u3044\u3002\n\t\t\tlet possible = true;\n\t\t\tfor (const otherEdge of adj[currIdx]) {\n\t\t\t\tif (otherEdge.isHexagon) {\n\t\t\t\t\t// \u3053\u306E\u30D8\u30AD\u30B5\u30B4\u30F3\u30A8\u30C3\u30B8\u304C\u30D1\u30B9\u306B\u542B\u307E\u308C\u3066\u3044\u306A\u3044\u304B\u30C1\u30A7\u30C3\u30AF\n\t\t\t\t\t// \u30D1\u30B9\u306B\u542B\u307E\u308C\u3066\u3044\u308B\u306A\u3089 otherEdge.next \u306F path[path.length-2] \u306E\u306F\u305A\n\t\t\t\t\tconst isAlreadyOnPath = path.length >= 2 && otherEdge.next === path[path.length - 2];\n\t\t\t\t\tconst isNextMove = otherEdge.next === edge.next;\n\t\t\t\t\tif (!isAlreadyOnPath && !isNextMove) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possible) continue;\n\n\t\t\tpath.push(edge.next);\n\t\t\tthis.findPathsOptimized(grid, edge.next, visitedMask | (1n << BigInt(edge.next)), path, hexagonsOnPath + (edge.isHexagon ? 1 : 0), totalHexagons, adj, endNodes, fingerprints, limit);\n\t\t\tpath.pop();\n\t\t\tif (fingerprints.size >= limit) return;\n\t\t}\n\t}\n\n\tprivate canReachEndOptimized(curr: number, visitedMask: bigint, adj: { next: number; isBroken: boolean }[][], endNodes: number[]): boolean {\n\t\tlet queue = [curr];\n\t\tlet localVisited = visitedMask;\n\n\t\tlet head = 0;\n\t\twhile (head < queue.length) {\n\t\t\tconst u = queue[head++];\n\t\t\tif (endNodes.includes(u)) return true;\n\n\t\t\tfor (const edge of adj[u]) {\n\t\t\t\tif (!edge.isBroken && !(localVisited & (1n << BigInt(edge.next)))) {\n\t\t\t\t\tlocalVisited |= 1n << BigInt(edge.next);\n\t\t\t\t\tqueue.push(edge.next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate getFingerprint(grid: Grid, path: Point[]): string {\n\t\tconst regions = this.calculateRegions(grid, path);\n\t\tconst regionFingerprints = regions\n\t\t\t.map((region) => {\n\t\t\t\tconst marks = region\n\t\t\t\t\t.map((p) => grid.cells[p.y][p.x])\n\t\t\t\t\t.filter((c) => c.type !== CellType.None)\n\t\t\t\t\t.map((c) => `${c.type}:${c.color}`)\n\t\t\t\t\t.sort();\n\t\t\t\treturn marks.join(\",\");\n\t\t\t})\n\t\t\t.sort();\n\t\treturn regionFingerprints.filter((f) => f.length > 0).join(\"|\") || \"empty\";\n\t}\n}\n", "import { Grid } from \"./grid\";\nimport { CellType, Color, type EdgeConstraint, EdgeType, type GenerationOptions, NodeType, type Point } from \"./types\";\nimport { PuzzleValidator } from \"./validator\";\n\nexport class PuzzleGenerator {\n\t/**\n\t * \u30D1\u30BA\u30EB\u3092\u751F\u6210\u3059\u308B\n\t * @param rows \u884C\u6570\n\t * @param cols \u5217\u6570\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\n\t */\n\tpublic generate(rows: number, cols: number, options: GenerationOptions = {}): Grid {\n\t\tconst targetDifficulty = options.difficulty ?? 0.5;\n\t\tconst validator = new PuzzleValidator();\n\n\t\tlet bestGrid: Grid | null = null;\n\t\tlet bestScore = -1;\n\n\t\t// \u30B0\u30EA\u30C3\u30C9\u30B5\u30A4\u30BA\u306B\u5FDC\u3058\u3066\u8A66\u884C\u56DE\u6570\u3092\u8ABF\u6574\n\t\tconst maxAttempts = rows * cols > 30 ? 60 : 100;\n\n\t\tfor (let attempt = 0; attempt < maxAttempts; attempt++) {\n\t\t\tconst grid = this.generateOnce(rows, cols, options);\n\n\t\t\t// \u5168\u3066\u306E\u8981\u6C42\u3055\u308C\u305F\u5236\u7D04\u30BF\u30A4\u30D7\u304C\u542B\u307E\u308C\u3066\u3044\u308B\u304B\u30C1\u30A7\u30C3\u30AF\n\t\t\tif (!this.checkAllRequestedConstraintsPresent(grid, options)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst difficulty = validator.calculateDifficulty(grid);\n\n\t\t\tif (difficulty === 0) continue;\n\n\t\t\tconst diffFromTarget = Math.abs(difficulty - targetDifficulty);\n\n\t\t\t// \u3088\u308A\u76EE\u6A19\u306B\u8FD1\u3044\u3082\u306E\u3092\u63A1\u7528\n\t\t\tif (bestGrid === null || diffFromTarget < Math.abs(bestScore - targetDifficulty)) {\n\t\t\t\tbestScore = difficulty;\n\t\t\t\tbestGrid = grid;\n\t\t\t}\n\n\t\t\t// \u975E\u5E38\u306B\u9AD8\u3044\u96E3\u6613\u5EA6\u304C\u6C42\u3081\u3089\u308C\u3066\u3044\u3066\u3001\u5341\u5206\u306A\u30B9\u30B3\u30A2\u304C\u5F97\u3089\u308C\u305F\u3089\u7D42\u4E86\n\t\t\tif (targetDifficulty > 0.8 && difficulty > 0.8) break;\n\t\t\t// \u5341\u5206\u306B\u8FD1\u3044\u3082\u306E\u304C\u5F97\u3089\u308C\u305F\u3089\u7D42\u4E86\n\t\t\tif (diffFromTarget < 0.05) break;\n\t\t}\n\n\t\treturn bestGrid || this.generateOnce(rows, cols, options);\n\t}\n\n\tprivate generateOnce(rows: number, cols: number, options: GenerationOptions): Grid {\n\t\tconst grid = new Grid(rows, cols);\n\n\t\t// 1. \u30B9\u30BF\u30FC\u30C8\u3068\u30B4\u30FC\u30EB\u306E\u8A2D\u5B9A (\u901A\u5E38\u306F\u5DE6\u4E0B\u30B9\u30BF\u30FC\u30C8\u3001\u53F3\u4E0A\u30B4\u30FC\u30EB\u306A\u3069)\n\t\tconst startPoint: Point = { x: 0, y: rows }; // \u5DE6\u4E0B\n\t\tconst endPoint: Point = { x: cols, y: 0 }; // \u53F3\u4E0A\n\n\t\tgrid.nodes[startPoint.y][startPoint.x].type = NodeType.Start;\n\t\tgrid.nodes[endPoint.y][endPoint.x].type = NodeType.End;\n\n\t\t// 2. \u6B63\u89E3\u30D1\u30B9\u3092\u751F\u6210 (\u30E9\u30F3\u30C0\u30E0\u30A6\u30A9\u30FC\u30AF / DFS)\n\t\tconst solutionPath = this.generateRandomPath(grid, startPoint, endPoint);\n\n\t\t// 3. \u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u5236\u7D04\uFF08\u30EB\u30FC\u30EB\uFF09\u3092\u914D\u7F6E\n\t\t// \u30D1\u30B9\u304C\u901A\u904E\u3059\u308B\u30A8\u30C3\u30B8\u306B\u30D8\u30AD\u30B5\u30B4\u30F3\u3092\u7F6E\u3044\u305F\u308A\u3001\u5206\u5272\u3055\u308C\u305F\u9818\u57DF\u306B\u8272\u3092\u5857\u308B\n\t\tthis.applyConstraintsBasedOnPath(grid, solutionPath, options);\n\n\t\t// 4. \u5207\u65AD\uFF08Broken/Absent\uFF09\u3092\u914D\u7F6E\n\t\tif (options.useBrokenEdges) {\n\t\t\tthis.applyBrokenEdges(grid, solutionPath, options);\n\t\t}\n\n\t\t// 5. \u6D6E\u5CF6\u306E\u524A\u9664\u3068\u5916\u5468\u306E\u8ABF\u6574\n\t\tthis.cleanGrid(grid);\n\n\t\treturn grid;\n\t}\n\n\t/**\n\t * Randomized DFS\u3092\u7528\u3044\u3066Start\u304B\u3089End\u3078\u306E\u4E00\u672C\u9053\u3092\u751F\u6210\u3059\u308B\n\t */\n\tprivate generateRandomPath(grid: Grid, start: Point, end: Point): Point[] {\n\t\tconst visited = new Set<string>();\n\t\tconst path: Point[] = [];\n\n\t\tconst stack: Point[] = [start];\n\t\tconst parentMap = new Map<string, Point | null>();\n\t\tparentMap.set(`${start.x},${start.y}`, null);\n\n\t\t// \u5B8C\u5168\u306A\u30E9\u30F3\u30C0\u30E0\u3067\u306F\u306A\u304F\u3001\u30B4\u30FC\u30EB\u65B9\u5411\u3078\u5411\u304B\u3046\u30D0\u30A4\u30A2\u30B9\u3092\u304B\u3051\u308B\u3053\u3068\u3082\u53EF\u80FD\u3060\u304C\n\t\t// \u3053\u3053\u3067\u306F\u5358\u7D14\u306A\u30D0\u30C3\u30AF\u30C8\u30E9\u30C3\u30AD\u30F3\u30B0\u4ED8\u304DDFS\u3067\u63A2\u7D22\u3059\u308B\n\n\t\tconst findPath = (current: Point): boolean => {\n\t\t\tvisited.add(`${current.x},${current.y}`);\n\t\t\tpath.push(current);\n\n\t\t\tif (current.x === end.x && current.y === end.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// \u6B21\u306E\u5019\u88DC\u3092\u53D6\u5F97\n\t\t\tconst neighbors = this.getValidNeighbors(grid, current, visited);\n\t\t\t// \u30E9\u30F3\u30C0\u30E0\u306B\u30B7\u30E3\u30C3\u30D5\u30EB\n\t\t\tthis.shuffleArray(neighbors);\n\n\t\t\tfor (const next of neighbors) {\n\t\t\t\tif (findPath(next)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// \u884C\u304D\u6B62\u307E\u308A\u306A\u3089\u30D0\u30C3\u30AF\u30C8\u30E9\u30C3\u30AF\n\t\t\tpath.pop();\n\t\t\treturn false;\n\t\t};\n\n\t\t// \u78BA\u5B9F\u306B\u30D1\u30B9\u3092\u898B\u3064\u3051\u308B\u305F\u3081\u3001\u7C21\u6613\u7684\u306A\u5B9F\u88C5\u3068\u3057\u3066\u3044\u307E\u3059\u3002\n\t\t// \u672C\u683C\u7684\u306AWitness\u30D1\u30BA\u30EB\u3067\u306F\u300C\u9577\u304F\u86C7\u884C\u3059\u308B\u30D1\u30B9\u300D\u304C\u597D\u307E\u3057\u3044\u305F\u3081\u3001\n\t\t// \u5B9F\u969B\u306B\u306FPrim\u6CD5\u306A\u3069\u3067\u5168\u57DF\u6728\u3092\u4F5C\u3063\u3066\u304B\u3089\u30D1\u30B9\u3092\u5207\u308A\u51FA\u3059\u624B\u6CD5\u304C\u63A8\u5968\u3055\u308C\u307E\u3059\u3002\n\t\t// \u3053\u3053\u3067\u306F\u57FA\u672C\u7684\u306ADFS\u63A2\u7D22\u3092\u884C\u3044\u307E\u3059\u3002\n\t\tfindPath(start);\n\n\t\treturn path;\n\t}\n\n\tprivate getValidNeighbors(grid: Grid, p: Point, visited: Set<string>): Point[] {\n\t\tconst candidates: Point[] = [];\n\t\tconst directions = [\n\t\t\t{ x: 0, y: -1 }, // Up\n\t\t\t{ x: 1, y: 0 }, // Right\n\t\t\t{ x: 0, y: 1 }, // Down\n\t\t\t{ x: -1, y: 0 }, // Left\n\t\t];\n\n\t\tfor (const d of directions) {\n\t\t\tconst nx = p.x + d.x;\n\t\t\tconst ny = p.y + d.y;\n\n\t\t\tif (nx >= 0 && nx <= grid.cols && ny >= 0 && ny <= grid.rows) {\n\t\t\t\tif (!visited.has(`${nx},${ny}`)) {\n\t\t\t\t\tcandidates.push({ x: nx, y: ny });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn candidates;\n\t}\n\n\tprivate applyBrokenEdges(grid: Grid, path: Point[], options: GenerationOptions) {\n\t\tconst complexity = options.complexity ?? 0.5;\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t}\n\n\t\t// \u30D1\u30B9\u306B\u4F7F\u308F\u308C\u3066\u3044\u306A\u3044\u30A8\u30C3\u30B8\u3092\u53CE\u96C6\n\t\tconst unusedEdges: { type: \"h\" | \"v\"; r: number; c: number; p1: Point; p2: Point }[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tconst p1 = { x: c, y: r };\n\t\t\t\tconst p2 = { x: c + 1, y: r };\n\t\t\t\tif (!pathEdges.has(this.getEdgeKey(p1, p2))) {\n\t\t\t\t\tunusedEdges.push({ type: \"h\", r, c, p1, p2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tconst p1 = { x: c, y: r };\n\t\t\t\tconst p2 = { x: c, y: r + 1 };\n\t\t\t\tif (!pathEdges.has(this.getEdgeKey(p1, p2))) {\n\t\t\t\t\tunusedEdges.push({ type: \"v\", r, c, p1, p2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.shuffleArray(unusedEdges);\n\n\t\t// \u6700\u5C0F\u9650\u306E\u8A2D\u7F6E (1\u301C3\u500B\u7A0B\u5EA6\u3001\u307E\u305F\u306F\u8907\u96D1\u5EA6\u306B\u5FDC\u3058\u3066)\n\t\tconst targetCount = Math.max(1, Math.floor(complexity * 4));\n\t\tlet placed = 0;\n\n\t\tfor (const edge of unusedEdges) {\n\t\t\tif (placed >= targetCount) break;\n\n\t\t\t// 80%\u306E\u78BA\u7387\u3067Broken(1), 20%\u306E\u78BA\u7387\u3067Absent(2)\n\t\t\tlet type = Math.random() < 0.8 ? EdgeType.Broken : EdgeType.Absent;\n\n\t\t\t// \u30DE\u30FC\u30AF\u304C\u542B\u307E\u308C\u308B\u30DE\u30B9\u306E\u5916\u5468\u3067Absent\u306F\u7981\u6B62\n\t\t\tif (type === EdgeType.Absent && this.isAdjacentToMark(grid, edge)) {\n\t\t\t\ttype = EdgeType.Broken;\n\t\t\t}\n\n\t\t\tif (edge.type === \"h\") {\n\t\t\t\tgrid.hEdges[edge.r][edge.c].type = type;\n\t\t\t} else {\n\t\t\t\tgrid.vEdges[edge.r][edge.c].type = type;\n\t\t\t}\n\t\t\tplaced++;\n\t\t}\n\n\t\t// \u5341\u5B57\u90E8\u5206\u30674\u65B9\u5411\uFF08\u307E\u305F\u306F\u9685\u306E\u5168\u65B9\u5411\uFF09\u5168\u3066\u304CBroken,Absent\u306E\u5834\u5408\u306F\u305D\u306E4\u65B9\u5411\u306FAbsent\u306B\u3059\u308B\n\t\t// \u305F\u3060\u3057\u3001\u30DE\u30FC\u30AF\u306E\u5468\u56F2\u306FAbsent\u7981\u6B62\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tconst edgesWithMeta: { e: EdgeConstraint; type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\t\t\tif (c > 0) edgesWithMeta.push({ e: grid.hEdges[r][c - 1], type: \"h\", r, c: c - 1 });\n\t\t\t\tif (c < grid.cols) edgesWithMeta.push({ e: grid.hEdges[r][c], type: \"h\", r, c });\n\t\t\t\tif (r > 0) edgesWithMeta.push({ e: grid.vEdges[r - 1][c], type: \"v\", r: r - 1, c });\n\t\t\t\tif (r < grid.rows) edgesWithMeta.push({ e: grid.vEdges[r][c], type: \"v\", r, c });\n\n\t\t\t\tconst allCuts = edgesWithMeta.every((m) => m.e.type === EdgeType.Broken || m.e.type === EdgeType.Absent);\n\t\t\t\tif (allCuts) {\n\t\t\t\t\t// \u30DE\u30FC\u30AF\u306E\u5468\u56F2\u3067\u306A\u3044\u304B\u78BA\u8A8D\n\t\t\t\t\tconst noneNearMark = edgesWithMeta.every((m) => !this.isAdjacentToMark(grid, m));\n\t\t\t\t\tif (noneNearMark) {\n\t\t\t\t\t\tfor (const m of edgesWithMeta) {\n\t\t\t\t\t\t\tm.e.type = EdgeType.Absent;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate cleanGrid(grid: Grid) {\n\t\t// 1. \u6D6E\u5CF6\uFF08\u30B9\u30BF\u30FC\u30C8\u304B\u3089\u8FBF\u308C\u306A\u3044\u30CE\u30FC\u30C9\u30FB\u30A8\u30C3\u30B8\uFF09\u3092Absent\u306B\u5909\u63DB\n\t\tconst startNodes: { x: number; y: number }[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) {\n\t\t\t\t\tstartNodes.push({ x: c, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst reachableNodes = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [...startNodes];\n\t\tfor (const p of startNodes) reachableNodes.add(`${p.x},${p.y}`);\n\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.vEdges[curr.y - 1]?.[curr.x] }, // Up\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.vEdges[curr.y]?.[curr.x] }, // Down\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.hEdges[curr.y]?.[curr.x - 1] }, // Left\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.hEdges[curr.y]?.[curr.x] }, // Right\n\t\t\t];\n\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.edge && n.edge.type !== EdgeType.Absent) {\n\t\t\t\t\tif (!reachableNodes.has(`${n.nx},${n.ny}`)) {\n\t\t\t\t\t\treachableNodes.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// \u8FBF\u308C\u306A\u3044\u30A8\u30C3\u30B8\u3092Absent\u306B\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (!reachableNodes.has(`${c},${r}`) || !reachableNodes.has(`${c + 1},${r}`)) {\n\t\t\t\t\tgrid.hEdges[r][c].type = EdgeType.Absent;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tif (!reachableNodes.has(`${c},${r}`) || !reachableNodes.has(`${c},${r + 1}`)) {\n\t\t\t\t\tgrid.vEdges[r][c].type = EdgeType.Absent;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 2. \u5916\u5468\u304B\u3089\u30EA\u30FC\u30AF\u3057\u3066\u3044\u308B\u30BB\u30EB\u306E\u30DE\u30FC\u30AF\u3092\u524A\u9664\n\t\tconst external = this.getExternalCells(grid);\n\t\tfor (const cellKey of external) {\n\t\t\tconst [c, r] = cellKey.split(\",\").map(Number);\n\t\t\tgrid.cells[r][c].type = CellType.None;\n\t\t}\n\t}\n\n\tprivate getExternalCells(grid: Grid): Set<string> {\n\t\tconst external = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [];\n\n\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\tif (grid.hEdges[0][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},0`)) {\n\t\t\t\t\texternal.add(`${c},0`);\n\t\t\t\t\tqueue.push({ x: c, y: 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.hEdges[grid.rows][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},${grid.rows - 1}`)) {\n\t\t\t\t\texternal.add(`${c},${grid.rows - 1}`);\n\t\t\t\t\tqueue.push({ x: c, y: grid.rows - 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tif (grid.vEdges[r][0].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`0,${r}`)) {\n\t\t\t\t\texternal.add(`0,${r}`);\n\t\t\t\t\tqueue.push({ x: 0, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.vEdges[r][grid.cols].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${grid.cols - 1},${r}`)) {\n\t\t\t\t\texternal.add(`${grid.cols - 1},${r}`);\n\t\t\t\t\tqueue.push({ x: grid.cols - 1, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.hEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.hEdges[curr.y + 1][curr.x] },\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x + 1] },\n\t\t\t];\n\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\tif (!external.has(`${n.nx},${n.ny}`) && n.edge.type === EdgeType.Absent) {\n\t\t\t\t\t\texternal.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn external;\n\t}\n\n\tprivate isAdjacentToMark(grid: Grid, edge: { type: \"h\" | \"v\"; r: number; c: number }): boolean {\n\t\tif (edge.type === \"h\") {\n\t\t\t// \u4E0A\u306E\u30BB\u30EB\n\t\t\tif (edge.r > 0 && grid.cells[edge.r - 1][edge.c].type !== CellType.None) return true;\n\t\t\t// \u4E0B\u306E\u30BB\u30EB\n\t\t\tif (edge.r < grid.rows && grid.cells[edge.r][edge.c].type !== CellType.None) return true;\n\t\t} else {\n\t\t\t// \u5DE6\u306E\u30BB\u30EB\n\t\t\tif (edge.c > 0 && grid.cells[edge.r][edge.c - 1].type !== CellType.None) return true;\n\t\t\t// \u53F3\u306E\u30BB\u30EB\n\t\t\tif (edge.c < grid.cols && grid.cells[edge.r][edge.c].type !== CellType.None) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate hasIsolatedMark(grid: Grid): boolean {\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (grid.cells[r][c].type === CellType.None) continue;\n\n\t\t\t\t// Check 4 edges of this cell\n\t\t\t\tconst edges = [\n\t\t\t\t\tgrid.hEdges[r][c], // Top\n\t\t\t\t\tgrid.hEdges[r + 1][c], // Bottom\n\t\t\t\t\tgrid.vEdges[r][c], // Left\n\t\t\t\t\tgrid.vEdges[r][c + 1], // Right\n\t\t\t\t];\n\n\t\t\t\tconst passableCount = edges.filter((e) => e.type === EdgeType.Normal || e.type === EdgeType.Hexagon).length;\n\t\t\t\tif (passableCount === 0) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n\n\tprivate TETRIS_SHAPES = [\n\t\t[[1]], // 1x1\n\t\t[[1, 1]], // 1x2\n\t\t[[1, 1, 1]], // 1x3\n\t\t[\n\t\t\t[1, 1],\n\t\t\t[1, 0],\n\t\t], // L-3\n\t\t[\n\t\t\t[0, 1],\n\t\t\t[1, 0],\n\t\t], // \u659C\u30812x2\n\t\t[[1, 1, 1, 1]], // I\n\t\t[\n\t\t\t[1, 1],\n\t\t\t[1, 1],\n\t\t], // O\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[0, 1, 0],\n\t\t], // T-2\n\t\t[\n\t\t\t[1, 1, 0],\n\t\t\t[0, 1, 1],\n\t\t], // Z-2\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[1, 0, 0],\n\t\t], // L\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[0, 0, 1],\n\t\t], // L-i\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[1, 0, 1],\n\t\t], // \u30B3\n\t\t[\n\t\t\t[0, 1, 0],\n\t\t\t[1, 0, 1],\n\t\t], // \u659C\u30812x3\n\t\t[\n\t\t\t[1, 0, 0, 1],\n\t\t\t[1, 0, 0, 1],\n\t\t], // \u30B5\u30F3\u30C9\u30A4\u30C3\u30C1\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[0, 1, 0],\n\t\t\t[0, 1, 0],\n\t\t], // T\n\t\t[\n\t\t\t[1, 1, 0],\n\t\t\t[0, 1, 0],\n\t\t\t[0, 1, 1],\n\t\t], // Z\n\t\t[\n\t\t\t[0, 1, 1],\n\t\t\t[0, 1, 0],\n\t\t\t[1, 1, 0],\n\t\t], // Z-i\n\t\t[\n\t\t\t[1, 1, 1],\n\t\t\t[1, 0, 1],\n\t\t\t[1, 1, 1],\n\t\t], // \u30ED\n\t];\n\n\tprivate applyConstraintsBasedOnPath(grid: Grid, path: Point[], options: GenerationOptions) {\n\t\tconst complexity = options.complexity ?? 0.5;\n\t\tconst useHexagons = options.useHexagons ?? true;\n\t\tconst useSquares = options.useSquares ?? true;\n\t\tconst useStars = options.useStars ?? true;\n\t\tconst useTetris = options.useTetris ?? false;\n\n\t\tlet hexagonsPlaced = 0;\n\t\tlet squaresPlaced = 0;\n\t\tlet starsPlaced = 0;\n\t\tlet tetrisPlaced = 0;\n\n\t\t// A. \u30D1\u30B9\u4E0A\u306E\u30D8\u30AD\u30B5\u30B4\u30F3 (Hexagon) \u914D\u7F6E\n\t\tif (useHexagons) {\n\t\t\tconst targetDifficulty = options.difficulty ?? 0.5;\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst p1 = path[i];\n\t\t\t\tconst p2 = path[i + 1];\n\n\t\t\t\tconst neighbors = this.getValidNeighbors(grid, p1, new Set());\n\t\t\t\tconst isBranching = neighbors.length > 2;\n\n\t\t\t\tlet prob = complexity * 0.4;\n\t\t\t\tif (isBranching) {\n\t\t\t\t\tprob = targetDifficulty < 0.4 ? prob * 1.0 : prob * 0.5;\n\t\t\t\t}\n\n\t\t\t\tif (Math.random() < prob) {\n\t\t\t\t\tthis.setEdgeHexagon(grid, p1, p2);\n\t\t\t\t\thexagonsPlaced++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// \u5F37\u5236\u914D\u7F6E\uFF1A\u4E00\u3064\u3082\u7F6E\u304B\u308C\u306A\u304B\u3063\u305F\u5834\u5408\n\t\t\tif (hexagonsPlaced === 0 && path.length >= 2) {\n\t\t\t\tconst idx = Math.floor(Math.random() * (path.length - 1));\n\t\t\t\tthis.setEdgeHexagon(grid, path[idx], path[idx + 1]);\n\t\t\t}\n\t\t}\n\n\t\t// B. \u9818\u57DF\u3054\u3068\u306E\u5236\u7D04\u914D\u7F6E (Squares & Stars)\n\n\t\tif (useSquares || useStars) {\n\t\t\tconst regions = this.calculateRegions(grid, path);\n\t\t\tconst availableColors = [Color.Black, Color.White, Color.Red, Color.Blue];\n\n\t\t\t// \u30B7\u30E3\u30C3\u30D5\u30EB\u3057\u3066\u3001\u5F37\u5236\u914D\u7F6E\u304C\u5FC5\u8981\u306A\u5834\u5408\u306B\u5099\u3048\u308B\n\t\t\tconst regionIndices = Array.from({ length: regions.length }, (_, i) => i);\n\t\t\tthis.shuffleArray(regionIndices);\n\n\t\t\tfor (const idx of regionIndices) {\n\t\t\t\tconst region = regions[idx];\n\t\t\t\t// \u96E3\u6613\u5EA6\u304C\u9AD8\u3044\u5834\u5408\u306F\u5236\u7D04\u3092\u30B9\u30AD\u30C3\u30D7\u3057\u306B\u304F\u304F\u3059\u308B\n\t\t\t\tconst skipProb = (options.difficulty ?? 0.5) > 0.7 ? 0.4 : 0.2;\n\n\t\t\t\t// \u5F37\u5236\u914D\u7F6E\u304C\u5FC5\u8981\u306A\u5834\u5408\uFF08\u6700\u5F8C\u306E\u65B9\u306E\u9818\u57DF\u3067\u307E\u3060\u4F55\u3082\u7F6E\u304B\u308C\u3066\u3044\u306A\u3044\u5834\u5408\uFF09\u306F\u30B9\u30AD\u30C3\u30D7\u3057\u306A\u3044\n\t\t\t\tconst forceOne = (useSquares && squaresPlaced === 0) || (useStars && starsPlaced === 0) || (useTetris && tetrisPlaced === 0);\n\t\t\t\tconst isLastFew = idx === regionIndices[regionIndices.length - 1];\n\n\t\t\t\tif (!forceOne || !isLastFew) {\n\t\t\t\t\tif (Math.random() > skipProb + complexity * 0.5) continue;\n\t\t\t\t}\n\n\t\t\t\tconst potentialCells = [...region];\n\t\t\t\tthis.shuffleArray(potentialCells);\n\n\t\t\t\t// 1. \u3053\u306E\u9818\u57DF\u306E\u56DB\u89D2\u5F62(Square)\u306E\u8272\u3092\u6C7A\u5B9A (1\u8272\u306E\u307F)\n\t\t\t\tlet squareColor = availableColors[Math.floor(Math.random() * availableColors.length)];\n\n\t\t\t\t// \u30C8\u30B2\u304C\u306A\u304F2\u8272\u76EE\u304C\u5FC5\u8981\u306A\u5834\u5408\u3001\u9055\u3046\u8272\u3092\u9078\u3076\n\t\t\t\tif (useSquares && !useStars && isLastFew) {\n\t\t\t\t\tconst currentColors = new Set<number>();\n\t\t\t\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t\t\t\tif (grid.cells[r][c].type === CellType.Square) currentColors.add(grid.cells[r][c].color);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (currentColors.size === 1) {\n\t\t\t\t\t\tconst otherColors = availableColors.filter((c) => !currentColors.has(c));\n\t\t\t\t\t\tif (otherColors.length > 0) {\n\t\t\t\t\t\t\tsquareColor = otherColors[Math.floor(Math.random() * otherColors.length)];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet numSquares = 0;\n\n\t\t\t\t// \u56DB\u89D2\u5F62\u3092\u914D\u7F6E\u3059\u308B\u304B\u6C7A\u5B9A\n\t\t\t\tlet shouldPlaceSquare = useSquares && Math.random() < 0.5 + complexity * 0.3;\n\t\t\t\tif (useSquares && squaresPlaced === 0 && isLastFew) shouldPlaceSquare = true;\n\n\t\t\t\t// \u30C8\u30B2\u304C\u306A\u304F\u56DB\u89D2\u304C\u5FC5\u8981\u306A\u5834\u5408\u3001\u6700\u4F4E\u3067\u30822\u3064\u306E\u9818\u57DF\u306B\u56DB\u89D2\u3092\u7F6E\u304F\u3088\u3046\u306B\u8A98\u5C0E\n\t\t\t\tif (useSquares && !useStars && isLastFew) {\n\t\t\t\t\tconst currentColors = new Set<number>();\n\t\t\t\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t\t\t\tif (grid.cells[r][c].type === CellType.Square) currentColors.add(grid.cells[r][c].color);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (currentColors.size < 2 && squaresPlaced > 0) {\n\t\t\t\t\t\tshouldPlaceSquare = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldPlaceSquare) {\n\t\t\t\t\tconst maxSquares = Math.min(potentialCells.length, 4);\n\t\t\t\t\tnumSquares = Math.floor(Math.random() * maxSquares);\n\t\t\t\t\tif (numSquares === 0 && squaresPlaced === 0) numSquares = 1;\n\n\t\t\t\t\tfor (let i = 0; i < numSquares; i++) {\n\t\t\t\t\t\tif (potentialCells.length === 0) break;\n\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Square;\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = squareColor;\n\t\t\t\t\t\tsquaresPlaced++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 2. \u30C6\u30C8\u30EA\u30B9(Tetris)\u3092\u914D\u7F6E\u3059\u308B\u304B\u6C7A\u5B9A\n\t\t\t\tif (useTetris) {\n\t\t\t\t\tlet shouldPlaceTetris = Math.random() < 0.2 + complexity * 0.3;\n\t\t\t\t\tif (tetrisPlaced === 0 && isLastFew) shouldPlaceTetris = true;\n\n\t\t\t\t\t// \u3042\u307E\u308A\u306B\u5927\u304D\u3044\u9818\u57DF\u306F\u30C6\u30C8\u30EA\u30B9\u3067\u57CB\u3081\u308B\u306E\u304C\u5927\u5909\u3001\u304B\u3064\u89E3\u7B54\u304C\u81EA\u660E\u306B\u306A\u308A\u3084\u3059\u3044\u305F\u3081\u5236\u9650\n\t\t\t\t\t// \u305F\u3060\u3057\u3001\u4E00\u3064\u3082\u7F6E\u304B\u308C\u3066\u3044\u306A\u3044\u5834\u5408\u306F\u5C11\u3057\u5236\u9650\u3092\u7DE9\u3081\u308B\n\t\t\t\t\tconst maxTetrisPerRegion = tetrisPlaced === 0 && isLastFew ? 6 : 4;\n\t\t\t\t\tif (shouldPlaceTetris && potentialCells.length > 0 && region.length <= maxTetrisPerRegion * 4) {\n\t\t\t\t\t\t// \u9818\u57DF\u5168\u4F53\u3092\u30C6\u30C8\u30EA\u30B9\u3067\u57CB\u3081\u308B\u5FC5\u8981\u304C\u3042\u308B\n\t\t\t\t\t\t// \u5B9F\u969B\u306B\u30BF\u30A4\u30EA\u30F3\u30B0\u53EF\u80FD\u304B\u8A66\u884C\u3057\u306A\u304C\u3089\u30D4\u30FC\u30B9\u3092\u9078\u3076\n\t\t\t\t\t\tconst tiledPieces = this.generateTiling(region, maxTetrisPerRegion);\n\n\t\t\t\t\t\tif (tiledPieces) {\n\t\t\t\t\t\t\tfor (const p of tiledPieces) {\n\t\t\t\t\t\t\t\tif (potentialCells.length === 0) break;\n\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = p.isRotated ? CellType.TetrisRotated : CellType.Tetris;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].shape = p.shape;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = Color.None;\n\t\t\t\t\t\t\t\ttetrisPlaced++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 3. \u5404\u8272\u306B\u3064\u3044\u3066\u30C8\u30B2(Star)\u3092\u914D\u7F6E\u3059\u308B\u304B\u6C7A\u5B9A\n\t\t\t\tif (useStars) {\n\t\t\t\t\tfor (const color of availableColors) {\n\t\t\t\t\t\tif (potentialCells.length < 1) break;\n\n\t\t\t\t\t\tlet shouldPlaceStar = Math.random() < 0.2 + complexity * 0.3;\n\t\t\t\t\t\tif (starsPlaced === 0 && isLastFew) shouldPlaceStar = true;\n\n\t\t\t\t\t\tif (!shouldPlaceStar) continue;\n\n\t\t\t\t\t\t// \u661F\u306E\u30DA\u30A2\u5224\u5B9A\u306B\u30C6\u30C8\u30EA\u30B9\u3082\u30AB\u30A6\u30F3\u30C8\u3059\u308B\n\t\t\t\t\t\tconst tetrisInRegion = region.map((p) => grid.cells[p.y][p.x]).filter((c) => c.type === CellType.Tetris || c.type === CellType.TetrisRotated);\n\t\t\t\t\t\tlet existingColorCount = 0;\n\t\t\t\t\t\tif (color === squareColor) existingColorCount += numSquares;\n\t\t\t\t\t\texistingColorCount += tetrisInRegion.filter((c) => c.color === color).length;\n\n\t\t\t\t\t\tif (existingColorCount === 1) {\n\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\n\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\n\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t} else if (existingColorCount === 0) {\n\t\t\t\t\t\t\t// \u307E\u3060\u30DA\u30A2\u5BFE\u8C61\u304C\u306A\u3044\u5834\u5408\u300150%\u306E\u78BA\u7387\u3067\u30C6\u30C8\u30EA\u30B9\u306E\u4E00\u3064\u306B\u8272\u3092\u4ED8\u3051\u3066\u30DA\u30A2\u306B\u3059\u308B\n\t\t\t\t\t\t\t// \u305F\u3060\u3057\u3001\u30C6\u30C8\u30EA\u30B9\u306F\u9752\u8272\u7981\u6B62 (\u6E1B\u7B97\u7528)\n\t\t\t\t\t\t\tconst uncoloredTetris = tetrisInRegion.filter((c) => c.color === Color.None);\n\t\t\t\t\t\t\tif (color !== Color.Blue && Math.random() < 0.5 && uncoloredTetris.length > 0) {\n\t\t\t\t\t\t\t\tconst t = uncoloredTetris[Math.floor(Math.random() * uncoloredTetris.length)];\n\t\t\t\t\t\t\t\tt.color = color;\n\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\n\t\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\t} else if (potentialCells.length >= 2) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < 2; i++) {\n\t\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\n\t\t\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// \u307E\u3060\u8DB3\u308A\u306A\u3044\u5834\u5408\u306E\u6700\u7D42\u624B\u6BB5 (1x1\u9818\u57DF\u306A\u3069\u3067\u661F\u304C\u7F6E\u3051\u306A\u304B\u3063\u305F\u5834\u5408\u306A\u3069)\n\t\t\tif (useStars && starsPlaced === 0) {\n\t\t\t\tfor (const region of regions) {\n\t\t\t\t\tif (region.length >= 2) {\n\t\t\t\t\t\tconst potentialCells = [...region].filter((p) => grid.cells[p.y][p.x].type === CellType.None);\n\t\t\t\t\t\tif (potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst color = availableColors[Math.floor(Math.random() * availableColors.length)];\n\t\t\t\t\t\t\tfor (let i = 0; i < 2; i++) {\n\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\n\t\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u30D1\u30B9\u3092\u58C1\u3068\u898B\u306A\u3057\u3066\u3001\u30BB\u30EB\uFF08Block\uFF09\u306E\u9818\u57DF\u5206\u5272\u3092\u884C\u3046 (Flood Fill)\n\t */\n\tprivate calculateRegions(grid: Grid, path: Point[]): Point[][] {\n\t\tconst regions: Point[][] = [];\n\t\tconst visitedCells = new Set<string>();\n\n\t\t// \u30D1\u30B9\u3092\u691C\u7D22\u3057\u3084\u3059\u3044\u5F62\u5F0F\u306B\u5909\u63DB (\u30A8\u30C3\u30B8\u96C6\u5408)\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst p1 = path[i];\n\t\t\tconst p2 = path[i + 1];\n\t\t\t// \u30A8\u30C3\u30B8\u3092\u4E00\u610F\u306A\u30AD\u30FC\u306B\u3059\u308B (\u5C0F\u3055\u3044\u5EA7\u6A19 -> \u5927\u304D\u3044\u5EA7\u6A19)\n\t\t\tconst k = p1.x < p2.x || p1.y < p2.y ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t\t\tpathEdges.add(k);\n\t\t}\n\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (visitedCells.has(`${c},${r}`)) continue;\n\n\t\t\t\tconst currentRegion: Point[] = [];\n\t\t\t\tconst queue: Point[] = [{ x: c, y: r }];\n\t\t\t\tvisitedCells.add(`${c},${r}`);\n\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst cell = queue.shift()!;\n\t\t\t\t\tcurrentRegion.push(cell);\n\n\t\t\t\t\t// 4\u65B9\u5411\u306E\u96A3\u63A5\u30BB\u30EB\u3092\u78BA\u8A8D\n\t\t\t\t\tconst neighbors = [\n\t\t\t\t\t\t{ dx: 0, dy: -1, boundary: { p1: { x: cell.x, y: cell.y }, p2: { x: cell.x + 1, y: cell.y } } }, // Up (Boundary is Top edge)\n\t\t\t\t\t\t{ dx: 0, dy: 1, boundary: { p1: { x: cell.x, y: cell.y + 1 }, p2: { x: cell.x + 1, y: cell.y + 1 } } }, // Down (Boundary is Bottom edge)\n\t\t\t\t\t\t{ dx: -1, dy: 0, boundary: { p1: { x: cell.x, y: cell.y }, p2: { x: cell.x, y: cell.y + 1 } } }, // Left (Boundary is Left edge)\n\t\t\t\t\t\t{ dx: 1, dy: 0, boundary: { p1: { x: cell.x + 1, y: cell.y }, p2: { x: cell.x + 1, y: cell.y + 1 } } }, // Right (Boundary is Right edge)\n\t\t\t\t\t];\n\n\t\t\t\t\tfor (const n of neighbors) {\n\t\t\t\t\t\tconst nx = cell.x + n.dx;\n\t\t\t\t\t\tconst ny = cell.y + n.dy;\n\n\t\t\t\t\t\t// \u76E4\u9762\u5185\u304B\n\t\t\t\t\t\tif (nx >= 0 && nx < grid.cols && ny >= 0 && ny < grid.rows) {\n\t\t\t\t\t\t\tif (!visitedCells.has(`${nx},${ny}`)) {\n\t\t\t\t\t\t\t\t// \u30D1\u30B9\uFF08\u58C1\uFF09\u307E\u305F\u306FAbsent\u30A8\u30C3\u30B8\u3067\u906E\u3089\u308C\u3066\u3044\u306A\u3044\u304B\u30C1\u30A7\u30C3\u30AF\n\t\t\t\t\t\t\t\tconst key = n.boundary.p1.x < n.boundary.p2.x || n.boundary.p1.y < n.boundary.p2.y ? `${n.boundary.p1.x},${n.boundary.p1.y}-${n.boundary.p2.x},${n.boundary.p2.y}` : `${n.boundary.p2.x},${n.boundary.p2.y}-${n.boundary.p1.x},${n.boundary.p1.y}`;\n\n\t\t\t\t\t\t\t\tif (!pathEdges.has(key) && !this.isAbsentEdge(grid, n.boundary.p1, n.boundary.p2)) {\n\t\t\t\t\t\t\t\t\tvisitedCells.add(`${nx},${ny}`);\n\t\t\t\t\t\t\t\t\tqueue.push({ x: nx, y: ny });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregions.push(currentRegion);\n\t\t\t}\n\t\t}\n\n\t\treturn regions;\n\t}\n\n\tprivate isAbsentEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\treturn grid.vEdges[y][p1.x].type === EdgeType.Absent;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\treturn grid.hEdges[p1.y][x].type === EdgeType.Absent;\n\t\t}\n\t}\n\n\tprivate setEdgeHexagon(grid: Grid, p1: Point, p2: Point) {\n\t\tif (p1.x === p2.x) {\n\t\t\t// Vertical\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\tgrid.vEdges[y][p1.x].type = EdgeType.Hexagon;\n\t\t} else {\n\t\t\t// Horizontal\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\tgrid.hEdges[p1.y][x].type = EdgeType.Hexagon;\n\t\t}\n\t}\n\n\tprivate checkAllRequestedConstraintsPresent(grid: Grid, options: GenerationOptions): boolean {\n\t\tconst useHexagons = options.useHexagons ?? true;\n\t\tconst useSquares = options.useSquares ?? true;\n\t\tconst useStars = options.useStars ?? true;\n\t\tconst useTetris = options.useTetris ?? false;\n\t\tconst useBrokenEdges = options.useBrokenEdges ?? false;\n\n\t\tif (useBrokenEdges) {\n\t\t\tlet found = false;\n\t\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Broken || grid.hEdges[r][c].type === EdgeType.Absent) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (found) break;\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Broken || grid.vEdges[r][c].type === EdgeType.Absent) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (found) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) return false;\n\t\t}\n\n\t\tif (useHexagons) {\n\t\t\tlet found = false;\n\t\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (found) break;\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (found) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) return false;\n\t\t}\n\n\t\tif (useSquares || useStars || useTetris) {\n\t\t\tlet foundSquare = false;\n\t\t\tlet foundStar = false;\n\t\t\tlet foundTetris = false;\n\t\t\tconst squareColors = new Set<number>();\n\n\t\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t\tif (grid.cells[r][c].type === CellType.Square) {\n\t\t\t\t\t\tfoundSquare = true;\n\t\t\t\t\t\tsquareColors.add(grid.cells[r][c].color);\n\t\t\t\t\t}\n\t\t\t\t\tif (grid.cells[r][c].type === CellType.Star) foundStar = true;\n\t\t\t\t\tif (grid.cells[r][c].type === CellType.Tetris || grid.cells[r][c].type === CellType.TetrisRotated) {\n\t\t\t\t\t\tfoundTetris = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (useSquares && !foundSquare) return false;\n\t\t\tif (useStars && !foundStar) return false;\n\t\t\tif (useTetris && !foundTetris) return false;\n\n\t\t\t// \u30C8\u30B2\u304C\u5B58\u5728\u3059\u308B\u5834\u5408\u3092\u9664\u304D\u3001\u56DB\u89D2\u304C1\u8272\u306E\u307F\u3067\u751F\u6210\u3055\u308C\u308B\u306E\u306F\u30D1\u30BA\u30EB\u3068\u3057\u3066\u7834\u7DBB\u3057\u3066\u3044\u308B\u306E\u30672\u8272\u4EE5\u4E0A\u5FC5\u8981\n\t\t\tif (foundSquare && !foundStar && squareColors.size < 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// \u30DE\u30FC\u30AF\u306E\u5468\u56F2\u5168\u3066\u304C\u901A\u884C\u4E0D\u53EF\u306E\u76E4\u9762\u306F\u975E\u63A8\u5968\n\t\tif (this.hasIsolatedMark(grid)) return false;\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * \u9818\u57DF\u3092\u6307\u5B9A\u3055\u308C\u305F\u30D4\u30FC\u30B9\u6570\u4EE5\u5185\u3067\u30BF\u30A4\u30EA\u30F3\u30B0\u3059\u308B\u3002\u6210\u529F\u3059\u308C\u3070\u30D4\u30FC\u30B9\u306E\u30EA\u30B9\u30C8\u3092\u8FD4\u3059\u3002\n\t */\n\tprivate generateTiling(region: Point[], maxPieces: number): { shape: number[][]; isRotated: boolean }[] | null {\n\t\tconst minX = Math.min(...region.map((p) => p.x));\n\t\tconst minY = Math.min(...region.map((p) => p.y));\n\t\tconst maxX = Math.max(...region.map((p) => p.x));\n\t\tconst maxY = Math.max(...region.map((p) => p.y));\n\t\tconst width = maxX - minX + 1;\n\t\tconst height = maxY - minY + 1;\n\n\t\tconst regionGrid = Array.from({ length: height }, () => Array(width).fill(false));\n\t\tfor (const p of region) {\n\t\t\tregionGrid[p.y - minY][p.x - minX] = true;\n\t\t}\n\n\t\treturn this.tilingDfs(regionGrid, [], maxPieces);\n\t}\n\n\tprivate tilingDfs(regionGrid: boolean[][], currentPieces: { shape: number[][]; isRotated: boolean }[], maxPieces: number): { shape: number[][]; isRotated: boolean }[] | null {\n\t\t// \u898B\u3064\u304B\u3063\u3066\u3044\u306A\u3044\u6700\u521D\u306E\u30DE\u30B9\u3092\u63A2\u3059\n\t\tlet r0 = -1;\n\t\tlet c0 = -1;\n\t\tfor (let r = 0; r < regionGrid.length; r++) {\n\t\t\tfor (let c = 0; c < regionGrid[0].length; c++) {\n\t\t\t\tif (regionGrid[r][c]) {\n\t\t\t\t\tr0 = r;\n\t\t\t\t\tc0 = c;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (r0 !== -1) break;\n\t\t}\n\n\t\t// \u5168\u3066\u57CB\u307E\u3063\u305F\n\t\tif (r0 === -1) return currentPieces;\n\n\t\t// \u30D4\u30FC\u30B9\u4E0A\u9650\n\t\tif (currentPieces.length >= maxPieces) return null;\n\n\t\t// \u30B7\u30E3\u30C3\u30D5\u30EB\u3057\u305F\u5F62\u72B6\u30EA\u30B9\u30C8\u3067\u8A66\u3059\n\t\tconst shapes = [...this.TETRIS_SHAPES];\n\t\tthis.shuffleArray(shapes);\n\n\t\tfor (const baseShape of shapes) {\n\t\t\t// \u56DE\u8EE2\u30D1\u30BF\u30FC\u30F3\u3092\u751F\u6210\n\t\t\tconst isInvariant = this.isRotationallyInvariant(baseShape);\n\t\t\tconst rotations = isInvariant ? [baseShape] : this.getAllRotations(baseShape);\n\t\t\tthis.shuffleArray(rotations);\n\n\t\t\tfor (const shape of rotations) {\n\t\t\t\t// \u30D4\u30FC\u30B9\u5185\u306E\u5404\u30D6\u30ED\u30C3\u30AF\u3092 (r0, c0) \u306B\u5408\u308F\u305B\u3066\u307F\u308B\n\t\t\t\tconst blocks: { r: number; c: number }[] = [];\n\t\t\t\tfor (let pr = 0; pr < shape.length; pr++) {\n\t\t\t\t\tfor (let pc = 0; pc < shape[0].length; pc++) {\n\t\t\t\t\t\tif (shape[pr][pc]) blocks.push({ r: pr, c: pc });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (const anchor of blocks) {\n\t\t\t\t\tconst dr = r0 - anchor.r;\n\t\t\t\t\tconst dc = c0 - anchor.c;\n\n\t\t\t\t\tif (this.canPlace(regionGrid, shape, dr, dc)) {\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, false);\n\t\t\t\t\t\tconst isRotated = !isInvariant && Math.random() < 0.5; // \u5B9F\u969B\u306B\u56DE\u8EE2\u3057\u305F\u30A2\u30A4\u30B3\u30F3\u306B\u3059\u308B\u304B\u306F\u30E9\u30F3\u30C0\u30E0\n\t\t\t\t\t\t// NOTE: \u3053\u3053\u3067 isRotated \u3092\u6C7A\u5B9A\u3059\u308B\u969B\u3001\u5143\u306E baseShape \u3068 shape \u304C\u7570\u306A\u308B\u5834\u5408\u306B TetrisRotated \u306B\u3059\u308B\u306E\u304C\u6B63\u3057\u3044\u3002\n\t\t\t\t\t\t// \u305F\u3060\u3057 Witness \u3067\u306F\u300C\u50BE\u3044\u3066\u3044\u308B\u30A2\u30A4\u30B3\u30F3\u300D\uFF1D\u300C\u56DE\u8EE2\u53EF\u80FD\u300D\u3068\u3044\u3046\u610F\u5473\u306A\u306E\u3067\u3001\n\t\t\t\t\t\t// \u3053\u3053\u3067\u306F\u5358\u306B\u30E9\u30F3\u30C0\u30E0\u306B\u56DE\u8EE2\u53EF\u80FD\u5C5E\u6027\u3092\u4ED8\u4E0E\u3059\u308B\u304B\u3001\u3042\u308B\u3044\u306F\u300C\u56DE\u8EE2\u304C\u5FC5\u8981\u306A\u5834\u5408\u300D\u306B\u4ED8\u4E0E\u3059\u308B\u3088\u3046\u306B\u3059\u308B\u3002\n\t\t\t\t\t\t// \u4ECA\u56DE\u306F\u300C\u56DE\u8EE2\u53EF\u80FD\u300D\u306A\u30D4\u30FC\u30B9\u3068\u3057\u3066\u751F\u6210\u3059\u308B\u3002\n\t\t\t\t\t\tconst result = this.tilingDfs(regionGrid, [...currentPieces, { shape, isRotated: !isInvariant }], maxPieces);\n\t\t\t\t\t\tif (result) return result;\n\t\t\t\t\t\tthis.placePiece(regionGrid, shape, dr, dc, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate isRotationallyInvariant(shape: number[][]): boolean {\n\t\tlet area = 0;\n\t\tfor (const row of shape) {\n\t\t\tfor (const cell of row) {\n\t\t\t\tif (cell) area++;\n\t\t\t}\n\t\t}\n\t\t// 1x1 or 2x2 full square\n\t\treturn area === 1 || (area === 4 && shape.length === 2 && shape[0].length === 2);\n\t}\n\n\tprivate getAllRotations(shape: number[][]): number[][][] {\n\t\tconst results: number[][][] = [];\n\t\tconst keys = new Set<string>();\n\n\t\tlet curr = shape;\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tconst key = JSON.stringify(curr);\n\t\t\tif (!keys.has(key)) {\n\t\t\t\tresults.push(curr);\n\t\t\t\tkeys.add(key);\n\t\t\t}\n\t\t\tcurr = this.rotate90(curr);\n\t\t}\n\t\treturn results;\n\t}\n\n\tprivate rotate90(shape: number[][]): number[][] {\n\t\tconst rows = shape.length;\n\t\tconst cols = shape[0].length;\n\t\tconst newShape = Array.from({ length: cols }, () => Array(rows).fill(0));\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tnewShape[c][rows - 1 - r] = shape[r][c];\n\t\t\t}\n\t\t}\n\t\treturn newShape;\n\t}\n\n\tprivate canPlace(regionGrid: boolean[][], shape: number[][], r: number, c: number): boolean {\n\t\tfor (let i = 0; i < shape.length; i++) {\n\t\t\tfor (let j = 0; j < shape[0].length; j++) {\n\t\t\t\tif (shape[i][j]) {\n\t\t\t\t\tconst nr = r + i;\n\t\t\t\t\tconst nc = c + j;\n\t\t\t\t\tif (nr < 0 || nr >= regionGrid.length || nc < 0 || nc >= regionGrid[0].length || !regionGrid[nr][nc]) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate placePiece(regionGrid: boolean[][], shape: number[][], r: number, c: number, value: boolean) {\n\t\tfor (let i = 0; i < shape.length; i++) {\n\t\t\tfor (let j = 0; j < shape[0].length; j++) {\n\t\t\t\tif (shape[i][j]) {\n\t\t\t\t\tregionGrid[r + i][c + j] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate shuffleArray(array: any[]) {\n\t\tfor (let i = array.length - 1; i > 0; i--) {\n\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t[array[i], array[j]] = [array[j], array[i]];\n\t\t}\n\t}\n}\n", "import { PuzzleGenerator } from \"./generator\";\nimport { Grid } from \"./grid\";\nimport type { GenerationOptions, PuzzleData, SolutionPath, ValidationResult } from \"./types\";\nimport { PuzzleValidator } from \"./validator\";\n\n// \u30E9\u30A4\u30D6\u30E9\u30EA\u306E\u30D5\u30A1\u30B5\u30FC\u30C9\u30AF\u30E9\u30B9\nexport { PuzzleGenerator } from \"./generator\";\nexport { Grid } from \"./grid\";\nexport { PuzzleValidator } from \"./validator\";\n\nexport class WitnessCore {\n\tprivate generator: PuzzleGenerator;\n\tprivate validator: PuzzleValidator;\n\n\tconstructor() {\n\t\tthis.generator = new PuzzleGenerator();\n\t\tthis.validator = new PuzzleValidator();\n\t}\n\n\t/**\n\t * \u65B0\u3057\u3044\u30D1\u30BA\u30EB\u3092\u751F\u6210\u3057\u3066\u30C7\u30FC\u30BF\u3092\u8FD4\u3059\n\t */\n\tpublic createPuzzle(rows: number, cols: number, options: GenerationOptions = {}): PuzzleData {\n\t\tconst grid = this.generator.generate(rows, cols, options);\n\t\treturn grid.export();\n\t}\n\n\t/**\n\t * \u89E3\u7B54\u3092\u691C\u8A3C\u3059\u308B\n\t */\n\tpublic validateSolution(puzzleData: PuzzleData, solution: SolutionPath): ValidationResult {\n\t\tconst grid = Grid.fromData(puzzleData);\n\t\treturn this.validator.validate(grid, solution);\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u306E\u96E3\u6613\u5EA6\u3092\u8A08\u7B97\u3059\u308B\n\t */\n\tpublic calculateDifficulty(puzzleData: PuzzleData): number {\n\t\tconst grid = Grid.fromData(puzzleData);\n\t\treturn this.validator.calculateDifficulty(grid);\n\t}\n}\n\n// \u30D6\u30E9\u30A6\u30B6/Node.js\u74B0\u5883\u4E21\u5BFE\u5FDC\u306E\u305F\u3081\u306E\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\nexport * from \"./types\";\n"],
  "mappings": "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",
  "names": ["Direction", "CellType", "EdgeType", "NodeType", "Color", "Grid", "_Grid", "rows", "cols", "data", "grid", "PuzzleValidator", "grid", "solution", "path", "start", "end", "visitedNodes", "i", "p1", "p2", "key", "type", "y", "x", "pathEdges", "r", "c", "regions", "region", "colorCounts", "starColors", "squareColors", "tetrisPieces", "cell", "constraint", "color", "pieces", "sum", "p", "minX", "minY", "maxX", "maxY", "width", "height", "regionGrid", "shape", "area", "row", "r0", "c0", "piece", "nextPieces", "rotations", "blocks", "pr", "pc", "anchor", "dr", "dc", "j", "nr", "nc", "value", "results", "keys", "curr", "rows", "cols", "newShape", "visitedCells", "externalCells", "queue", "neighbors", "n", "neighborKey", "edgeKey", "isAbsent", "external", "nodeCols", "nodeCount", "adj", "startNodes", "endNodes", "hexagonEdges", "u", "v", "isHexagon", "isBlocked", "stats", "totalHexagons", "fingerprints", "startIdx", "constraintCount", "constraintTypes", "branchingFactor", "searchComplexity", "difficulty", "cellCount", "density", "densityFactor", "typeFactor", "sizeFactor", "currIdx", "visitedMask", "hexagonsOnPath", "limit", "solutionPath", "idx", "fp", "validMoves", "edge", "possible", "otherEdge", "isAlreadyOnPath", "isNextMove", "move", "localVisited", "head", "f", "PuzzleGenerator", "rows", "cols", "options", "targetDifficulty", "validator", "PuzzleValidator", "bestGrid", "bestScore", "maxAttempts", "attempt", "grid", "difficulty", "diffFromTarget", "Grid", "startPoint", "endPoint", "solutionPath", "start", "end", "visited", "path", "stack", "findPath", "current", "neighbors", "next", "p", "candidates", "directions", "d", "nx", "ny", "complexity", "pathEdges", "unusedEdges", "r", "c", "p1", "p2", "targetCount", "placed", "edge", "type", "edgesWithMeta", "m", "startNodes", "reachableNodes", "queue", "curr", "n", "external", "cellKey", "e", "useHexagons", "useSquares", "useStars", "useTetris", "hexagonsPlaced", "squaresPlaced", "starsPlaced", "tetrisPlaced", "i", "isBranching", "prob", "idx", "regions", "availableColors", "regionIndices", "_", "region", "skipProb", "forceOne", "isLastFew", "potentialCells", "squareColor", "currentColors", "otherColors", "numSquares", "shouldPlaceSquare", "maxSquares", "cell", "shouldPlaceTetris", "maxTetrisPerRegion", "tiledPieces", "color", "shouldPlaceStar", "tetrisInRegion", "existingColorCount", "uncoloredTetris", "t", "visitedCells", "k", "currentRegion", "key", "y", "x", "found", "foundSquare", "foundStar", "foundTetris", "squareColors", "maxPieces", "minX", "minY", "maxX", "maxY", "width", "height", "regionGrid", "currentPieces", "r0", "c0", "shapes", "baseShape", "isInvariant", "rotations", "shape", "blocks", "pr", "pc", "anchor", "dr", "dc", "isRotated", "result", "area", "row", "results", "keys", "newShape", "j", "nr", "nc", "value", "array", "WitnessCore", "PuzzleGenerator", "PuzzleValidator", "rows", "cols", "options", "puzzleData", "solution", "grid", "Grid"]
}
