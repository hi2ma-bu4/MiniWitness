{
  "version": 3,
  "sources": ["../src/types.ts", "../src/grid.ts", "../src/generator.ts", "../src/validator.ts", "../src/index.ts"],
  "sourcesContent": ["// types.ts\n\nexport enum Direction {\n\tUp = 0,\n\tRight = 1,\n\tDown = 2,\n\tLeft = 3,\n}\n\nexport enum CellType {\n\tNone = 0,\n\tSquare = 1, // \u8272\u5206\u3051\u304C\u5FC5\u8981\u306A\u30D6\u30ED\u30C3\u30AF\n\tStar = 2, // \u540C\u3058\u8272\u306E\u30DA\u30A2\u4F5C\u6210 (\u661F)\n\t// \u5FC5\u8981\u306B\u5FDC\u3058\u3066Tetris\u578B\u306A\u3069\u3092\u8FFD\u52A0\n}\n\nexport enum EdgeType {\n\tNormal = 0,\n\tHexagon = 1, // \u901A\u904E\u5FC5\u9808\n\tBroken = 2, // \u901A\u904E\u4E0D\u53EF\n}\n\nexport enum NodeType {\n\tNormal = 0,\n\tStart = 1,\n\tEnd = 2,\n}\n\nexport enum Color {\n\tNone = 0,\n\tBlack = 1,\n\tWhite = 2,\n\tRed = 3,\n\tBlue = 4,\n\t// \u62E1\u5F35\u53EF\u80FD\n}\n\nexport interface Point {\n\tx: number;\n\ty: number;\n}\n\nexport interface CellConstraint {\n\ttype: CellType;\n\tcolor: Color;\n}\n\nexport interface EdgeConstraint {\n\ttype: EdgeType;\n}\n\nexport interface NodeConstraint {\n\ttype: NodeType;\n}\n\n/**\n * \u30D1\u30BA\u30EB\u306E\u9759\u7684\u306A\u5B9A\u7FA9\u30C7\u30FC\u30BF\n */\nexport interface PuzzleData {\n\trows: number;\n\tcols: number;\n\tcells: CellConstraint[][]; // [row][col]\n\tvEdges: EdgeConstraint[][]; // Vertical edges [row][col] (row: 0..rows-1, col: 0..cols)\n\thEdges: EdgeConstraint[][]; // Horizontal edges [row][col] (row: 0..rows, col: 0..cols-1)\n\tnodes: NodeConstraint[][]; // [row][col]\n}\n\n/**\n * \u30E6\u30FC\u30B6\u30FC\u306E\u5165\u529B\uFF08\u56DE\u7B54\u30D1\u30B9\uFF09\n */\nexport interface SolutionPath {\n\tpoints: Point[]; // \u901A\u904E\u3057\u305F\u30CE\u30FC\u30C9\u306E\u5EA7\u6A19\u914D\u5217\n}\n\nexport interface ValidationResult {\n\tisValid: boolean;\n\terrorReason?: string;\n}\n", "// grid.ts\nimport { CellConstraint, CellType, Color, EdgeConstraint, EdgeType, NodeConstraint, NodeType, PuzzleData } from \"./types\";\n\nexport class Grid {\n\tpublic readonly rows: number;\n\tpublic readonly cols: number;\n\n\t// \u30C7\u30FC\u30BF\u30DE\u30C8\u30EA\u30AF\u30B9\n\tpublic cells: CellConstraint[][] = [];\n\tpublic hEdges: EdgeConstraint[][] = []; // \u6A2A\u68D2\n\tpublic vEdges: EdgeConstraint[][] = []; // \u7E26\u68D2\n\tpublic nodes: NodeConstraint[][] = [];\n\n\tconstructor(rows: number, cols: number) {\n\t\tthis.rows = rows;\n\t\tthis.cols = cols;\n\t\tthis.initializeGrid();\n\t}\n\n\tprivate initializeGrid() {\n\t\t// Cells: rows * cols\n\t\tthis.cells = Array.from({ length: this.rows }, () => Array.from({ length: this.cols }, () => ({ type: CellType.None, color: Color.None })));\n\n\t\t// H-Edges: (rows + 1) * cols\n\t\tthis.hEdges = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols }, () => ({ type: EdgeType.Normal })));\n\n\t\t// V-Edges: rows * (cols + 1)\n\t\tthis.vEdges = Array.from({ length: this.rows }, () => Array.from({ length: this.cols + 1 }, () => ({ type: EdgeType.Normal })));\n\n\t\t// Nodes: (rows + 1) * (cols + 1)\n\t\tthis.nodes = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols + 1 }, () => ({ type: NodeType.Normal })));\n\t}\n\n\tpublic export(): PuzzleData {\n\t\t// \u30C7\u30FC\u30BF\u306E\u30C7\u30A3\u30FC\u30D7\u30B3\u30D4\u30FC\u3092\u8FD4\u3059\n\t\treturn JSON.parse(\n\t\t\tJSON.stringify({\n\t\t\t\trows: this.rows,\n\t\t\t\tcols: this.cols,\n\t\t\t\tcells: this.cells,\n\t\t\t\tvEdges: this.vEdges,\n\t\t\t\thEdges: this.hEdges,\n\t\t\t\tnodes: this.nodes,\n\t\t\t}),\n\t\t);\n\t}\n\n\tpublic static fromData(data: PuzzleData): Grid {\n\t\tconst grid = new Grid(data.rows, data.cols);\n\t\tgrid.cells = data.cells;\n\t\tgrid.vEdges = data.vEdges;\n\t\tgrid.hEdges = data.hEdges;\n\t\tgrid.nodes = data.nodes;\n\t\treturn grid;\n\t}\n}\n", "// generator.ts\nimport { Grid } from \"./grid\";\nimport { CellType, Color, EdgeType, NodeType, Point } from \"./types\";\n\nexport class PuzzleGenerator {\n\t/**\n\t * \u30D1\u30BA\u30EB\u3092\u751F\u6210\u3059\u308B\n\t * @param rows \u884C\u6570\n\t * @param cols \u5217\u6570\n\t * @param complexity \u8907\u96D1\u5EA6 (0.0 - 1.0)\n\t */\n\tpublic generate(rows: number, cols: number, complexity: number = 0.5): Grid {\n\t\tconst grid = new Grid(rows, cols);\n\n\t\t// 1. \u30B9\u30BF\u30FC\u30C8\u3068\u30B4\u30FC\u30EB\u306E\u8A2D\u5B9A (\u901A\u5E38\u306F\u5DE6\u4E0B\u30B9\u30BF\u30FC\u30C8\u3001\u53F3\u4E0A\u30B4\u30FC\u30EB\u306A\u3069)\n\t\tconst startPoint: Point = { x: 0, y: rows }; // \u5DE6\u4E0B\n\t\tconst endPoint: Point = { x: cols, y: 0 }; // \u53F3\u4E0A\n\n\t\tgrid.nodes[startPoint.y][startPoint.x].type = NodeType.Start;\n\t\tgrid.nodes[endPoint.y][endPoint.x].type = NodeType.End;\n\n\t\t// 2. \u6B63\u89E3\u30D1\u30B9\u3092\u751F\u6210 (\u30E9\u30F3\u30C0\u30E0\u30A6\u30A9\u30FC\u30AF / DFS)\n\t\tconst solutionPath = this.generateRandomPath(grid, startPoint, endPoint);\n\n\t\t// 3. \u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u5236\u7D04\uFF08\u30EB\u30FC\u30EB\uFF09\u3092\u914D\u7F6E\n\t\t// \u30D1\u30B9\u304C\u901A\u904E\u3059\u308B\u30A8\u30C3\u30B8\u306B\u30D8\u30AD\u30B5\u30B4\u30F3\u3092\u7F6E\u3044\u305F\u308A\u3001\u5206\u5272\u3055\u308C\u305F\u9818\u57DF\u306B\u8272\u3092\u5857\u308B\n\t\tthis.applyConstraintsBasedOnPath(grid, solutionPath, complexity);\n\n\t\treturn grid;\n\t}\n\n\t/**\n\t * Randomized DFS\u3092\u7528\u3044\u3066Start\u304B\u3089End\u3078\u306E\u4E00\u672C\u9053\u3092\u751F\u6210\u3059\u308B\n\t */\n\tprivate generateRandomPath(grid: Grid, start: Point, end: Point): Point[] {\n\t\tconst visited = new Set<string>();\n\t\tconst path: Point[] = [];\n\n\t\tconst stack: Point[] = [start];\n\t\tconst parentMap = new Map<string, Point | null>();\n\t\tparentMap.set(`${start.x},${start.y}`, null);\n\n\t\t// \u5B8C\u5168\u306A\u30E9\u30F3\u30C0\u30E0\u3067\u306F\u306A\u304F\u3001\u30B4\u30FC\u30EB\u65B9\u5411\u3078\u5411\u304B\u3046\u30D0\u30A4\u30A2\u30B9\u3092\u304B\u3051\u308B\u3053\u3068\u3082\u53EF\u80FD\u3060\u304C\n\t\t// \u3053\u3053\u3067\u306F\u5358\u7D14\u306A\u30D0\u30C3\u30AF\u30C8\u30E9\u30C3\u30AD\u30F3\u30B0\u4ED8\u304DDFS\u3067\u63A2\u7D22\u3059\u308B\n\n\t\tconst findPath = (current: Point): boolean => {\n\t\t\tvisited.add(`${current.x},${current.y}`);\n\t\t\tpath.push(current);\n\n\t\t\tif (current.x === end.x && current.y === end.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// \u6B21\u306E\u5019\u88DC\u3092\u53D6\u5F97\n\t\t\tconst neighbors = this.getValidNeighbors(grid, current, visited);\n\t\t\t// \u30E9\u30F3\u30C0\u30E0\u306B\u30B7\u30E3\u30C3\u30D5\u30EB\n\t\t\tthis.shuffleArray(neighbors);\n\n\t\t\tfor (const next of neighbors) {\n\t\t\t\tif (findPath(next)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// \u884C\u304D\u6B62\u307E\u308A\u306A\u3089\u30D0\u30C3\u30AF\u30C8\u30E9\u30C3\u30AF\n\t\t\tpath.pop();\n\t\t\treturn false;\n\t\t};\n\n\t\t// \u78BA\u5B9F\u306B\u30D1\u30B9\u3092\u898B\u3064\u3051\u308B\u305F\u3081\u3001\u7C21\u6613\u7684\u306A\u5B9F\u88C5\u3068\u3057\u3066\u3044\u307E\u3059\u3002\n\t\t// \u672C\u683C\u7684\u306AWitness\u30D1\u30BA\u30EB\u3067\u306F\u300C\u9577\u304F\u86C7\u884C\u3059\u308B\u30D1\u30B9\u300D\u304C\u597D\u307E\u3057\u3044\u305F\u3081\u3001\n\t\t// \u5B9F\u969B\u306B\u306FPrim\u6CD5\u306A\u3069\u3067\u5168\u57DF\u6728\u3092\u4F5C\u3063\u3066\u304B\u3089\u30D1\u30B9\u3092\u5207\u308A\u51FA\u3059\u624B\u6CD5\u304C\u63A8\u5968\u3055\u308C\u307E\u3059\u3002\n\t\t// \u3053\u3053\u3067\u306F\u57FA\u672C\u7684\u306ADFS\u63A2\u7D22\u3092\u884C\u3044\u307E\u3059\u3002\n\t\tfindPath(start);\n\n\t\treturn path;\n\t}\n\n\tprivate getValidNeighbors(grid: Grid, p: Point, visited: Set<string>): Point[] {\n\t\tconst candidates: Point[] = [];\n\t\tconst directions = [\n\t\t\t{ x: 0, y: -1 }, // Up\n\t\t\t{ x: 1, y: 0 }, // Right\n\t\t\t{ x: 0, y: 1 }, // Down\n\t\t\t{ x: -1, y: 0 }, // Left\n\t\t];\n\n\t\tfor (const d of directions) {\n\t\t\tconst nx = p.x + d.x;\n\t\t\tconst ny = p.y + d.y;\n\n\t\t\tif (nx >= 0 && nx <= grid.cols && ny >= 0 && ny <= grid.rows) {\n\t\t\t\tif (!visited.has(`${nx},${ny}`)) {\n\t\t\t\t\tcandidates.push({ x: nx, y: ny });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn candidates;\n\t}\n\n\tprivate applyConstraintsBasedOnPath(grid: Grid, path: Point[], complexity: number) {\n\t\t// A. \u30D1\u30B9\u4E0A\u306E\u30D8\u30AD\u30B5\u30B4\u30F3 (Hexagon) \u914D\u7F6E\n\t\t// \u30D1\u30B9\u4E0A\u306E\u30A8\u30C3\u30B8\u306E\u3044\u304F\u3064\u304B\u3092\u300C\u901A\u904E\u5FC5\u9808\u300D\u306B\u3059\u308B\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst p1 = path[i];\n\t\t\tconst p2 = path[i + 1];\n\n\t\t\t// \u78BA\u7387\u3067\u30D8\u30AD\u30B5\u30B4\u30F3\u3092\u914D\u7F6E\n\t\t\tif (Math.random() < complexity * 0.4) {\n\t\t\t\tthis.setEdgeHexagon(grid, p1, p2);\n\t\t\t}\n\t\t}\n\n\t\t// B. \u9818\u57DF\u5206\u96E2 (Squares)\n\t\t// \u30D1\u30B9\u306B\u3088\u3063\u3066\u76E4\u9762\u306F2\u3064\u4EE5\u4E0A\u306E\u9818\u57DF\u306B\u5206\u5272\u3055\u308C\u3066\u3044\u308B\u306F\u305A\u3067\u3042\u308B\u3002\n\t\t// \u30D1\u30B9\u3092\u300C\u5883\u754C\u7DDA\u300D\u3068\u898B\u306A\u3057\u3001\u9818\u57DF\u3054\u3068\u306B\u7570\u306A\u308B\u8272\u3092\u5272\u308A\u5F53\u3066\u308B\u3053\u3068\u3067\u3001\n\t\t// \u3053\u306E\u30D1\u30B9\u304C\u552F\u4E00\u306E\u89E3\uFF08\u3042\u308B\u3044\u306F\u6B63\u5F53\u306A\u89E3\u306E\u4E00\u3064\uFF09\u306B\u306A\u308B\u3088\u3046\u306B\u5F37\u5236\u3059\u308B\u3002\n\n\t\tconst regions = this.calculateRegions(grid, path);\n\t\tconst availableColors = [Color.Black, Color.White, Color.Red, Color.Blue];\n\t\tfor (let i = 0; i < regions.length; i++) {\n\t\t\tconst region = regions[i];\n\t\t\tconst color = availableColors[i % availableColors.length];\n\t\t\t// \u8907\u96D1\u5EA6\u306B\u5FDC\u3058\u3066\u5236\u7D04\u3092\u914D\u7F6E\n\t\t\tif (Math.random() < 0.3 + complexity * 0.4) {\n\t\t\t\tif (Math.random() < 0.3) {\n\t\t\t\t\t// \u30C8\u30B2 (Star) \u3092\u30DA\u30A2\u3067\u914D\u7F6E\n\t\t\t\t\tthis.fillRegionWithStarPairs(grid, region, color);\n\t\t\t\t} else {\n\t\t\t\t\t// \u56DB\u89D2 (Square) \u3092\u914D\u7F6E\n\t\t\t\t\tthis.fillRegionWithColor(grid, region, color, complexity);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u30D1\u30B9\u3092\u58C1\u3068\u898B\u306A\u3057\u3066\u3001\u30BB\u30EB\uFF08Block\uFF09\u306E\u9818\u57DF\u5206\u5272\u3092\u884C\u3046 (Flood Fill)\n\t */\n\tprivate calculateRegions(grid: Grid, path: Point[]): Point[][] {\n\t\tconst regions: Point[][] = [];\n\t\tconst visitedCells = new Set<string>();\n\n\t\t// \u30D1\u30B9\u3092\u691C\u7D22\u3057\u3084\u3059\u3044\u5F62\u5F0F\u306B\u5909\u63DB (\u30A8\u30C3\u30B8\u96C6\u5408)\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst p1 = path[i];\n\t\t\tconst p2 = path[i + 1];\n\t\t\t// \u30A8\u30C3\u30B8\u3092\u4E00\u610F\u306A\u30AD\u30FC\u306B\u3059\u308B (\u5C0F\u3055\u3044\u5EA7\u6A19 -> \u5927\u304D\u3044\u5EA7\u6A19)\n\t\t\tconst k = p1.x < p2.x || p1.y < p2.y ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t\t\tpathEdges.add(k);\n\t\t}\n\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (visitedCells.has(`${c},${r}`)) continue;\n\n\t\t\t\tconst currentRegion: Point[] = [];\n\t\t\t\tconst queue: Point[] = [{ x: c, y: r }];\n\t\t\t\tvisitedCells.add(`${c},${r}`);\n\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst cell = queue.shift()!;\n\t\t\t\t\tcurrentRegion.push(cell);\n\n\t\t\t\t\t// 4\u65B9\u5411\u306E\u96A3\u63A5\u30BB\u30EB\u3092\u78BA\u8A8D\n\t\t\t\t\tconst neighbors = [\n\t\t\t\t\t\t{ dx: 0, dy: -1, boundary: { p1: { x: cell.x, y: cell.y }, p2: { x: cell.x + 1, y: cell.y } } }, // Up (Boundary is Top edge)\n\t\t\t\t\t\t{ dx: 0, dy: 1, boundary: { p1: { x: cell.x, y: cell.y + 1 }, p2: { x: cell.x + 1, y: cell.y + 1 } } }, // Down (Boundary is Bottom edge)\n\t\t\t\t\t\t{ dx: -1, dy: 0, boundary: { p1: { x: cell.x, y: cell.y }, p2: { x: cell.x, y: cell.y + 1 } } }, // Left (Boundary is Left edge)\n\t\t\t\t\t\t{ dx: 1, dy: 0, boundary: { p1: { x: cell.x + 1, y: cell.y }, p2: { x: cell.x + 1, y: cell.y + 1 } } }, // Right (Boundary is Right edge)\n\t\t\t\t\t];\n\n\t\t\t\t\tfor (const n of neighbors) {\n\t\t\t\t\t\tconst nx = cell.x + n.dx;\n\t\t\t\t\t\tconst ny = cell.y + n.dy;\n\n\t\t\t\t\t\t// \u76E4\u9762\u5185\u304B\n\t\t\t\t\t\tif (nx >= 0 && nx < grid.cols && ny >= 0 && ny < grid.rows) {\n\t\t\t\t\t\t\tif (!visitedCells.has(`${nx},${ny}`)) {\n\t\t\t\t\t\t\t\t// \u30D1\u30B9\uFF08\u58C1\uFF09\u3067\u906E\u3089\u308C\u3066\u3044\u306A\u3044\u304B\u30C1\u30A7\u30C3\u30AF\n\t\t\t\t\t\t\t\tconst key = n.boundary.p1.x < n.boundary.p2.x || n.boundary.p1.y < n.boundary.p2.y ? `${n.boundary.p1.x},${n.boundary.p1.y}-${n.boundary.p2.x},${n.boundary.p2.y}` : `${n.boundary.p2.x},${n.boundary.p2.y}-${n.boundary.p1.x},${n.boundary.p1.y}`;\n\n\t\t\t\t\t\t\t\tif (!pathEdges.has(key)) {\n\t\t\t\t\t\t\t\t\tvisitedCells.add(`${nx},${ny}`);\n\t\t\t\t\t\t\t\t\tqueue.push({ x: nx, y: ny });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregions.push(currentRegion);\n\t\t\t}\n\t\t}\n\n\t\treturn regions;\n\t}\n\n\tprivate fillRegionWithColor(grid: Grid, cells: Point[], color: Color, density: number) {\n\t\tfor (const cell of cells) {\n\t\t\tif (Math.random() < density * 0.7) {\n\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Square;\n\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate fillRegionWithStarPairs(grid: Grid, cells: Point[], color: Color) {\n\t\tif (cells.length < 2) return;\n\n\t\t// \u30E9\u30F3\u30C0\u30E0\u306B2\u7B87\u6240\u9078\u3093\u3067\u30DA\u30A2\u306B\u3059\u308B\n\t\tconst shuffled = [...cells];\n\t\tthis.shuffleArray(shuffled);\n\n\t\tfor (let i = 0; i < 2; i++) {\n\t\t\tgrid.cells[shuffled[i].y][shuffled[i].x].type = CellType.Star;\n\t\t\tgrid.cells[shuffled[i].y][shuffled[i].x].color = color;\n\t\t}\n\t}\n\n\tprivate setEdgeHexagon(grid: Grid, p1: Point, p2: Point) {\n\t\tif (p1.x === p2.x) {\n\t\t\t// Vertical\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\tgrid.vEdges[y][p1.x].type = EdgeType.Hexagon;\n\t\t} else {\n\t\t\t// Horizontal\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\tgrid.hEdges[p1.y][x].type = EdgeType.Hexagon;\n\t\t}\n\t}\n\n\tprivate shuffleArray(array: any[]) {\n\t\tfor (let i = array.length - 1; i > 0; i--) {\n\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t[array[i], array[j]] = [array[j], array[i]];\n\t\t}\n\t}\n}\n", "// validator.ts\nimport { Grid } from \"./grid\";\nimport { CellType, EdgeType, NodeType, Point, SolutionPath, ValidationResult } from \"./types\";\n\nexport class PuzzleValidator {\n\tpublic validate(grid: Grid, solution: SolutionPath): ValidationResult {\n\t\tconst path = solution.points;\n\n\t\t// 1. \u57FA\u672C\u7684\u306A\u30D1\u30B9\u306E\u6709\u52B9\u6027\u30C1\u30A7\u30C3\u30AF (\u9023\u7D9A\u6027\u3001\u59CB\u70B9\u7D42\u70B9)\n\t\tif (path.length < 2) return { isValid: false, errorReason: \"Path too short\" };\n\n\t\tconst start = path[0];\n\t\tconst end = path[path.length - 1];\n\n\t\tif (grid.nodes[start.y][start.x].type !== NodeType.Start) {\n\t\t\treturn { isValid: false, errorReason: \"Must start at Start Node\" };\n\t\t}\n\t\tif (grid.nodes[end.y][end.x].type !== NodeType.End) {\n\t\t\t// Note: The Witness\u306E\u30EB\u30FC\u30EB\u3067\u306F\u30B4\u30FC\u30EB\u306F\u8907\u6570\u3042\u308B\u5834\u5408\u3082\u3042\u308B\u304C\u3001\u3053\u3053\u3067\u306F\u7C21\u7565\u5316\n\t\t\treturn { isValid: false, errorReason: \"Must end at End Node\" };\n\t\t}\n\n\t\t// 2. \u30D1\u30B9\u306E\u9023\u7D9A\u6027\u3068\u81EA\u5DF1\u4EA4\u5DEE\u306E\u30C1\u30A7\u30C3\u30AF\n\t\tconst visitedNodes = new Set<string>();\n\t\tvisitedNodes.add(`${start.x},${start.y}`);\n\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst p1 = path[i];\n\t\t\tconst p2 = path[i + 1];\n\n\t\t\t// \u8DDD\u96E2\u304C1\u3067\u3042\u308B\u3053\u3068\n\t\t\tconst dist = Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n\t\t\tif (dist !== 1) return { isValid: false, errorReason: \"Invalid jump in path\" };\n\n\t\t\t// \u65E2\u306B\u901A\u3063\u305F\u30CE\u30FC\u30C9\u3067\u306F\u306A\u3044\u3053\u3068 (\u81EA\u5DF1\u4EA4\u5DEE\u7981\u6B62)\n\t\t\tconst key = `${p2.x},${p2.y}`;\n\t\t\tif (visitedNodes.has(key)) return { isValid: false, errorReason: \"Self-intersecting path\" };\n\t\t\tvisitedNodes.add(key);\n\n\t\t\t// \u901A\u884C\u4E0D\u53EF\u30A8\u30C3\u30B8(Broken)\u3067\u306A\u3044\u304B\u30C1\u30A7\u30C3\u30AF\n\t\t\tif (this.isBrokenEdge(grid, p1, p2)) {\n\t\t\t\treturn { isValid: false, errorReason: \"Passed through broken edge\" };\n\t\t\t}\n\t\t}\n\n\t\t// 3. \u30EB\u30FC\u30EB\u691C\u8A3C: Hexagon (\u901A\u904E\u5FC5\u9808)\n\t\tif (!this.checkHexagonConstraint(grid, path)) {\n\t\t\treturn { isValid: false, errorReason: \"Missed hexagon constraint\" };\n\t\t}\n\n\t\t// 4. \u30EB\u30FC\u30EB\u691C\u8A3C: \u30BB\u30EB\u5236\u7D04 (Squares & Stars)\n\t\tif (!this.checkCellConstraints(grid, path)) {\n\t\t\treturn { isValid: false, errorReason: \"Cell constraints failed\" };\n\t\t}\n\n\t\treturn { isValid: true };\n\t}\n\n\tprivate isBrokenEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\treturn grid.vEdges[y][p1.x].type === EdgeType.Broken;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\treturn grid.hEdges[p1.y][x].type === EdgeType.Broken;\n\t\t}\n\t}\n\n\tprivate checkHexagonConstraint(grid: Grid, path: Point[]): boolean {\n\t\t// \u30D1\u30B9\u4E0A\u306E\u30A8\u30C3\u30B8\u30AD\u30FC\u96C6\u5408\u3092\u4F5C\u6210\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst p1 = path[i];\n\t\t\tconst p2 = path[i + 1];\n\t\t\tpathEdges.add(this.getEdgeKey(p1, p2));\n\t\t}\n\n\t\t// \u30B0\u30EA\u30C3\u30C9\u4E0A\u306E\u5168\u30D8\u30AD\u30B5\u30B4\u30F3\u30A8\u30C3\u30B8\u3092\u78BA\u8A8D\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t// Horizontal Check\n\t\t\t\tif (r < grid.rows + 1 && grid.hEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r });\n\t\t\t\t\tif (!pathEdges.has(key)) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\t// Vertical Check\n\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 });\n\t\t\t\t\tif (!pathEdges.has(key)) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate checkCellConstraints(grid: Grid, path: Point[]): boolean {\n\t\tconst regions = this.calculateRegions(grid, path);\n\n\t\tfor (const region of regions) {\n\t\t\tconst colorCounts = new Map<number, number>();\n\t\t\tconst starColors = new Set<number>();\n\t\t\tconst squareColors = new Set<number>();\n\n\t\t\tfor (const cell of region) {\n\t\t\t\tconst constraint = grid.cells[cell.y][cell.x];\n\n\t\t\t\tif (constraint.type === CellType.None) continue;\n\n\t\t\t\tconst color = constraint.color;\n\t\t\t\tcolorCounts.set(color, (colorCounts.get(color) || 0) + 1);\n\n\t\t\t\tif (constraint.type === CellType.Square) {\n\t\t\t\t\tsquareColors.add(color);\n\t\t\t\t} else if (constraint.type === CellType.Star) {\n\t\t\t\t\tstarColors.add(color);\n\t\t\t\t}\n\t\t\t\t// Squares: All squares in a region must be the same color\n\t\t\t\tif (squareColors.size > 1) return false;\n\t\t\t}\n\t\t\t// Stars: For each color that has a star, there must be exactly 2 marks of that color\n\t\t\tfor (const color of starColors) {\n\t\t\t\tif (colorCounts.get(color) !== 2) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate calculateRegions(grid: Grid, path: Point[]): Point[][] {\n\t\t// Flood Fill (Generator\u306E\u5B9F\u88C5\u3068\u540C\u7B49)\n\t\tconst regions: Point[][] = [];\n\t\tconst visitedCells = new Set<string>();\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t}\n\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (visitedCells.has(`${c},${r}`)) continue;\n\n\t\t\t\tconst region: Point[] = [];\n\t\t\t\tconst queue: Point[] = [{ x: c, y: r }];\n\t\t\t\tvisitedCells.add(`${c},${r}`);\n\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst curr = queue.shift()!;\n\t\t\t\t\tregion.push(curr);\n\n\t\t\t\t\tconst neighbors = [\n\t\t\t\t\t\t{ nx: curr.x, ny: curr.y - 1, p1: { x: curr.x, y: curr.y }, p2: { x: curr.x + 1, y: curr.y } }, // Up\n\t\t\t\t\t\t{ nx: curr.x, ny: curr.y + 1, p1: { x: curr.x, y: curr.y + 1 }, p2: { x: curr.x + 1, y: curr.y + 1 } }, // Down\n\t\t\t\t\t\t{ nx: curr.x - 1, ny: curr.y, p1: { x: curr.x, y: curr.y }, p2: { x: curr.x, y: curr.y + 1 } }, // Left\n\t\t\t\t\t\t{ nx: curr.x + 1, ny: curr.y, p1: { x: curr.x + 1, y: curr.y }, p2: { x: curr.x + 1, y: curr.y + 1 } }, // Right\n\t\t\t\t\t];\n\n\t\t\t\t\tfor (const n of neighbors) {\n\t\t\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\t\t\tif (!visitedCells.has(`${n.nx},${n.ny}`)) {\n\t\t\t\t\t\t\t\tconst edgeKey = this.getEdgeKey(n.p1, n.p2);\n\t\t\t\t\t\t\t\tconst isBroken = this.isBrokenEdge(grid, n.p1, n.p2);\n\t\t\t\t\t\t\t\tif (!pathEdges.has(edgeKey) && !isBroken) {\n\t\t\t\t\t\t\t\t\tvisitedCells.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregions.push(region);\n\t\t\t}\n\t\t}\n\t\treturn regions;\n\t}\n\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n}\n", "// index.ts\nimport { PuzzleGenerator } from \"./generator\";\nimport { Grid } from \"./grid\";\nimport { PuzzleData, SolutionPath, ValidationResult } from \"./types\";\nimport { PuzzleValidator } from \"./validator\";\n\n// \u30E9\u30A4\u30D6\u30E9\u30EA\u306E\u30D5\u30A1\u30B5\u30FC\u30C9\u30AF\u30E9\u30B9\nexport class WitnessCore {\n\tprivate generator: PuzzleGenerator;\n\tprivate validator: PuzzleValidator;\n\n\tconstructor() {\n\t\tthis.generator = new PuzzleGenerator();\n\t\tthis.validator = new PuzzleValidator();\n\t}\n\n\t/**\n\t * \u65B0\u3057\u3044\u30D1\u30BA\u30EB\u3092\u751F\u6210\u3057\u3066\u30C7\u30FC\u30BF\u3092\u8FD4\u3059\n\t */\n\tpublic createPuzzle(rows: number, cols: number, complexity: number = 0.5): PuzzleData {\n\t\tconst grid = this.generator.generate(rows, cols, complexity);\n\t\treturn grid.export();\n\t}\n\n\t/**\n\t * \u89E3\u7B54\u3092\u691C\u8A3C\u3059\u308B\n\t */\n\tpublic validateSolution(puzzleData: PuzzleData, solution: SolutionPath): ValidationResult {\n\t\tconst grid = Grid.fromData(puzzleData);\n\t\treturn this.validator.validate(grid, solution);\n\t}\n}\n\n// \u30D6\u30E9\u30A6\u30B6/Node.js\u74B0\u5883\u4E21\u5BFE\u5FDC\u306E\u305F\u3081\u306E\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\nexport * from \"./types\";\n"],
  "mappings": "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",
  "names": ["Direction", "CellType", "EdgeType", "NodeType", "Color", "Grid", "_Grid", "rows", "cols", "data", "grid", "PuzzleGenerator", "rows", "cols", "complexity", "grid", "Grid", "startPoint", "endPoint", "solutionPath", "start", "end", "visited", "path", "stack", "findPath", "current", "neighbors", "next", "p", "candidates", "directions", "d", "nx", "ny", "p1", "p2", "regions", "availableColors", "region", "color", "visitedCells", "pathEdges", "k", "r", "c", "currentRegion", "queue", "cell", "n", "key", "cells", "density", "shuffled", "i", "y", "x", "array", "j", "PuzzleValidator", "grid", "solution", "path", "start", "end", "visitedNodes", "i", "p1", "p2", "key", "y", "x", "pathEdges", "r", "c", "regions", "region", "colorCounts", "starColors", "squareColors", "cell", "constraint", "color", "visitedCells", "queue", "curr", "neighbors", "n", "edgeKey", "isBroken", "WitnessCore", "PuzzleGenerator", "PuzzleValidator", "rows", "cols", "complexity", "puzzleData", "solution", "grid", "Grid"]
}
