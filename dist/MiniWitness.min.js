var S=(e=>(e[e.Up=0]="Up",e[e.Right=1]="Right",e[e.Down=2]="Down",e[e.Left=3]="Left",e))(S||{}),g=(o=>(o[o.None=0]="None",o[o.Square=1]="Square",o[o.Star=2]="Star",o))(g||{}),m=(o=>(o[o.Normal=0]="Normal",o[o.Hexagon=1]="Hexagon",o[o.Broken=2]="Broken",o))(m||{}),P=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o))(P||{}),E=(s=>(s[s.None=0]="None",s[s.Black=1]="Black",s[s.White=2]="White",s[s.Red=3]="Red",s[s.Blue=4]="Blue",s))(E||{});var h=class p{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(t,n){this.rows=t,this.cols=n,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:0}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(t){let n=new p(t.rows,t.cols);return n.cells=t.cells,n.vEdges=t.vEdges,n.hEdges=t.hEdges,n.nodes=t.nodes,n}};var b=class{generate(t,n,o=.5){let e=new h(t,n),s={x:0,y:t},r={x:n,y:0};e.nodes[s.y][s.x].type=1,e.nodes[r.y][r.x].type=2;let a=this.generateRandomPath(e,s,r);return this.applyConstraintsBasedOnPath(e,a,o),e}generateRandomPath(t,n,o){let e=new Set,s=[],r=[n];new Map().set(`${n.x},${n.y}`,null);let l=c=>{if(e.add(`${c.x},${c.y}`),s.push(c),c.x===o.x&&c.y===o.y)return!0;let i=this.getValidNeighbors(t,c,e);this.shuffleArray(i);for(let y of i)if(l(y))return!0;return s.pop(),!1};return l(n),s}getValidNeighbors(t,n,o){let e=[],s=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let r of s){let a=n.x+r.x,l=n.y+r.y;a>=0&&a<=t.cols&&l>=0&&l<=t.rows&&(o.has(`${a},${l}`)||e.push({x:a,y:l}))}return e}applyConstraintsBasedOnPath(t,n,o){for(let r=0;r<n.length-1;r++){let a=n[r],l=n[r+1];Math.random()<o*.4&&this.setEdgeHexagon(t,a,l)}let e=this.calculateRegions(t,n),s=[1,2,3,4];for(let r=0;r<e.length;r++){let a=e[r],l=s[r%s.length];Math.random()<.3+o*.4&&(Math.random()<.3?this.fillRegionWithStarPairs(t,a,l):this.fillRegionWithColor(t,a,l,o))}}calculateRegions(t,n){let o=[],e=new Set,s=new Set;for(let a=0;a<n.length-1;a++){let l=n[a],c=n[a+1],i=l.x<c.x||l.y<c.y?`${l.x},${l.y}-${c.x},${c.y}`:`${c.x},${c.y}-${l.x},${l.y}`;s.add(i)}let r=(a,l)=>!1;for(let a=0;a<t.rows;a++)for(let l=0;l<t.cols;l++){if(e.has(`${l},${a}`))continue;let c=[],i=[{x:l,y:a}];for(e.add(`${l},${a}`);i.length>0;){let y=i.shift();c.push(y);let d=[{dx:0,dy:-1,boundary:{p1:{x:y.x,y:y.y},p2:{x:y.x+1,y:y.y}}},{dx:0,dy:1,boundary:{p1:{x:y.x,y:y.y+1},p2:{x:y.x+1,y:y.y+1}}},{dx:-1,dy:0,boundary:{p1:{x:y.x,y:y.y},p2:{x:y.x,y:y.y+1}}},{dx:1,dy:0,boundary:{p1:{x:y.x+1,y:y.y},p2:{x:y.x+1,y:y.y+1}}}];for(let x of d){let u=y.x+x.dx,f=y.y+x.dy;if(u>=0&&u<t.cols&&f>=0&&f<t.rows&&!e.has(`${u},${f}`)){let w=x.boundary.p1.x<x.boundary.p2.x||x.boundary.p1.y<x.boundary.p2.y?`${x.boundary.p1.x},${x.boundary.p1.y}-${x.boundary.p2.x},${x.boundary.p2.y}`:`${x.boundary.p2.x},${x.boundary.p2.y}-${x.boundary.p1.x},${x.boundary.p1.y}`;s.has(w)||(e.add(`${u},${f}`),i.push({x:u,y:f}))}}}o.push(c)}return o}fillRegionWithColor(t,n,o,e){for(let s of n)Math.random()<e*.7&&(t.cells[s.y][s.x].type=1,t.cells[s.y][s.x].color=o)}fillRegionWithStarPairs(t,n,o){if(n.length<2)return;let e=[...n];this.shuffleArray(e);for(let s=0;s<2;s++)t.cells[e[s].y][e[s].x].type=2,t.cells[e[s].y][e[s].x].color=o}setEdgeHexagon(t,n,o){if(n.x===o.x){let e=Math.min(n.y,o.y);t.vEdges[e][n.x].type=1}else{let e=Math.min(n.x,o.x);t.hEdges[n.y][e].type=1}}shuffleArray(t){for(let n=t.length-1;n>0;n--){let o=Math.floor(Math.random()*(n+1));[t[n],t[o]]=[t[o],t[n]]}}};var $=class{validate(t,n){let o=n.points;if(o.length<2)return{isValid:!1,errorReason:"Path too short"};let e=o[0],s=o[o.length-1];if(t.nodes[e.y][e.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(t.nodes[s.y][s.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let r=new Set;r.add(`${e.x},${e.y}`);for(let a=0;a<o.length-1;a++){let l=o[a],c=o[a+1];if(Math.abs(l.x-c.x)+Math.abs(l.y-c.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let y=`${c.x},${c.y}`;if(r.has(y))return{isValid:!1,errorReason:"Self-intersecting path"};if(r.add(y),this.isBrokenEdge(t,l,c))return{isValid:!1,errorReason:"Passed through broken edge"}}return this.checkHexagonConstraint(t,o)?this.checkCellConstraints(t,o)?{isValid:!0}:{isValid:!1,errorReason:"Cell constraints failed"}:{isValid:!1,errorReason:"Missed hexagon constraint"}}isBrokenEdge(t,n,o){if(n.x===o.x){let e=Math.min(n.y,o.y);return t.vEdges[e][n.x].type===2}else{let e=Math.min(n.x,o.x);return t.hEdges[n.y][e].type===2}}checkHexagonConstraint(t,n){let o=new Set;for(let e=0;e<n.length-1;e++){let s=n[e],r=n[e+1];o.add(this.getEdgeKey(s,r))}for(let e=0;e<=t.rows;e++)for(let s=0;s<t.cols;s++)if(e<t.rows+1&&t.hEdges[e][s].type===1){let r=this.getEdgeKey({x:s,y:e},{x:s+1,y:e});if(!o.has(r))return!1}for(let e=0;e<t.rows;e++)for(let s=0;s<=t.cols;s++)if(t.vEdges[e][s].type===1){let r=this.getEdgeKey({x:s,y:e},{x:s,y:e+1});if(!o.has(r))return!1}return!0}checkCellConstraints(t,n){let o=this.calculateRegions(t,n);for(let e of o){let s=new Map,r=new Set,a=new Set;for(let l of e){let c=t.cells[l.y][l.x];if(c.type===0)continue;let i=c.color;if(s.set(i,(s.get(i)||0)+1),c.type===1?a.add(i):c.type===2&&r.add(i),a.size>1)return!1;for(let y of r)if(s.get(y)!==2)return!1}}return!0}calculateRegions(t,n){let o=[],e=new Set,s=new Set;for(let r=0;r<n.length-1;r++)s.add(this.getEdgeKey(n[r],n[r+1]));for(let r=0;r<t.rows;r++)for(let a=0;a<t.cols;a++){if(e.has(`${a},${r}`))continue;let l=[],c=[{x:a,y:r}];for(e.add(`${a},${r}`);c.length>0;){let i=c.shift();l.push(i);let y=[{nx:i.x,ny:i.y-1,p1:{x:i.x,y:i.y},p2:{x:i.x+1,y:i.y}},{nx:i.x,ny:i.y+1,p1:{x:i.x,y:i.y+1},p2:{x:i.x+1,y:i.y+1}},{nx:i.x-1,ny:i.y,p1:{x:i.x,y:i.y},p2:{x:i.x,y:i.y+1}},{nx:i.x+1,ny:i.y,p1:{x:i.x+1,y:i.y},p2:{x:i.x+1,y:i.y+1}}];for(let d of y)if(d.nx>=0&&d.nx<t.cols&&d.ny>=0&&d.ny<t.rows&&!e.has(`${d.nx},${d.ny}`)){let x=this.getEdgeKey(d.p1,d.p2),u=this.isBrokenEdge(t,d.p1,d.p2);!s.has(x)&&!u&&(e.add(`${d.nx},${d.ny}`),c.push({x:d.nx,y:d.ny}))}}o.push(l)}return o}getEdgeKey(t,n){return t.x<n.x||t.x===n.x&&t.y<n.y?`${t.x},${t.y}-${n.x},${n.y}`:`${n.x},${n.y}-${t.x},${t.y}`}};var v=class{generator;validator;constructor(){this.generator=new b,this.validator=new $}createPuzzle(t,n,o=.5){return this.generator.generate(t,n,o).export()}validateSolution(t,n){let o=h.fromData(t);return this.validator.validate(o,n)}};export{g as CellType,E as Color,S as Direction,m as EdgeType,P as NodeType,v as WitnessCore};
//# sourceMappingURL=MiniWitness.min.js.map
