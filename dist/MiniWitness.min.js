var R=(n=>(n[n.Up=0]="Up",n[n.Right=1]="Right",n[n.Down=2]="Down",n[n.Left=3]="Left",n))(R||{}),g=(t=>(t[t.None=0]="None",t[t.Square=1]="Square",t))(g||{}),m=(o=>(o[o.Normal=0]="Normal",o[o.Hexagon=1]="Hexagon",o[o.Broken=2]="Broken",o))(m||{}),P=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o))(P||{}),E=(s=>(s[s.None=0]="None",s[s.Black=1]="Black",s[s.White=2]="White",s[s.Red=3]="Red",s[s.Blue=4]="Blue",s))(E||{});var u=class p{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:0}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(e){let t=new p(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t}};var b=class{generate(e,t,o=.5){let n=new u(e,t),s={x:0,y:e},r={x:t,y:0};n.nodes[s.y][s.x].type=1,n.nodes[r.y][r.x].type=2;let i=this.generateRandomPath(n,s,r);return this.applyConstraintsBasedOnPath(n,i,o),n}generateRandomPath(e,t,o){let n=new Set,s=[],r=[t];new Map().set(`${t.x},${t.y}`,null);let l=y=>{if(n.add(`${y.x},${y.y}`),s.push(y),y.x===o.x&&y.y===o.y)return!0;let a=this.getValidNeighbors(e,y,n);this.shuffleArray(a);for(let c of a)if(l(c))return!0;return s.pop(),!1};return l(t),s}getValidNeighbors(e,t,o){let n=[],s=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let r of s){let i=t.x+r.x,l=t.y+r.y;i>=0&&i<=e.cols&&l>=0&&l<=e.rows&&(o.has(`${i},${l}`)||n.push({x:i,y:l}))}return n}applyConstraintsBasedOnPath(e,t,o){for(let s=0;s<t.length-1;s++){let r=t[s],i=t[s+1];Math.random()<o*.4&&this.setEdgeHexagon(e,r,i)}let n=this.calculateRegions(e,t);if(n.length>=2){let s=1,r=2;this.fillRegionWithColor(e,n[0],s,o),this.fillRegionWithColor(e,n[1],r,o)}}calculateRegions(e,t){let o=[],n=new Set,s=new Set;for(let i=0;i<t.length-1;i++){let l=t[i],y=t[i+1],a=l.x<y.x||l.y<y.y?`${l.x},${l.y}-${y.x},${y.y}`:`${y.x},${y.y}-${l.x},${l.y}`;s.add(a)}let r=(i,l)=>!1;for(let i=0;i<e.rows;i++)for(let l=0;l<e.cols;l++){if(n.has(`${l},${i}`))continue;let y=[],a=[{x:l,y:i}];for(n.add(`${l},${i}`);a.length>0;){let c=a.shift();y.push(c);let x=[{dx:0,dy:-1,boundary:{p1:{x:c.x,y:c.y},p2:{x:c.x+1,y:c.y}}},{dx:0,dy:1,boundary:{p1:{x:c.x,y:c.y+1},p2:{x:c.x+1,y:c.y+1}}},{dx:-1,dy:0,boundary:{p1:{x:c.x,y:c.y},p2:{x:c.x,y:c.y+1}}},{dx:1,dy:0,boundary:{p1:{x:c.x+1,y:c.y},p2:{x:c.x+1,y:c.y+1}}}];for(let d of x){let h=c.x+d.dx,f=c.y+d.dy;if(h>=0&&h<e.cols&&f>=0&&f<e.rows&&!n.has(`${h},${f}`)){let w=d.boundary.p1.x<d.boundary.p2.x||d.boundary.p1.y<d.boundary.p2.y?`${d.boundary.p1.x},${d.boundary.p1.y}-${d.boundary.p2.x},${d.boundary.p2.y}`:`${d.boundary.p2.x},${d.boundary.p2.y}-${d.boundary.p1.x},${d.boundary.p1.y}`;s.has(w)||(n.add(`${h},${f}`),a.push({x:h,y:f}))}}}o.push(y)}return o}fillRegionWithColor(e,t,o,n){for(let s of t)Math.random()<n&&(e.cells[s.y][s.x].type=1,e.cells[s.y][s.x].color=o)}setEdgeHexagon(e,t,o){if(t.x===o.x){let n=Math.min(t.y,o.y);e.vEdges[n][t.x].type=1}else{let n=Math.min(t.x,o.x);e.hEdges[t.y][n].type=1}}shuffleArray(e){for(let t=e.length-1;t>0;t--){let o=Math.floor(Math.random()*(t+1));[e[t],e[o]]=[e[o],e[t]]}}};var $=class{validate(e,t){let o=t.points;if(o.length<2)return{isValid:!1,errorReason:"Path too short"};let n=o[0],s=o[o.length-1];if(e.nodes[n.y][n.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[s.y][s.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let r=new Set;r.add(`${n.x},${n.y}`);for(let i=0;i<o.length-1;i++){let l=o[i],y=o[i+1];if(Math.abs(l.x-y.x)+Math.abs(l.y-y.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let c=`${y.x},${y.y}`;if(r.has(c))return{isValid:!1,errorReason:"Self-intersecting path"};if(r.add(c),this.isBrokenEdge(e,l,y))return{isValid:!1,errorReason:"Passed through broken edge"}}return this.checkHexagonConstraint(e,o)?this.checkSquareConstraint(e,o)?{isValid:!0}:{isValid:!1,errorReason:"Color segregation failed"}:{isValid:!1,errorReason:"Missed hexagon constraint"}}isBrokenEdge(e,t,o){if(t.x===o.x){let n=Math.min(t.y,o.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,o.x);return e.hEdges[t.y][n].type===2}}checkHexagonConstraint(e,t){let o=new Set;for(let n=0;n<t.length-1;n++){let s=t[n],r=t[n+1];o.add(this.getEdgeKey(s,r))}for(let n=0;n<=e.rows;n++)for(let s=0;s<e.cols;s++)if(n<e.rows+1&&e.hEdges[n][s].type===1){let r=this.getEdgeKey({x:s,y:n},{x:s+1,y:n});if(!o.has(r))return!1}for(let n=0;n<e.rows;n++)for(let s=0;s<=e.cols;s++)if(e.vEdges[n][s].type===1){let r=this.getEdgeKey({x:s,y:n},{x:s,y:n+1});if(!o.has(r))return!1}return!0}checkSquareConstraint(e,t){let o=this.calculateRegions(e,t);for(let n of o){let s=null;for(let r of n){let i=e.cells[r.y][r.x];if(i.type===1){if(s===null)s=i.color;else if(s!==i.color)return!1}}}return!0}calculateRegions(e,t){let o=[],n=new Set,s=new Set;for(let r=0;r<t.length-1;r++)s.add(this.getEdgeKey(t[r],t[r+1]));for(let r=0;r<e.rows;r++)for(let i=0;i<e.cols;i++){if(n.has(`${i},${r}`))continue;let l=[],y=[{x:i,y:r}];for(n.add(`${i},${r}`);y.length>0;){let a=y.shift();l.push(a);let c=[{nx:a.x,ny:a.y-1,p1:{x:a.x,y:a.y},p2:{x:a.x+1,y:a.y}},{nx:a.x,ny:a.y+1,p1:{x:a.x,y:a.y+1},p2:{x:a.x+1,y:a.y+1}},{nx:a.x-1,ny:a.y,p1:{x:a.x,y:a.y},p2:{x:a.x,y:a.y+1}},{nx:a.x+1,ny:a.y,p1:{x:a.x+1,y:a.y},p2:{x:a.x+1,y:a.y+1}}];for(let x of c)if(x.nx>=0&&x.nx<e.cols&&x.ny>=0&&x.ny<e.rows&&!n.has(`${x.nx},${x.ny}`)){let d=this.getEdgeKey(x.p1,x.p2);s.has(d)||(n.add(`${x.nx},${x.ny}`),y.push({x:x.nx,y:x.ny}))}}o.push(l)}return o}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}};var v=class{generator;validator;constructor(){this.generator=new b,this.validator=new $}createPuzzle(e,t,o=.5){return this.generator.generate(e,t,o).export()}validateSolution(e,t){let o=u.fromData(e);return this.validator.validate(o,t)}};export{g as CellType,E as Color,R as Direction,m as EdgeType,P as NodeType,v as WitnessCore};
//# sourceMappingURL=MiniWitness.min.js.map
