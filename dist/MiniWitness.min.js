var U=(n=>(n[n.Up=0]="Up",n[n.Right=1]="Right",n[n.Down=2]="Down",n[n.Left=3]="Left",n))(U||{}),F=(s=>(s[s.None=0]="None",s[s.Square=1]="Square",s[s.Star=2]="Star",s[s.Tetris=3]="Tetris",s[s.TetrisRotated=4]="TetrisRotated",s[s.Eraser=5]="Eraser",s))(F||{}),j=(n=>(n[n.Normal=0]="Normal",n[n.Broken=1]="Broken",n[n.Absent=2]="Absent",n[n.Hexagon=3]="Hexagon",n))(j||{}),W=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o))(W||{}),J=(l=>(l[l.None=0]="None",l[l.Black=1]="Black",l[l.White=2]="White",l[l.Red=3]="Red",l[l.Blue=4]="Blue",l))(J||{});var q=class D{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:0}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(e){let t=new D(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t}};var I=class{validate(e,t){let o=t.points;if(o.length<2)return{isValid:!1,errorReason:"Path too short"};let n=o[0],l=o[o.length-1];if(e.nodes[n.y][n.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[l.y][l.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let s=new Set;s.add(`${n.x},${n.y}`);for(let c=0;c<o.length-1;c++){let i=o[c],a=o[c+1];if(Math.abs(i.x-a.x)+Math.abs(i.y-a.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let h=`${a.x},${a.y}`;if(s.has(h))return{isValid:!1,errorReason:"Self-intersecting path"};if(s.add(h),this.isBrokenEdge(e,i,a))return{isValid:!1,errorReason:"Passed through broken edge"}}let r=this.calculateRegions(e,o),u=this.getMissedHexagons(e,o);return this.validateWithErasers(e,r,u)}isBrokenEdge(e,t,o){let n;if(t.x===o.x){let l=Math.min(t.y,o.y);n=e.vEdges[l][t.x].type}else{let l=Math.min(t.x,o.x);n=e.hEdges[t.y][l].type}return n===1||n===2}isAbsentEdge(e,t,o){if(t.x===o.x){let n=Math.min(t.y,o.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,o.x);return e.hEdges[t.y][n].type===2}}getMissedHexagons(e,t){let o=new Set;for(let l=0;l<t.length-1;l++)o.add(this.getEdgeKey(t[l],t[l+1]));let n=[];for(let l=0;l<=e.rows;l++)for(let s=0;s<e.cols;s++)if(e.hEdges[l][s].type===3){let r=this.getEdgeKey({x:s,y:l},{x:s+1,y:l});o.has(r)||n.push({type:"h",r:l,c:s})}for(let l=0;l<e.rows;l++)for(let s=0;s<=e.cols;s++)if(e.vEdges[l][s].type===3){let r=this.getEdgeKey({x:s,y:l},{x:s,y:l+1});o.has(r)||n.push({type:"v",r:l,c:s})}return n}validateWithErasers(e,t,o){let n=[];for(let s=0;s<t.length;s++){let r=t[s],u=r.filter(f=>e.cells[f.y][f.x].type===5),c=r.filter(f=>e.cells[f.y][f.x].type!==0&&e.cells[f.y][f.x].type!==5),i=[];for(let f=0;f<o.length;f++)this.isHexagonAdjacentToRegion(e,o[f],r)&&i.push(f);let a=this.getPossibleErasures(e,r,u,c,i);if(a.length===0)return{isValid:!1,errorReason:`Constraints failed in region ${s}`};a.sort((f,h)=>{let y=f.invalidatedCells.length+f.invalidatedHexagons.length,p=h.invalidatedCells.length+h.invalidatedHexagons.length;return y-p}),n.push(a)}let l=this.findGlobalAssignment(n,o.length);return l?{isValid:!0,invalidatedCells:l.invalidatedCells,invalidatedEdges:l.invalidatedHexIndices.map(s=>o[s])}:{isValid:!1,errorReason:"Could not satisfy all constraints with available erasers"}}isHexagonAdjacentToRegion(e,t,o){let n=new Set(o.map(l=>`${l.x},${l.y}`));if(t.type==="h"){if(t.r>0&&n.has(`${t.c},${t.r-1}`)||t.r<e.rows&&n.has(`${t.c},${t.r}`))return!0}else if(t.c>0&&n.has(`${t.c-1},${t.r}`)||t.c<e.cols&&n.has(`${t.c},${t.r}`))return!0;return!1}getPossibleErasures(e,t,o,n,l){let s=[],r=o.length;if(r===0)return this.checkRegionValid(e,t,[],[])&&s.push({invalidatedCells:[],invalidatedHexagons:[],isValid:!0}),s;let u=[...n.map(i=>({type:"cell",pos:i})),...l.map(i=>({type:"hex",index:i}))],c=this.checkRegionValid(e,t,[],[])&&l.length===0;for(let i=0;i<=r;i++){let a=this.getNCombinations(o,i);for(let f of a){let h=new Set(f.map(p=>`${p.x},${p.y}`)),y=o.filter(p=>!h.has(`${p.x},${p.y}`));for(let p=0;p<=u.length;p++){if(y.length!==i+p)continue;let v=this.getNCombinations(u,p);for(let E of v){let b=E.filter(g=>g.type==="cell").map(g=>g.pos),w=E.filter(g=>g.type==="hex").map(g=>g.index);if(this.checkRegionValid(e,t,[...b,...f],y)){let g=!0;if(c)p>0&&(g=!1);else for(let C=0;C<E.length;C++){let $=[...E.slice(0,C),...E.slice(C+1)],O=$.filter(x=>x.type==="cell").map(x=>x.pos),m=new Set($.filter(x=>x.type==="hex").map(x=>x.index)),A=l.every(x=>m.has(x));if(this.checkRegionValid(e,t,O,y)&&A){g=!1;break}}g&&s.push({invalidatedCells:[...b,...f],invalidatedHexagons:w,isValid:!0})}}}}}return s}getNCombinations(e,t){let o=[],n=(l,s)=>{if(s.length===t){o.push([...s]);return}for(let r=l;r<e.length;r++)s.push(e[r]),n(r+1,s),s.pop()};return n(0,[]),o}checkRegionValid(e,t,o,n){let l=new Set(o.map(a=>`${a.x},${a.y}`)),s=new Set(n.map(a=>`${a.x},${a.y}`)),r=new Map,u=new Set,c=new Set,i=[];for(let a of t){if(l.has(`${a.x},${a.y}`))continue;let f=e.cells[a.y][a.x];if(f.type===0)continue;let h=f.type===5&&s.has(`${a.x},${a.y}`),y=f.type!==5;if(!h&&!y)continue;let p=f.color;p!==0&&r.set(p,(r.get(p)||0)+1),f.type===1?c.add(p):f.type===2?u.add(p):(f.type===3||f.type===4)&&f.shape&&i.push({shape:f.shape,rotatable:f.type===4})}if(c.size>1)return!1;for(let a of u)if(r.get(a)!==2)return!1;return!(i.length>0&&!this.checkTetrisConstraint(t,i))}findGlobalAssignment(e,t){let o=e.length,n=new Array(t).fill(0),l=[],s=[],r=u=>{if(u===o)return n.every(c=>c===1);for(let c of e[u]){let i=!0;for(let a of c.invalidatedHexagons)if(n[a]>0){i=!1;break}if(i){for(let a of c.invalidatedHexagons)n[a]++,s.push(a);if(l.push(...c.invalidatedCells),r(u+1))return!0;for(let a of c.invalidatedHexagons)n[a]--,s.pop();for(let a=0;a<c.invalidatedCells.length;a++)l.pop()}}return!1};return r(0)?{invalidatedCells:l,invalidatedHexIndices:s}:null}checkTetrisConstraint(e,t){if(t.reduce((a,f)=>a+this.getShapeArea(f.shape),0)!==e.length)return!1;let n=Math.min(...e.map(a=>a.x)),l=Math.min(...e.map(a=>a.y)),s=Math.max(...e.map(a=>a.x)),r=Math.max(...e.map(a=>a.y)),u=s-n+1,c=r-l+1,i=Array.from({length:c},()=>Array(u).fill(!1));for(let a of e)i[a.y-l][a.x-n]=!0;return this.canTile(i,t)}getShapeArea(e){let t=0;for(let o of e)for(let n of o)n&&t++;return t}canTile(e,t){let o=-1,n=-1;for(let l=0;l<e.length;l++){for(let s=0;s<e[0].length;s++)if(e[l][s]){o=l,n=s;break}if(o!==-1)break}if(o===-1)return t.length===0;if(t.length===0)return!1;for(let l=0;l<t.length;l++){let s=t[l],r=[...t.slice(0,l),...t.slice(l+1)],u=s.rotatable?this.getAllRotations(s.shape):[s.shape];for(let c of u){let i=[];for(let a=0;a<c.length;a++)for(let f=0;f<c[0].length;f++)c[a][f]&&i.push({r:a,c:f});for(let a of i){let f=o-a.r,h=n-a.c;if(this.canPlace(e,c,f,h)){if(this.placePiece(e,c,f,h,!1),this.canTile(e,r))return!0;this.placePiece(e,c,f,h,!0)}}}}return!1}canPlace(e,t,o,n){for(let l=0;l<t.length;l++)for(let s=0;s<t[0].length;s++)if(t[l][s]){let r=o+l,u=n+s;if(r<0||r>=e.length||u<0||u>=e[0].length||!e[r][u])return!1}return!0}placePiece(e,t,o,n,l){for(let s=0;s<t.length;s++)for(let r=0;r<t[0].length;r++)t[s][r]&&(e[o+s][n+r]=l)}getAllRotations(e){let t=[],o=new Set,n=e;for(let l=0;l<4;l++){let s=JSON.stringify(n);o.has(s)||(t.push(n),o.add(s)),n=this.rotate90(n)}return t}rotate90(e){let t=e.length,o=e[0].length,n=Array.from({length:o},()=>Array(t).fill(0));for(let l=0;l<t;l++)for(let s=0;s<o;s++)n[s][t-1-l]=e[l][s];return n}calculateRegions(e,t){let o=[],n=new Set,l=new Set;for(let r=0;r<t.length-1;r++)l.add(this.getEdgeKey(t[r],t[r+1]));let s=this.getExternalCells(e);for(let r=0;r<e.rows;r++)for(let u=0;u<e.cols;u++){if(n.has(`${u},${r}`)||s.has(`${u},${r}`))continue;let c=[],i=[{x:u,y:r}];for(n.add(`${u},${r}`);i.length>0;){let a=i.shift();c.push(a);let f=[{nx:a.x,ny:a.y-1,p1:{x:a.x,y:a.y},p2:{x:a.x+1,y:a.y}},{nx:a.x,ny:a.y+1,p1:{x:a.x,y:a.y+1},p2:{x:a.x+1,y:a.y+1}},{nx:a.x-1,ny:a.y,p1:{x:a.x,y:a.y},p2:{x:a.x,y:a.y+1}},{nx:a.x+1,ny:a.y,p1:{x:a.x+1,y:a.y},p2:{x:a.x+1,y:a.y+1}}];for(let h of f)if(h.nx>=0&&h.nx<e.cols&&h.ny>=0&&h.ny<e.rows){let y=`${h.nx},${h.ny}`;if(!n.has(y)&&!s.has(y)){let p=this.getEdgeKey(h.p1,h.p2);!l.has(p)&&!this.isAbsentEdge(e,h.p1,h.p2)&&(n.add(y),i.push({x:h.nx,y:h.ny}))}}}o.push(c)}return o}getExternalCells(e){let t=new Set,o=[];for(let n=0;n<e.cols;n++)e.hEdges[0][n].type===2&&(t.has(`${n},0`)||(t.add(`${n},0`),o.push({x:n,y:0}))),e.hEdges[e.rows][n].type===2&&(t.has(`${n},${e.rows-1}`)||(t.add(`${n},${e.rows-1}`),o.push({x:n,y:e.rows-1})));for(let n=0;n<e.rows;n++)e.vEdges[n][0].type===2&&(t.has(`0,${n}`)||(t.add(`0,${n}`),o.push({x:0,y:n}))),e.vEdges[n][e.cols].type===2&&(t.has(`${e.cols-1},${n}`)||(t.add(`${e.cols-1},${n}`),o.push({x:e.cols-1,y:n})));for(;o.length>0;){let n=o.shift(),l=[{nx:n.x,ny:n.y-1,edge:e.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:e.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:e.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:e.vEdges[n.y][n.x+1]}];for(let s of l)s.nx>=0&&s.nx<e.cols&&s.ny>=0&&s.ny<e.rows&&!t.has(`${s.nx},${s.ny}`)&&s.edge.type===2&&(t.add(`${s.nx},${s.ny}`),o.push({x:s.nx,y:s.ny}))}return t}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e){let t=e.rows,o=e.cols,n=o+1,l=(t+1)*n,s=Array.from({length:l},()=>[]),r=[],u=[],c=new Set;for(let m=0;m<=t;m++)for(let A=0;A<=o;A++){let x=m*n+A;if(e.nodes[m][A].type===1&&r.push(x),e.nodes[m][A].type===2&&u.push(x),A<o){let V=x+1,z=e.hEdges[m][A].type,S=z===3,M=z===1||z===2;s[x].push({next:V,isHexagon:S,isBroken:M}),s[V].push({next:x,isHexagon:S,isBroken:M}),S&&c.add(this.getEdgeKey({x:A,y:m},{x:A+1,y:m}))}if(m<t){let V=x+n,z=e.vEdges[m][A].type,S=z===3,M=z===1||z===2;s[x].push({next:V,isHexagon:S,isBroken:M}),s[V].push({next:x,isHexagon:S,isBroken:M}),S&&c.add(this.getEdgeKey({x:A,y:m},{x:A,y:m+1}))}}let i={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},a=c.size,f=new Set;for(let m of r)this.exploreSearchSpace(e,m,1n<<BigInt(m),[m],0,a,s,u,f,i,500);if(i.solutions===0)return 0;let h=c.size,y=new Set;c.size>0&&y.add(999);let p=0,v=0;for(let m=0;m<t;m++)for(let A=0;A<o;A++){let x=e.cells[m][A];x.type!==0&&(h++,y.add(x.type),x.type===3?p++:x.type===4&&(p++,v++))}let E=i.branchingPoints/(i.totalNodesVisited||1),b=Math.log10(i.totalNodesVisited+1),w=(E*10+b*1)/(Math.log2(i.solutions+1)+1);p>0&&(w+=v*.5,w+=(p-v)*.2);let N=t*o,g=h/N,C=g<.3?Math.pow(g/.3,3):1,$=y.size<=1?.4:1;w*=C*$;let O=Math.sqrt(N)/4;return w*=O,Math.max(.01,Math.min(1,w/4))}exploreSearchSpace(e,t,o,n,l,s,r,u,c,i,a){if(i.totalNodesVisited++,i.maxDepth=Math.max(i.maxDepth,n.length),i.totalNodesVisited>a)return;if(u.includes(t)){if(l===s){let h={points:n.map(y=>({x:y%(e.cols+1),y:Math.floor(y/(e.cols+1))}))};if(this.validate(e,h).isValid){let y=this.getFingerprint(e,h.points);c.has(y)||(c.add(y),i.solutions++)}}return}if(!this.canReachEndOptimized(t,o,r,u)){i.backtracks++;return}let f=[];for(let h of r[t]){if(h.isBroken||o&1n<<BigInt(h.next))continue;let y=!0;for(let p of r[t])if(p.isHexagon){let v=n.length>=2&&p.next===n[n.length-2],E=p.next===h.next;if(!v&&!E){y=!1;break}}y&&f.push(h)}f.length>1&&i.branchingPoints++;for(let h of f)if(n.push(h.next),this.exploreSearchSpace(e,h.next,o|1n<<BigInt(h.next),n,l+(h.isHexagon?1:0),s,r,u,c,i,a),n.pop(),i.totalNodesVisited>a)return}countSolutions(e,t=100){let o=e.rows,n=e.cols,l=n+1,s=(o+1)*l,r=Array.from({length:s},()=>[]),u=[],c=[],i=new Set;for(let h=0;h<=o;h++)for(let y=0;y<=n;y++){let p=h*l+y;if(e.nodes[h][y].type===1&&u.push(p),e.nodes[h][y].type===2&&c.push(p),y<n){let v=p+1,E=e.hEdges[h][y].type,b=E===3,w=E===1||E===2;r[p].push({next:v,isHexagon:b,isBroken:w}),r[v].push({next:p,isHexagon:b,isBroken:w}),b&&i.add(this.getEdgeKey({x:y,y:h},{x:y+1,y:h}))}if(h<o){let v=p+l,E=e.vEdges[h][y].type,b=E===3,w=E===1||E===2;r[p].push({next:v,isHexagon:b,isBroken:w}),r[v].push({next:p,isHexagon:b,isBroken:w}),b&&i.add(this.getEdgeKey({x:y,y:h},{x:y,y:h+1}))}}let a=new Set,f=i.size;for(let h of u)this.findPathsOptimized(e,h,1n<<BigInt(h),[h],0,f,r,c,a,t);return a.size}findPathsOptimized(e,t,o,n,l,s,r,u,c,i){if(!(c.size>=i)){if(u.includes(t)){if(l===s){let a={points:n.map(f=>({x:f%(e.cols+1),y:Math.floor(f/(e.cols+1))}))};this.validate(e,a).isValid&&c.add(this.getFingerprint(e,a.points))}return}if(this.canReachEndOptimized(t,o,r,u))for(let a of r[t]){if(a.isBroken||o&1n<<BigInt(a.next))continue;let f=!0;for(let h of r[t])if(h.isHexagon){let y=n.length>=2&&h.next===n[n.length-2],p=h.next===a.next;if(!y&&!p){f=!1;break}}if(f&&(n.push(a.next),this.findPathsOptimized(e,a.next,o|1n<<BigInt(a.next),n,l+(a.isHexagon?1:0),s,r,u,c,i),n.pop(),c.size>=i))return}}}canReachEndOptimized(e,t,o,n){let l=[e],s=t,r=0;for(;r<l.length;){let u=l[r++];if(n.includes(u))return!0;for(let c of o[u])!c.isBroken&&!(s&1n<<BigInt(c.next))&&(s|=1n<<BigInt(c.next),l.push(c.next))}return!1}getFingerprint(e,t){return this.calculateRegions(e,t).map(l=>l.map(r=>e.cells[r.y][r.x]).filter(r=>r.type!==0).map(r=>`${r.type}:${r.color}`).sort().join(",")).sort().filter(l=>l.length>0).join("|")||"empty"}};var K=class{generate(e,t,o={}){let n=o.difficulty??.5,l=new I,s=null,r=-1,u=e*t>30?30:60;for(let c=0;c<u;c++){let i=this.generateOnce(e,t,o);if(!this.checkAllRequestedConstraintsPresent(i,o))continue;let a=l.calculateDifficulty(i);if(a===0)continue;let f=Math.abs(a-n);if((s===null||f<Math.abs(r-n))&&(r=a,s=i),n>.8&&a>.8||f<.05)break}return s||this.generateOnce(e,t,o)}generateOnce(e,t,o){let n=new q(e,t),l={x:0,y:e},s={x:t,y:0};n.nodes[l.y][l.x].type=1,n.nodes[s.y][s.x].type=2;let r=this.generateRandomPath(n,l,s);return this.applyConstraintsBasedOnPath(n,r,o),o.useBrokenEdges&&this.applyBrokenEdges(n,r,o),this.cleanGrid(n),n}generateRandomPath(e,t,o){let n=new Set,l=[],s=r=>{if(n.add(`${r.x},${r.y}`),l.push(r),r.x===o.x&&r.y===o.y)return!0;let u=this.getValidNeighbors(e,r,n);this.shuffleArray(u);for(let c of u)if(s(c))return!0;return l.pop(),!1};return s(t),l}getValidNeighbors(e,t,o){let n=[],l=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let s of l){let r=t.x+s.x,u=t.y+s.y;r>=0&&r<=e.cols&&u>=0&&u<=e.rows&&(o.has(`${r},${u}`)||n.push({x:r,y:u}))}return n}applyBrokenEdges(e,t,o){let n=o.complexity??.5,l=new Set;for(let c=0;c<t.length-1;c++)l.add(this.getEdgeKey(t[c],t[c+1]));let s=[];for(let c=0;c<=e.rows;c++)for(let i=0;i<e.cols;i++){let a={x:i,y:c},f={x:i+1,y:c};l.has(this.getEdgeKey(a,f))||s.push({type:"h",r:c,c:i,p1:a,p2:f})}for(let c=0;c<e.rows;c++)for(let i=0;i<=e.cols;i++){let a={x:i,y:c},f={x:i,y:c+1};l.has(this.getEdgeKey(a,f))||s.push({type:"v",r:c,c:i,p1:a,p2:f})}this.shuffleArray(s);let r=Math.max(1,Math.floor(n*4)),u=0;for(let c of s){if(u>=r)break;let i=Math.random()<.8?1:2;i===2&&this.isAdjacentToMark(e,c)&&(i=1),c.type==="h"?e.hEdges[c.r][c.c].type=i:e.vEdges[c.r][c.c].type=i,u++}for(let c=0;c<=e.rows;c++)for(let i=0;i<=e.cols;i++){let a=[];if(i>0&&a.push({e:e.hEdges[c][i-1],type:"h",r:c,c:i-1}),i<e.cols&&a.push({e:e.hEdges[c][i],type:"h",r:c,c:i}),c>0&&a.push({e:e.vEdges[c-1][i],type:"v",r:c-1,c:i}),c<e.rows&&a.push({e:e.vEdges[c][i],type:"v",r:c,c:i}),a.every(f=>f.e.type===1||f.e.type===2)&&a.every(f=>!this.isAdjacentToMark(e,f)))for(let f of a)f.e.type=2}}cleanGrid(e){let t=[];for(let s=0;s<=e.rows;s++)for(let r=0;r<=e.cols;r++)e.nodes[s][r].type===1&&t.push({x:r,y:s});let o=new Set,n=[...t];for(let s of t)o.add(`${s.x},${s.y}`);for(;n.length>0;){let s=n.shift(),r=[{nx:s.x,ny:s.y-1,edge:e.vEdges[s.y-1]?.[s.x]},{nx:s.x,ny:s.y+1,edge:e.vEdges[s.y]?.[s.x]},{nx:s.x-1,ny:s.y,edge:e.hEdges[s.y]?.[s.x-1]},{nx:s.x+1,ny:s.y,edge:e.hEdges[s.y]?.[s.x]}];for(let u of r)u.edge&&u.edge.type!==2&&(o.has(`${u.nx},${u.ny}`)||(o.add(`${u.nx},${u.ny}`),n.push({x:u.nx,y:u.ny})))}for(let s=0;s<=e.rows;s++)for(let r=0;r<e.cols;r++)(!o.has(`${r},${s}`)||!o.has(`${r+1},${s}`))&&(e.hEdges[s][r].type=2);for(let s=0;s<e.rows;s++)for(let r=0;r<=e.cols;r++)(!o.has(`${r},${s}`)||!o.has(`${r},${s+1}`))&&(e.vEdges[s][r].type=2);let l=this.getExternalCells(e);for(let s of l){let[r,u]=s.split(",").map(Number);e.cells[u][r].type=0}}getExternalCells(e){let t=new Set,o=[];for(let n=0;n<e.cols;n++)e.hEdges[0][n].type===2&&(t.has(`${n},0`)||(t.add(`${n},0`),o.push({x:n,y:0}))),e.hEdges[e.rows][n].type===2&&(t.has(`${n},${e.rows-1}`)||(t.add(`${n},${e.rows-1}`),o.push({x:n,y:e.rows-1})));for(let n=0;n<e.rows;n++)e.vEdges[n][0].type===2&&(t.has(`0,${n}`)||(t.add(`0,${n}`),o.push({x:0,y:n}))),e.vEdges[n][e.cols].type===2&&(t.has(`${e.cols-1},${n}`)||(t.add(`${e.cols-1},${n}`),o.push({x:e.cols-1,y:n})));for(;o.length>0;){let n=o.shift(),l=[{nx:n.x,ny:n.y-1,edge:e.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:e.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:e.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:e.vEdges[n.y][n.x+1]}];for(let s of l)s.nx>=0&&s.nx<e.cols&&s.ny>=0&&s.ny<e.rows&&!t.has(`${s.nx},${s.ny}`)&&s.edge.type===2&&(t.add(`${s.nx},${s.ny}`),o.push({x:s.nx,y:s.ny}))}return t}isAdjacentToMark(e,t){if(t.type==="h"){if(t.r>0&&e.cells[t.r-1][t.c].type!==0||t.r<e.rows&&e.cells[t.r][t.c].type!==0)return!0}else if(t.c>0&&e.cells[t.r][t.c-1].type!==0||t.c<e.cols&&e.cells[t.r][t.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let t=0;t<e.rows;t++)for(let o=0;o<e.cols;o++){if(e.cells[t][o].type===0)continue;if([e.hEdges[t][o],e.hEdges[t+1][o],e.vEdges[t][o],e.vEdges[t][o+1]].every(l=>l.type===1||l.type===2))return!0}return!1}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,t,o){let n=o.complexity??.5,l=o.useHexagons??!0,s=o.useSquares??!0,r=o.useStars??!0,u=o.useTetris??!1,c=o.useEraser??!1,i=0,a=0,f=0,h=0,y=0,p=0,v=Math.floor(e.rows*e.cols*.45);if(l){let E=o.difficulty??.5;for(let b=0;b<t.length-1;b++){let N=this.getValidNeighbors(e,t[b],new Set).length>2,g=n*.4;N&&(g=E<.4?g*1:g*.5),Math.random()<g&&(this.setEdgeHexagon(e,t[b],t[b+1]),i++)}if(i===0&&t.length>=2){let b=Math.floor(Math.random()*(t.length-1));this.setEdgeHexagon(e,t[b],t[b+1])}}if(s||r||u||c){let E=this.calculateRegions(e,t),b=[1,2,3,4],w=Array.from({length:E.length},(g,C)=>C);this.shuffleArray(w);let N=new Set;for(let g=0;g<w.length;g++){let C=w[g],$=E[C],O=(o.difficulty??.5)>.7?.4:.2,m=g>=w.length-2;if((!(s&&a===0||r&&f===0||u&&h===0||c&&y===0)||!m)&&Math.random()>O+n*.5)continue;let x=[...$];this.shuffleArray(x);let V=b[Math.floor(Math.random()*b.length)];if(s&&!r&&m&&N.size===1){let S=b.filter(M=>!N.has(M));S.length>0&&(V=S[Math.floor(Math.random()*S.length)])}let z=s&&Math.random()<.5+n*.3;if(s&&a===0&&m&&(z=!0),s&&!r&&m&&N.size<2&&a>0&&(z=!0),z&&x.length>0){let S=Math.min(x.length,4),M=Math.floor(Math.random()*S)+1;for(let P=0;P<M&&x.length!==0;P++){let k=x.pop();e.cells[k.y][k.x].type=1,e.cells[k.y][k.x].color=V,a++,N.add(V)}}if(u&&p<v){let S=Math.random()<.1+n*.4;h===0&&m&&(S=!0);let M=h===0&&m?6:4;if(S&&x.length>0&&$.length<=M*4&&p+$.length<=v){let P=this.generateTiling($,M,o);if(P){for(let k of P){if(x.length===0)break;let R=x.pop();e.cells[R.y][R.x].type=k.isRotated?4:3,e.cells[R.y][R.x].shape=k.isRotated?k.displayShape:k.shape,e.cells[R.y][R.x].color=0,h++}p+=$.length}}}if(c&&y<1){let S=.05+n*.2,M=Math.random()<S;if(m&&(M=!0),M&&x.length>=1){let P=[];r&&P.push("star"),s&&P.push("square");let k=[];l&&(k=this.getRegionBoundaryEdges(e,$,t),k.length>0&&P.push("hexagon")),u&&P.push("tetris");let R=P.length>0?P[Math.floor(Math.random()*P.length)]:null;x.length>=2&&(!R||Math.random()<.01)&&(R="eraser");let G=!1;if(R==="hexagon"){let d=k[Math.floor(Math.random()*k.length)];d.type==="h"?e.hEdges[d.r][d.c].type=3:e.vEdges[d.r][d.c].type=3,i++,G=!0}else if(R==="square"&&x.length>=2){let d=x.pop();e.cells[d.y][d.x].type=1;let B=$.find(H=>e.cells[H.y][H.x].type===1),T=B?e.cells[B.y][B.x].color:void 0;e.cells[d.y][d.x].color=b.find(H=>H!==T)||3,a++,G=!0}else if(R==="star"&&x.length>=2){let d=x.pop();e.cells[d.y][d.x].type=2,e.cells[d.y][d.x].color=b[Math.floor(Math.random()*b.length)],f++,G=!0}else if(R==="tetris"&&x.length>=2){let d=this.generateTiling($,4,o),B=[];if(d&&d.length>0){let T=0;for(let H of d){let X=this.getShapeArea(H.shape);if(T+X<$.length)B.push(H),T+=X;else break}}if(B.length===0&&$.length>1&&(B=[{shape:[[1]],displayShape:[[1]],isRotated:!1}]),B.length>0){for(let T of B){if(x.length<2)break;let H=x.pop();e.cells[H.y][H.x].type=T.isRotated?4:3,e.cells[H.y][H.x].shape=T.isRotated?T.displayShape:T.shape,e.cells[H.y][H.x].color=0,h++}G=!0}}else if(R==="eraser"&&x.length>=2){let d=x.pop();e.cells[d.y][d.x].type=5,e.cells[d.y][d.x].color=0,y++,G=!0}if(!G&&x.length>=2){let d=x.pop();e.cells[d.y][d.x].type=5,e.cells[d.y][d.x].color=0,y++,G=!0}if(G){let d=x.pop();e.cells[d.y][d.x].type=5;let B=0;r&&Math.random()<.4&&(B=b[Math.floor(Math.random()*b.length)]),e.cells[d.y][d.x].color=B,y++}}}if(r)for(let S of b){if(x.length<1)break;if(Math.random()>.2+n*.3)continue;let M=$.filter(P=>e.cells[P.y][P.x].color===S).length;if(M===1){let P=x.pop();e.cells[P.y][P.x].type=2,e.cells[P.y][P.x].color=S,f++}else if(M===0&&x.length>=2)for(let P=0;P<2;P++){let k=x.pop();e.cells[k.y][k.x].type=2,e.cells[k.y][k.x].color=S,f++}}}if(s&&!r&&N.size<2){for(let g of E)if(g.every(C=>e.cells[C.y][C.x].type===0)){let C=b.find(O=>!N.has(O))||2,$=g[Math.floor(Math.random()*g.length)];e.cells[$.y][$.x].type=1,e.cells[$.y][$.x].color=C,N.add(C),a++;break}}}}calculateRegions(e,t){let o=[],n=new Set,l=new Set;for(let s=0;s<t.length-1;s++)l.add(this.getEdgeKey(t[s],t[s+1]));for(let s=0;s<e.rows;s++)for(let r=0;r<e.cols;r++){if(n.has(`${r},${s}`))continue;let u=[],c=[{x:r,y:s}];for(n.add(`${r},${s}`);c.length>0;){let i=c.shift();u.push(i);let a=[{dx:0,dy:-1,p1:{x:i.x,y:i.y},p2:{x:i.x+1,y:i.y}},{dx:0,dy:1,p1:{x:i.x,y:i.y+1},p2:{x:i.x+1,y:i.y+1}},{dx:-1,dy:0,p1:{x:i.x,y:i.y},p2:{x:i.x,y:i.y+1}},{dx:1,dy:0,p1:{x:i.x+1,y:i.y},p2:{x:i.x+1,y:i.y+1}}];for(let f of a){let h=i.x+f.dx,y=i.y+f.dy;h>=0&&h<e.cols&&y>=0&&y<e.rows&&!n.has(`${h},${y}`)&&!l.has(this.getEdgeKey(f.p1,f.p2))&&!this.isAbsentEdge(e,f.p1,f.p2)&&(n.add(`${h},${y}`),c.push({x:h,y}))}}o.push(u)}return o}isAbsentEdge(e,t,o){if(t.x===o.x){let n=Math.min(t.y,o.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,o.x);return e.hEdges[t.y][n].type===2}}getRegionBoundaryEdges(e,t,o){let n=new Set;for(let r=0;r<o.length-1;r++)n.add(this.getEdgeKey(o[r],o[r+1]));let l=[];for(let r of t){let u=[{type:"h",r:r.y,c:r.x},{type:"h",r:r.y+1,c:r.x},{type:"v",r:r.y,c:r.x},{type:"v",r:r.y,c:r.x+1}];for(let c of u){let i=c.type==="h"?{x:c.c,y:c.r}:{x:c.c,y:c.r},a=c.type==="h"?{x:c.c+1,y:c.r}:{x:c.c,y:c.r+1},f=this.getEdgeKey(i,a);!n.has(f)&&!this.isAbsentEdge(e,i,a)&&l.push(c)}}let s=new Map;for(let r of l)s.set(`${r.type},${r.r},${r.c}`,r);return Array.from(s.values())}setEdgeHexagon(e,t,o){t.x===o.x?e.vEdges[Math.min(t.y,o.y)][t.x].type=3:e.hEdges[t.y][Math.min(t.x,o.x)].type=3}checkAllRequestedConstraintsPresent(e,t){let o=t.useHexagons??!0,n=t.useSquares??!0,l=t.useStars??!0,s=t.useTetris??!1,r=t.useEraser??!1;if(t.useBrokenEdges??!1){let c=!1;for(let i=0;i<=e.rows;i++)for(let a=0;a<e.cols;a++)if(e.hEdges[i][a].type===1||e.hEdges[i][a].type===2){c=!0;break}if(!c){for(let i=0;i<e.rows;i++)for(let a=0;a<=e.cols;a++)if(e.vEdges[i][a].type===1||e.vEdges[i][a].type===2){c=!0;break}}if(!c)return!1}if(o){let c=!1;for(let i=0;i<=e.rows;i++)for(let a=0;a<e.cols;a++)if(e.hEdges[i][a].type===3){c=!0;break}if(!c){for(let i=0;i<e.rows;i++)for(let a=0;a<=e.cols;a++)if(e.vEdges[i][a].type===3){c=!0;break}}if(!c)return!1}if(n||l||s||r){let c=!1,i=!1,a=!1,f=!1,h=new Set;for(let y=0;y<e.rows;y++)for(let p=0;p<e.cols;p++){let v=e.cells[y][p].type;v===1&&(c=!0,h.add(e.cells[y][p].color)),v===2&&(i=!0),(v===3||v===4)&&(a=!0),v===5&&(f=!0)}if(n&&!c||l&&!i||s&&!a||r&&!f||n&&c&&!i&&h.size<2)return!1}return!this.hasIsolatedMark(e)}generateTiling(e,t,o){let n=Math.min(...e.map(a=>a.x)),l=Math.min(...e.map(a=>a.y)),s=Math.max(...e.map(a=>a.x)),r=Math.max(...e.map(a=>a.y)),u=s-n+1,c=r-l+1,i=Array.from({length:c},()=>Array(u).fill(!1));for(let a of e)i[a.y-l][a.x-n]=!0;return this.tilingDfs(i,[],t,o)}tilingDfs(e,t,o,n){let l=-1,s=-1;for(let c=0;c<e.length;c++){for(let i=0;i<e[0].length;i++)if(e[c][i]){l=c,s=i;break}if(l!==-1)break}if(l===-1)return t;if(t.length>=o)return null;let r=n.difficulty??.5,u=[...this.TETRIS_SHAPES];this.shuffleArray(u),r>.6&&u.sort((c,i)=>this.getShapeArea(i)-this.getShapeArea(c));for(let c of u){let i=this.isRotationallyInvariant(c),a=i?[c]:this.getAllRotations(c);this.shuffleArray(a);for(let f of a){let h=[];for(let y=0;y<f.length;y++)for(let p=0;p<f[0].length;p++)f[y][p]&&h.push({r:y,c:p});for(let y of h){let p=l-y.r,v=s-y.c;if(this.canPlace(e,f,p,v)){this.placePiece(e,f,p,v,!1);let E=this.tilingDfs(e,[...t,{shape:f,displayShape:c,isRotated:!i&&Math.random()<.3+r*.6}],o,n);if(E)return E;this.placePiece(e,f,p,v,!0)}}}}return null}getShapeArea(e){let t=0;for(let o of e)for(let n of o)n&&t++;return t}isRotationallyInvariant(e){let t=this.getShapeArea(e);return t===1||t===4&&e.length===2&&e[0].length===2}getAllRotations(e){let t=[],o=new Set,n=e;for(let l=0;l<4;l++){let s=JSON.stringify(n);o.has(s)||(t.push(n),o.add(s)),n=this.rotate90(n)}return t}rotate90(e){let t=e.length,o=e[0].length,n=Array.from({length:o},()=>Array(t).fill(0));for(let l=0;l<t;l++)for(let s=0;s<o;s++)n[s][t-1-l]=e[l][s];return n}canPlace(e,t,o,n){for(let l=0;l<t.length;l++)for(let s=0;s<t[0].length;s++)if(t[l][s]){let r=o+l,u=n+s;if(r<0||r>=e.length||u<0||u>=e[0].length||!e[r][u])return!1}return!0}placePiece(e,t,o,n,l){for(let s=0;s<t.length;s++)for(let r=0;r<t[0].length;r++)t[s][r]&&(e[o+s][n+r]=l)}shuffleArray(e){for(let t=e.length-1;t>0;t--){let o=Math.floor(Math.random()*(t+1));[e[t],e[o]]=[e[o],e[t]]}}};var Y=class{generator;validator;constructor(){this.generator=new K,this.validator=new I}createPuzzle(e,t,o={}){return this.generator.generate(e,t,o).export()}validateSolution(e,t){let o=q.fromData(e);return this.validator.validate(o,t)}calculateDifficulty(e){let t=q.fromData(e);return this.validator.calculateDifficulty(t)}};export{F as CellType,J as Color,U as Direction,j as EdgeType,q as Grid,W as NodeType,K as PuzzleGenerator,I as PuzzleValidator,Y as WitnessCore};
//# sourceMappingURL=MiniWitness.min.js.map
