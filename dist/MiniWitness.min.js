var F=(n=>(n[n.Up=0]="Up",n[n.Right=1]="Right",n[n.Down=2]="Down",n[n.Left=3]="Left",n))(F||{}),O=(s=>(s[s.None=0]="None",s[s.Square=1]="Square",s[s.Star=2]="Star",s[s.Tetris=3]="Tetris",s[s.TetrisRotated=4]="TetrisRotated",s[s.Eraser=5]="Eraser",s))(O||{}),q=(n=>(n[n.Normal=0]="Normal",n[n.Broken=1]="Broken",n[n.Absent=2]="Absent",n[n.Hexagon=3]="Hexagon",n))(q||{}),I=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o))(I||{}),K=(a=>(a[a.None=0]="None",a[a.Black=1]="Black",a[a.White=2]="White",a[a.Red=3]="Red",a[a.Blue=4]="Blue",a))(K||{});var B=class T{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:0}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(e){let t=new T(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t}};var V=class{validate(e,t){let o=t.points;if(o.length<2)return{isValid:!1,errorReason:"Path too short"};let n=o[0],a=o[o.length-1];if(e.nodes[n.y][n.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[a.y][a.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let s=new Set;s.add(`${n.x},${n.y}`);for(let c=0;c<o.length-1;c++){let i=o[c],r=o[c+1];if(Math.abs(i.x-r.x)+Math.abs(i.y-r.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let h=`${r.x},${r.y}`;if(s.has(h))return{isValid:!1,errorReason:"Self-intersecting path"};if(s.add(h),this.isBrokenEdge(e,i,r))return{isValid:!1,errorReason:"Passed through broken edge"}}let l=this.calculateRegions(e,o),u=this.getMissedHexagons(e,o);return this.validateWithErasers(e,l,u)}isBrokenEdge(e,t,o){let n;if(t.x===o.x){let a=Math.min(t.y,o.y);n=e.vEdges[a][t.x].type}else{let a=Math.min(t.x,o.x);n=e.hEdges[t.y][a].type}return n===1||n===2}isAbsentEdge(e,t,o){if(t.x===o.x){let n=Math.min(t.y,o.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,o.x);return e.hEdges[t.y][n].type===2}}getMissedHexagons(e,t){let o=new Set;for(let a=0;a<t.length-1;a++)o.add(this.getEdgeKey(t[a],t[a+1]));let n=[];for(let a=0;a<=e.rows;a++)for(let s=0;s<e.cols;s++)if(e.hEdges[a][s].type===3){let l=this.getEdgeKey({x:s,y:a},{x:s+1,y:a});o.has(l)||n.push({type:"h",r:a,c:s})}for(let a=0;a<e.rows;a++)for(let s=0;s<=e.cols;s++)if(e.vEdges[a][s].type===3){let l=this.getEdgeKey({x:s,y:a},{x:s,y:a+1});o.has(l)||n.push({type:"v",r:a,c:s})}return n}validateWithErasers(e,t,o){let n=[];for(let s=0;s<t.length;s++){let l=t[s],u=l.filter(f=>e.cells[f.y][f.x].type===5),c=l.filter(f=>e.cells[f.y][f.x].type!==0&&e.cells[f.y][f.x].type!==5),i=[];for(let f=0;f<o.length;f++)this.isHexagonAdjacentToRegion(e,o[f],l)&&i.push(f);let r=this.getPossibleErasures(e,l,u,c,i);if(r.length===0)return{isValid:!1,errorReason:`Constraints failed in region ${s}`};r.sort((f,h)=>{let y=f.invalidatedCells.length+f.invalidatedHexagons.length,x=h.invalidatedCells.length+h.invalidatedHexagons.length;return y-x}),n.push(r)}let a=this.findGlobalAssignment(n,o.length);return a?{isValid:!0,invalidatedCells:a.invalidatedCells,invalidatedEdges:a.invalidatedHexIndices.map(s=>o[s])}:{isValid:!1,errorReason:"Could not satisfy all constraints with available erasers"}}isHexagonAdjacentToRegion(e,t,o){let n=new Set(o.map(a=>`${a.x},${a.y}`));if(t.type==="h"){if(t.r>0&&n.has(`${t.c},${t.r-1}`)||t.r<e.rows&&n.has(`${t.c},${t.r}`))return!0}else if(t.c>0&&n.has(`${t.c-1},${t.r}`)||t.c<e.cols&&n.has(`${t.c},${t.r}`))return!0;return!1}getPossibleErasures(e,t,o,n,a){let s=[],l=o.length;if(l===0)return this.checkRegionValid(e,t,[],[])&&s.push({invalidatedCells:[],invalidatedHexagons:[],isValid:!0}),s;let u=[...n.map(i=>({type:"cell",pos:i})),...a.map(i=>({type:"hex",index:i}))],c=this.checkRegionValid(e,t,[],[])&&a.length===0;for(let i=0;i<=l;i++){let r=this.getNCombinations(o,i);for(let f of r){let h=new Set(f.map(x=>`${x.x},${x.y}`)),y=o.filter(x=>!h.has(`${x.x},${x.y}`));for(let x=0;x<=u.length;x++){if(y.length!==i+x)continue;let m=this.getNCombinations(u,x);for(let g of m){let d=g.filter(v=>v.type==="cell").map(v=>v.pos),w=g.filter(v=>v.type==="hex").map(v=>v.index);if(this.checkRegionValid(e,t,[...d,...f],y)){let v=!0;if(c)x>0&&(v=!1);else for(let P=0;P<g.length;P++){let M=[...g.slice(0,P),...g.slice(P+1)].filter(H=>H.type==="cell").map(H=>H.pos);if(this.checkRegionValid(e,t,M,y)){v=!1;break}}v&&s.push({invalidatedCells:[...d,...f],invalidatedHexagons:w,isValid:!0})}}}}}return s}getNCombinations(e,t){let o=[],n=(a,s)=>{if(s.length===t){o.push([...s]);return}for(let l=a;l<e.length;l++)s.push(e[l]),n(l+1,s),s.pop()};return n(0,[]),o}checkRegionValid(e,t,o,n){let a=new Set(o.map(r=>`${r.x},${r.y}`)),s=new Set(n.map(r=>`${r.x},${r.y}`)),l=new Map,u=new Set,c=new Set,i=[];for(let r of t){if(a.has(`${r.x},${r.y}`))continue;let f=e.cells[r.y][r.x];if(f.type===0)continue;let h=f.type===5&&s.has(`${r.x},${r.y}`),y=f.type!==5;if(!h&&!y)continue;let x=f.color;x!==0&&l.set(x,(l.get(x)||0)+1),f.type===1?c.add(x):f.type===2?u.add(x):(f.type===3||f.type===4)&&f.shape&&i.push({shape:f.shape,rotatable:f.type===4})}if(c.size>1)return!1;for(let r of u)if(l.get(r)!==2)return!1;return!(i.length>0&&!this.checkTetrisConstraint(t,i))}findGlobalAssignment(e,t){let o=e.length,n=new Array(t).fill(0),a=[],s=[],l=u=>{if(u===o)return n.every(c=>c===1);for(let c of e[u]){let i=!0;for(let r of c.invalidatedHexagons)if(n[r]>0){i=!1;break}if(i){for(let r of c.invalidatedHexagons)n[r]++,s.push(r);if(a.push(...c.invalidatedCells),l(u+1))return!0;for(let r of c.invalidatedHexagons)n[r]--,s.pop();for(let r=0;r<c.invalidatedCells.length;r++)a.pop()}}return!1};return l(0)?{invalidatedCells:a,invalidatedHexIndices:s}:null}checkTetrisConstraint(e,t){if(t.reduce((r,f)=>r+this.getShapeArea(f.shape),0)!==e.length)return!1;let n=Math.min(...e.map(r=>r.x)),a=Math.min(...e.map(r=>r.y)),s=Math.max(...e.map(r=>r.x)),l=Math.max(...e.map(r=>r.y)),u=s-n+1,c=l-a+1,i=Array.from({length:c},()=>Array(u).fill(!1));for(let r of e)i[r.y-a][r.x-n]=!0;return this.canTile(i,t)}getShapeArea(e){let t=0;for(let o of e)for(let n of o)n&&t++;return t}canTile(e,t){let o=-1,n=-1;for(let a=0;a<e.length;a++){for(let s=0;s<e[0].length;s++)if(e[a][s]){o=a,n=s;break}if(o!==-1)break}if(o===-1)return t.length===0;if(t.length===0)return!1;for(let a=0;a<t.length;a++){let s=t[a],l=[...t.slice(0,a),...t.slice(a+1)],u=s.rotatable?this.getAllRotations(s.shape):[s.shape];for(let c of u){let i=[];for(let r=0;r<c.length;r++)for(let f=0;f<c[0].length;f++)c[r][f]&&i.push({r,c:f});for(let r of i){let f=o-r.r,h=n-r.c;if(this.canPlace(e,c,f,h)){if(this.placePiece(e,c,f,h,!1),this.canTile(e,l))return!0;this.placePiece(e,c,f,h,!0)}}}}return!1}canPlace(e,t,o,n){for(let a=0;a<t.length;a++)for(let s=0;s<t[0].length;s++)if(t[a][s]){let l=o+a,u=n+s;if(l<0||l>=e.length||u<0||u>=e[0].length||!e[l][u])return!1}return!0}placePiece(e,t,o,n,a){for(let s=0;s<t.length;s++)for(let l=0;l<t[0].length;l++)t[s][l]&&(e[o+s][n+l]=a)}getAllRotations(e){let t=[],o=new Set,n=e;for(let a=0;a<4;a++){let s=JSON.stringify(n);o.has(s)||(t.push(n),o.add(s)),n=this.rotate90(n)}return t}rotate90(e){let t=e.length,o=e[0].length,n=Array.from({length:o},()=>Array(t).fill(0));for(let a=0;a<t;a++)for(let s=0;s<o;s++)n[s][t-1-a]=e[a][s];return n}calculateRegions(e,t){let o=[],n=new Set,a=new Set;for(let l=0;l<t.length-1;l++)a.add(this.getEdgeKey(t[l],t[l+1]));let s=this.getExternalCells(e);for(let l=0;l<e.rows;l++)for(let u=0;u<e.cols;u++){if(n.has(`${u},${l}`)||s.has(`${u},${l}`))continue;let c=[],i=[{x:u,y:l}];for(n.add(`${u},${l}`);i.length>0;){let r=i.shift();c.push(r);let f=[{nx:r.x,ny:r.y-1,p1:{x:r.x,y:r.y},p2:{x:r.x+1,y:r.y}},{nx:r.x,ny:r.y+1,p1:{x:r.x,y:r.y+1},p2:{x:r.x+1,y:r.y+1}},{nx:r.x-1,ny:r.y,p1:{x:r.x,y:r.y},p2:{x:r.x,y:r.y+1}},{nx:r.x+1,ny:r.y,p1:{x:r.x+1,y:r.y},p2:{x:r.x+1,y:r.y+1}}];for(let h of f)if(h.nx>=0&&h.nx<e.cols&&h.ny>=0&&h.ny<e.rows){let y=`${h.nx},${h.ny}`;if(!n.has(y)&&!s.has(y)){let x=this.getEdgeKey(h.p1,h.p2);!a.has(x)&&!this.isAbsentEdge(e,h.p1,h.p2)&&(n.add(y),i.push({x:h.nx,y:h.ny}))}}}o.push(c)}return o}getExternalCells(e){let t=new Set,o=[];for(let n=0;n<e.cols;n++)e.hEdges[0][n].type===2&&(t.has(`${n},0`)||(t.add(`${n},0`),o.push({x:n,y:0}))),e.hEdges[e.rows][n].type===2&&(t.has(`${n},${e.rows-1}`)||(t.add(`${n},${e.rows-1}`),o.push({x:n,y:e.rows-1})));for(let n=0;n<e.rows;n++)e.vEdges[n][0].type===2&&(t.has(`0,${n}`)||(t.add(`0,${n}`),o.push({x:0,y:n}))),e.vEdges[n][e.cols].type===2&&(t.has(`${e.cols-1},${n}`)||(t.add(`${e.cols-1},${n}`),o.push({x:e.cols-1,y:n})));for(;o.length>0;){let n=o.shift(),a=[{nx:n.x,ny:n.y-1,edge:e.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:e.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:e.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:e.vEdges[n.y][n.x+1]}];for(let s of a)s.nx>=0&&s.nx<e.cols&&s.ny>=0&&s.ny<e.rows&&!t.has(`${s.nx},${s.ny}`)&&s.edge.type===2&&(t.add(`${s.nx},${s.ny}`),o.push({x:s.nx,y:s.ny}))}return t}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e){let t=e.rows,o=e.cols,n=o+1,a=(t+1)*n,s=Array.from({length:a},()=>[]),l=[],u=[],c=new Set;for(let b=0;b<=t;b++)for(let k=0;k<=o;k++){let p=b*n+k;if(e.nodes[b][k].type===1&&l.push(p),e.nodes[b][k].type===2&&u.push(p),k<o){let N=p+1,R=e.hEdges[b][k].type,E=R===3,$=R===1||R===2;s[p].push({next:N,isHexagon:E,isBroken:$}),s[N].push({next:p,isHexagon:E,isBroken:$}),E&&c.add(this.getEdgeKey({x:k,y:b},{x:k+1,y:b}))}if(b<t){let N=p+n,R=e.vEdges[b][k].type,E=R===3,$=R===1||R===2;s[p].push({next:N,isHexagon:E,isBroken:$}),s[N].push({next:p,isHexagon:E,isBroken:$}),E&&c.add(this.getEdgeKey({x:k,y:b},{x:k,y:b+1}))}}let i={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},r=c.size,f=new Set;for(let b of l)this.exploreSearchSpace(e,b,1n<<BigInt(b),[b],0,r,s,u,f,i,500);if(i.solutions===0)return 0;let h=c.size,y=new Set;c.size>0&&y.add(999);let x=0,m=0;for(let b=0;b<t;b++)for(let k=0;k<o;k++){let p=e.cells[b][k];p.type!==0&&(h++,y.add(p.type),p.type===3?x++:p.type===4&&(x++,m++))}let g=i.branchingPoints/(i.totalNodesVisited||1),d=Math.log10(i.totalNodesVisited+1),w=(g*10+d*1)/(Math.log2(i.solutions+1)+1);x>0&&(w+=m*.5,w+=(x-m)*.2);let v=t*o,P=h/v,C=P<.3?Math.pow(P/.3,3):1,M=y.size<=1?.4:1;w*=C*M;let H=Math.sqrt(v)/4;return w*=H,Math.max(.01,Math.min(1,w/4))}exploreSearchSpace(e,t,o,n,a,s,l,u,c,i,r){if(i.totalNodesVisited++,i.maxDepth=Math.max(i.maxDepth,n.length),i.totalNodesVisited>r)return;if(u.includes(t)){if(a===s){let h={points:n.map(y=>({x:y%(e.cols+1),y:Math.floor(y/(e.cols+1))}))};if(this.validate(e,h).isValid){let y=this.getFingerprint(e,h.points);c.has(y)||(c.add(y),i.solutions++)}}return}if(!this.canReachEndOptimized(t,o,l,u)){i.backtracks++;return}let f=[];for(let h of l[t]){if(h.isBroken||o&1n<<BigInt(h.next))continue;let y=!0;for(let x of l[t])if(x.isHexagon){let m=n.length>=2&&x.next===n[n.length-2],g=x.next===h.next;if(!m&&!g){y=!1;break}}y&&f.push(h)}f.length>1&&i.branchingPoints++;for(let h of f)if(n.push(h.next),this.exploreSearchSpace(e,h.next,o|1n<<BigInt(h.next),n,a+(h.isHexagon?1:0),s,l,u,c,i,r),n.pop(),i.totalNodesVisited>r)return}countSolutions(e,t=100){let o=e.rows,n=e.cols,a=n+1,s=(o+1)*a,l=Array.from({length:s},()=>[]),u=[],c=[],i=new Set;for(let h=0;h<=o;h++)for(let y=0;y<=n;y++){let x=h*a+y;if(e.nodes[h][y].type===1&&u.push(x),e.nodes[h][y].type===2&&c.push(x),y<n){let m=x+1,g=e.hEdges[h][y].type,d=g===3,w=g===1||g===2;l[x].push({next:m,isHexagon:d,isBroken:w}),l[m].push({next:x,isHexagon:d,isBroken:w}),d&&i.add(this.getEdgeKey({x:y,y:h},{x:y+1,y:h}))}if(h<o){let m=x+a,g=e.vEdges[h][y].type,d=g===3,w=g===1||g===2;l[x].push({next:m,isHexagon:d,isBroken:w}),l[m].push({next:x,isHexagon:d,isBroken:w}),d&&i.add(this.getEdgeKey({x:y,y:h},{x:y,y:h+1}))}}let r=new Set,f=i.size;for(let h of u)this.findPathsOptimized(e,h,1n<<BigInt(h),[h],0,f,l,c,r,t);return r.size}findPathsOptimized(e,t,o,n,a,s,l,u,c,i){if(!(c.size>=i)){if(u.includes(t)){if(a===s){let r={points:n.map(f=>({x:f%(e.cols+1),y:Math.floor(f/(e.cols+1))}))};this.validate(e,r).isValid&&c.add(this.getFingerprint(e,r.points))}return}if(this.canReachEndOptimized(t,o,l,u))for(let r of l[t]){if(r.isBroken||o&1n<<BigInt(r.next))continue;let f=!0;for(let h of l[t])if(h.isHexagon){let y=n.length>=2&&h.next===n[n.length-2],x=h.next===r.next;if(!y&&!x){f=!1;break}}if(f&&(n.push(r.next),this.findPathsOptimized(e,r.next,o|1n<<BigInt(r.next),n,a+(r.isHexagon?1:0),s,l,u,c,i),n.pop(),c.size>=i))return}}}canReachEndOptimized(e,t,o,n){let a=[e],s=t,l=0;for(;l<a.length;){let u=a[l++];if(n.includes(u))return!0;for(let c of o[u])!c.isBroken&&!(s&1n<<BigInt(c.next))&&(s|=1n<<BigInt(c.next),a.push(c.next))}return!1}getFingerprint(e,t){return this.calculateRegions(e,t).map(a=>a.map(l=>e.cells[l.y][l.x]).filter(l=>l.type!==0).map(l=>`${l.type}:${l.color}`).sort().join(",")).sort().filter(a=>a.length>0).join("|")||"empty"}};var G=class{generate(e,t,o={}){let n=o.difficulty??.5,a=new V,s=null,l=-1,u=e*t>30?30:60;for(let c=0;c<u;c++){let i=this.generateOnce(e,t,o);if(!this.checkAllRequestedConstraintsPresent(i,o))continue;let r=a.calculateDifficulty(i);if(r===0)continue;let f=Math.abs(r-n);if((s===null||f<Math.abs(l-n))&&(l=r,s=i),n>.8&&r>.8||f<.05)break}return s||this.generateOnce(e,t,o)}generateOnce(e,t,o){let n=new B(e,t),a={x:0,y:e},s={x:t,y:0};n.nodes[a.y][a.x].type=1,n.nodes[s.y][s.x].type=2;let l=this.generateRandomPath(n,a,s);return this.applyConstraintsBasedOnPath(n,l,o),o.useBrokenEdges&&this.applyBrokenEdges(n,l,o),this.cleanGrid(n),n}generateRandomPath(e,t,o){let n=new Set,a=[],s=l=>{if(n.add(`${l.x},${l.y}`),a.push(l),l.x===o.x&&l.y===o.y)return!0;let u=this.getValidNeighbors(e,l,n);this.shuffleArray(u);for(let c of u)if(s(c))return!0;return a.pop(),!1};return s(t),a}getValidNeighbors(e,t,o){let n=[],a=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let s of a){let l=t.x+s.x,u=t.y+s.y;l>=0&&l<=e.cols&&u>=0&&u<=e.rows&&(o.has(`${l},${u}`)||n.push({x:l,y:u}))}return n}applyBrokenEdges(e,t,o){let n=o.complexity??.5,a=new Set;for(let c=0;c<t.length-1;c++)a.add(this.getEdgeKey(t[c],t[c+1]));let s=[];for(let c=0;c<=e.rows;c++)for(let i=0;i<e.cols;i++){let r={x:i,y:c},f={x:i+1,y:c};a.has(this.getEdgeKey(r,f))||s.push({type:"h",r:c,c:i,p1:r,p2:f})}for(let c=0;c<e.rows;c++)for(let i=0;i<=e.cols;i++){let r={x:i,y:c},f={x:i,y:c+1};a.has(this.getEdgeKey(r,f))||s.push({type:"v",r:c,c:i,p1:r,p2:f})}this.shuffleArray(s);let l=Math.max(1,Math.floor(n*4)),u=0;for(let c of s){if(u>=l)break;let i=Math.random()<.8?1:2;i===2&&this.isAdjacentToMark(e,c)&&(i=1),c.type==="h"?e.hEdges[c.r][c.c].type=i:e.vEdges[c.r][c.c].type=i,u++}for(let c=0;c<=e.rows;c++)for(let i=0;i<=e.cols;i++){let r=[];if(i>0&&r.push({e:e.hEdges[c][i-1],type:"h",r:c,c:i-1}),i<e.cols&&r.push({e:e.hEdges[c][i],type:"h",r:c,c:i}),c>0&&r.push({e:e.vEdges[c-1][i],type:"v",r:c-1,c:i}),c<e.rows&&r.push({e:e.vEdges[c][i],type:"v",r:c,c:i}),r.every(f=>f.e.type===1||f.e.type===2)&&r.every(f=>!this.isAdjacentToMark(e,f)))for(let f of r)f.e.type=2}}cleanGrid(e){let t=[];for(let s=0;s<=e.rows;s++)for(let l=0;l<=e.cols;l++)e.nodes[s][l].type===1&&t.push({x:l,y:s});let o=new Set,n=[...t];for(let s of t)o.add(`${s.x},${s.y}`);for(;n.length>0;){let s=n.shift(),l=[{nx:s.x,ny:s.y-1,edge:e.vEdges[s.y-1]?.[s.x]},{nx:s.x,ny:s.y+1,edge:e.vEdges[s.y]?.[s.x]},{nx:s.x-1,ny:s.y,edge:e.hEdges[s.y]?.[s.x-1]},{nx:s.x+1,ny:s.y,edge:e.hEdges[s.y]?.[s.x]}];for(let u of l)u.edge&&u.edge.type!==2&&(o.has(`${u.nx},${u.ny}`)||(o.add(`${u.nx},${u.ny}`),n.push({x:u.nx,y:u.ny})))}for(let s=0;s<=e.rows;s++)for(let l=0;l<e.cols;l++)(!o.has(`${l},${s}`)||!o.has(`${l+1},${s}`))&&(e.hEdges[s][l].type=2);for(let s=0;s<e.rows;s++)for(let l=0;l<=e.cols;l++)(!o.has(`${l},${s}`)||!o.has(`${l},${s+1}`))&&(e.vEdges[s][l].type=2);let a=this.getExternalCells(e);for(let s of a){let[l,u]=s.split(",").map(Number);e.cells[u][l].type=0}}getExternalCells(e){let t=new Set,o=[];for(let n=0;n<e.cols;n++)e.hEdges[0][n].type===2&&(t.has(`${n},0`)||(t.add(`${n},0`),o.push({x:n,y:0}))),e.hEdges[e.rows][n].type===2&&(t.has(`${n},${e.rows-1}`)||(t.add(`${n},${e.rows-1}`),o.push({x:n,y:e.rows-1})));for(let n=0;n<e.rows;n++)e.vEdges[n][0].type===2&&(t.has(`0,${n}`)||(t.add(`0,${n}`),o.push({x:0,y:n}))),e.vEdges[n][e.cols].type===2&&(t.has(`${e.cols-1},${n}`)||(t.add(`${e.cols-1},${n}`),o.push({x:e.cols-1,y:n})));for(;o.length>0;){let n=o.shift(),a=[{nx:n.x,ny:n.y-1,edge:e.hEdges[n.y][n.x]},{nx:n.x,ny:n.y+1,edge:e.hEdges[n.y+1][n.x]},{nx:n.x-1,ny:n.y,edge:e.vEdges[n.y][n.x]},{nx:n.x+1,ny:n.y,edge:e.vEdges[n.y][n.x+1]}];for(let s of a)s.nx>=0&&s.nx<e.cols&&s.ny>=0&&s.ny<e.rows&&!t.has(`${s.nx},${s.ny}`)&&s.edge.type===2&&(t.add(`${s.nx},${s.ny}`),o.push({x:s.nx,y:s.ny}))}return t}isAdjacentToMark(e,t){if(t.type==="h"){if(t.r>0&&e.cells[t.r-1][t.c].type!==0||t.r<e.rows&&e.cells[t.r][t.c].type!==0)return!0}else if(t.c>0&&e.cells[t.r][t.c-1].type!==0||t.c<e.cols&&e.cells[t.r][t.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let t=0;t<e.rows;t++)for(let o=0;o<e.cols;o++){if(e.cells[t][o].type===0)continue;if([e.hEdges[t][o],e.hEdges[t+1][o],e.vEdges[t][o],e.vEdges[t][o+1]].every(a=>a.type===1||a.type===2))return!0}return!1}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1,1,1]],[[1,1,1,1,1]],[[1,1],[1,1]],[[1,1],[1,0]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[0,1],[1,0]],[[1,1,1],[0,1,0]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,1]],[[0,1,1],[1,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,t,o){let n=o.complexity??.5,a=o.useHexagons??!0,s=o.useSquares??!0,l=o.useStars??!0,u=o.useTetris??!1,c=o.useEraser??!1,i=0,r=0,f=0,h=0,y=0,x=0,m=Math.floor(e.rows*e.cols*.45);if(a){let g=o.difficulty??.5;for(let d=0;d<t.length-1;d++){let v=this.getValidNeighbors(e,t[d],new Set).length>2,P=n*.4;v&&(P=g<.4?P*1:P*.5),Math.random()<P&&(this.setEdgeHexagon(e,t[d],t[d+1]),i++)}if(i===0&&t.length>=2){let d=Math.floor(Math.random()*(t.length-1));this.setEdgeHexagon(e,t[d],t[d+1])}}if(s||l||u||c){let g=this.calculateRegions(e,t),d=[1,2,3,4],w=Array.from({length:g.length},(P,C)=>C);this.shuffleArray(w);let v=new Set;for(let P=0;P<w.length;P++){let C=w[P],M=g[C],H=(o.difficulty??.5)>.7?.4:.2,b=P>=w.length-2;if((!(s&&r===0||l&&f===0||u&&h===0||c&&y===0)||!b)&&Math.random()>H+n*.5)continue;let p=[...M];this.shuffleArray(p);let N=d[Math.floor(Math.random()*d.length)];if(s&&!l&&b&&v.size===1){let E=d.filter($=>!v.has($));E.length>0&&(N=E[Math.floor(Math.random()*E.length)])}let R=s&&Math.random()<.5+n*.3;if(s&&r===0&&b&&(R=!0),s&&!l&&b&&v.size<2&&r>0&&(R=!0),R&&p.length>0){let E=Math.min(p.length,4),$=Math.floor(Math.random()*E)+1;for(let S=0;S<$&&p.length!==0;S++){let A=p.pop();e.cells[A.y][A.x].type=1,e.cells[A.y][A.x].color=N,r++,v.add(N)}}if(u&&x<m){let E=Math.random()<.1+n*.4;h===0&&b&&(E=!0);let $=h===0&&b?6:4;if(E&&p.length>0&&M.length<=$*4&&x+M.length<=m){let S=this.generateTiling(M,$,o);if(S){for(let A of S){if(p.length===0)break;let z=p.pop();e.cells[z.y][z.x].type=A.isRotated?4:3,e.cells[z.y][z.x].shape=A.isRotated?A.displayShape:A.shape,e.cells[z.y][z.x].color=0,h++}x+=M.length}}}if(c){let E=Math.random()<.05+n*.2;if(y===0&&b&&(E=!0),E&&p.length>=2){let $=p.pop();e.cells[$.y][$.x].type=5;let S=0;l&&Math.random()<.4&&(S=d[Math.floor(Math.random()*d.length)]),e.cells[$.y][$.x].color=S,y++;let A=p.pop();e.cells[A.y][A.x].type=2,e.cells[A.y][A.x].color=d.find(z=>z!==S)||3,f++}}if(l)for(let E of d){if(p.length<1)break;if(Math.random()>.2+n*.3)continue;let $=M.filter(S=>e.cells[S.y][S.x].color===E).length;if($===1){let S=p.pop();e.cells[S.y][S.x].type=2,e.cells[S.y][S.x].color=E,f++}else if($===0&&p.length>=2)for(let S=0;S<2;S++){let A=p.pop();e.cells[A.y][A.x].type=2,e.cells[A.y][A.x].color=E,f++}}}if(s&&!l&&v.size<2){for(let P of g)if(P.every(C=>e.cells[C.y][C.x].type===0)){let C=d.find(H=>!v.has(H))||2,M=P[Math.floor(Math.random()*P.length)];e.cells[M.y][M.x].type=1,e.cells[M.y][M.x].color=C,v.add(C),r++;break}}}}calculateRegions(e,t){let o=[],n=new Set,a=new Set;for(let s=0;s<t.length-1;s++)a.add(this.getEdgeKey(t[s],t[s+1]));for(let s=0;s<e.rows;s++)for(let l=0;l<e.cols;l++){if(n.has(`${l},${s}`))continue;let u=[],c=[{x:l,y:s}];for(n.add(`${l},${s}`);c.length>0;){let i=c.shift();u.push(i);let r=[{dx:0,dy:-1,p1:{x:i.x,y:i.y},p2:{x:i.x+1,y:i.y}},{dx:0,dy:1,p1:{x:i.x,y:i.y+1},p2:{x:i.x+1,y:i.y+1}},{dx:-1,dy:0,p1:{x:i.x,y:i.y},p2:{x:i.x,y:i.y+1}},{dx:1,dy:0,p1:{x:i.x+1,y:i.y},p2:{x:i.x+1,y:i.y+1}}];for(let f of r){let h=i.x+f.dx,y=i.y+f.dy;h>=0&&h<e.cols&&y>=0&&y<e.rows&&!n.has(`${h},${y}`)&&!a.has(this.getEdgeKey(f.p1,f.p2))&&!this.isAbsentEdge(e,f.p1,f.p2)&&(n.add(`${h},${y}`),c.push({x:h,y}))}}o.push(u)}return o}isAbsentEdge(e,t,o){if(t.x===o.x){let n=Math.min(t.y,o.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,o.x);return e.hEdges[t.y][n].type===2}}setEdgeHexagon(e,t,o){t.x===o.x?e.vEdges[Math.min(t.y,o.y)][t.x].type=3:e.hEdges[t.y][Math.min(t.x,o.x)].type=3}checkAllRequestedConstraintsPresent(e,t){let o=t.useHexagons??!0,n=t.useSquares??!0,a=t.useStars??!0,s=t.useTetris??!1,l=t.useEraser??!1;if(t.useBrokenEdges??!1){let c=!1;for(let i=0;i<=e.rows;i++)for(let r=0;r<e.cols;r++)if(e.hEdges[i][r].type===1||e.hEdges[i][r].type===2){c=!0;break}if(!c){for(let i=0;i<e.rows;i++)for(let r=0;r<=e.cols;r++)if(e.vEdges[i][r].type===1||e.vEdges[i][r].type===2){c=!0;break}}if(!c)return!1}if(o){let c=!1;for(let i=0;i<=e.rows;i++)for(let r=0;r<e.cols;r++)if(e.hEdges[i][r].type===3){c=!0;break}if(!c){for(let i=0;i<e.rows;i++)for(let r=0;r<=e.cols;r++)if(e.vEdges[i][r].type===3){c=!0;break}}if(!c)return!1}if(n||a||s||l){let c=!1,i=!1,r=!1,f=!1,h=new Set;for(let y=0;y<e.rows;y++)for(let x=0;x<e.cols;x++){let m=e.cells[y][x].type;m===1&&(c=!0,h.add(e.cells[y][x].color)),m===2&&(i=!0),(m===3||m===4)&&(r=!0),m===5&&(f=!0)}if(n&&!c||a&&!i||s&&!r||l&&!f||n&&c&&!i&&h.size<2)return!1}return!this.hasIsolatedMark(e)}generateTiling(e,t,o){let n=Math.min(...e.map(r=>r.x)),a=Math.min(...e.map(r=>r.y)),s=Math.max(...e.map(r=>r.x)),l=Math.max(...e.map(r=>r.y)),u=s-n+1,c=l-a+1,i=Array.from({length:c},()=>Array(u).fill(!1));for(let r of e)i[r.y-a][r.x-n]=!0;return this.tilingDfs(i,[],t,o)}tilingDfs(e,t,o,n){let a=-1,s=-1;for(let c=0;c<e.length;c++){for(let i=0;i<e[0].length;i++)if(e[c][i]){a=c,s=i;break}if(a!==-1)break}if(a===-1)return t;if(t.length>=o)return null;let l=n.difficulty??.5,u=[...this.TETRIS_SHAPES];this.shuffleArray(u),l>.6&&u.sort((c,i)=>this.getShapeArea(i)-this.getShapeArea(c));for(let c of u){let i=this.isRotationallyInvariant(c),r=i?[c]:this.getAllRotations(c);this.shuffleArray(r);for(let f of r){let h=[];for(let y=0;y<f.length;y++)for(let x=0;x<f[0].length;x++)f[y][x]&&h.push({r:y,c:x});for(let y of h){let x=a-y.r,m=s-y.c;if(this.canPlace(e,f,x,m)){this.placePiece(e,f,x,m,!1);let g=this.tilingDfs(e,[...t,{shape:f,displayShape:c,isRotated:!i&&Math.random()<.3+l*.6}],o,n);if(g)return g;this.placePiece(e,f,x,m,!0)}}}}return null}getShapeArea(e){let t=0;for(let o of e)for(let n of o)n&&t++;return t}isRotationallyInvariant(e){let t=this.getShapeArea(e);return t===1||t===4&&e.length===2&&e[0].length===2}getAllRotations(e){let t=[],o=new Set,n=e;for(let a=0;a<4;a++){let s=JSON.stringify(n);o.has(s)||(t.push(n),o.add(s)),n=this.rotate90(n)}return t}rotate90(e){let t=e.length,o=e[0].length,n=Array.from({length:o},()=>Array(t).fill(0));for(let a=0;a<t;a++)for(let s=0;s<o;s++)n[s][t-1-a]=e[a][s];return n}canPlace(e,t,o,n){for(let a=0;a<t.length;a++)for(let s=0;s<t[0].length;s++)if(t[a][s]){let l=o+a,u=n+s;if(l<0||l>=e.length||u<0||u>=e[0].length||!e[l][u])return!1}return!0}placePiece(e,t,o,n,a){for(let s=0;s<t.length;s++)for(let l=0;l<t[0].length;l++)t[s][l]&&(e[o+s][n+l]=a)}shuffleArray(e){for(let t=e.length-1;t>0;t--){let o=Math.floor(Math.random()*(t+1));[e[t],e[o]]=[e[o],e[t]]}}};var D=class{generator;validator;constructor(){this.generator=new G,this.validator=new V}createPuzzle(e,t,o={}){return this.generator.generate(e,t,o).export()}validateSolution(e,t){let o=B.fromData(e);return this.validator.validate(o,t)}calculateDifficulty(e){let t=B.fromData(e);return this.validator.calculateDifficulty(t)}};export{O as CellType,K as Color,F as Direction,q as EdgeType,B as Grid,I as NodeType,G as PuzzleGenerator,V as PuzzleValidator,D as WitnessCore};
//# sourceMappingURL=MiniWitness.min.js.map
