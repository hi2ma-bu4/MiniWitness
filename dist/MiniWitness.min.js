var w=(n=>(n[n.Up=0]="Up",n[n.Right=1]="Right",n[n.Down=2]="Down",n[n.Left=3]="Left",n))(w||{}),P=(o=>(o[o.None=0]="None",o[o.Square=1]="Square",o[o.Star=2]="Star",o))(P||{}),$=(o=>(o[o.Normal=0]="Normal",o[o.Hexagon=1]="Hexagon",o[o.Broken=2]="Broken",o))($||{}),S=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o))(S||{}),E=(r=>(r[r.None=0]="None",r[r.Black=1]="Black",r[r.White=2]="White",r[r.Red=3]="Red",r[r.Blue=4]="Blue",r))(E||{});var p=class b{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(t,e){this.rows=t,this.cols=e,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:0}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(t){let e=new b(t.rows,t.cols);return e.cells=t.cells,e.vEdges=t.vEdges,e.hEdges=t.hEdges,e.nodes=t.nodes,e}};var g=class{validate(t,e){let o=e.points;if(o.length<2)return{isValid:!1,errorReason:"Path too short"};let n=o[0],r=o[o.length-1];if(t.nodes[n.y][n.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(t.nodes[r.y][r.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let i=new Set;i.add(`${n.x},${n.y}`);for(let l=0;l<o.length-1;l++){let c=o[l],a=o[l+1];if(Math.abs(c.x-a.x)+Math.abs(c.y-a.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let u=`${a.x},${a.y}`;if(i.has(u))return{isValid:!1,errorReason:"Self-intersecting path"};if(i.add(u),this.isBrokenEdge(t,c,a))return{isValid:!1,errorReason:"Passed through broken edge"}}return this.checkHexagonConstraint(t,o)?this.checkCellConstraints(t,o)?{isValid:!0}:{isValid:!1,errorReason:"Cell constraints failed"}:{isValid:!1,errorReason:"Missed hexagon constraint"}}isBrokenEdge(t,e,o){if(e.x===o.x){let n=Math.min(e.y,o.y);return t.vEdges[n][e.x].type===2}else{let n=Math.min(e.x,o.x);return t.hEdges[e.y][n].type===2}}checkHexagonConstraint(t,e){let o=new Set;for(let n=0;n<e.length-1;n++){let r=e[n],i=e[n+1];o.add(this.getEdgeKey(r,i))}for(let n=0;n<=t.rows;n++)for(let r=0;r<t.cols;r++)if(n<t.rows+1&&t.hEdges[n][r].type===1){let i=this.getEdgeKey({x:r,y:n},{x:r+1,y:n});if(!o.has(i))return!1}for(let n=0;n<t.rows;n++)for(let r=0;r<=t.cols;r++)if(t.vEdges[n][r].type===1){let i=this.getEdgeKey({x:r,y:n},{x:r,y:n+1});if(!o.has(i))return!1}return!0}checkCellConstraints(t,e){let o=this.calculateRegions(t,e);for(let n of o){let r=new Map,i=new Set,l=new Set;for(let c of n){let a=t.cells[c.y][c.x];if(a.type===0)continue;let s=a.color;if(r.set(s,(r.get(s)||0)+1),a.type===1?l.add(s):a.type===2&&i.add(s),l.size>1)return!1}for(let c of i)if(r.get(c)!==2)return!1}return!0}calculateRegions(t,e){let o=[],n=new Set,r=new Set;for(let i=0;i<e.length-1;i++)r.add(this.getEdgeKey(e[i],e[i+1]));for(let i=0;i<t.rows;i++)for(let l=0;l<t.cols;l++){if(n.has(`${l},${i}`))continue;let c=[],a=[{x:l,y:i}];for(n.add(`${l},${i}`);a.length>0;){let s=a.shift();c.push(s);let u=[{nx:s.x,ny:s.y-1,p1:{x:s.x,y:s.y},p2:{x:s.x+1,y:s.y}},{nx:s.x,ny:s.y+1,p1:{x:s.x,y:s.y+1},p2:{x:s.x+1,y:s.y+1}},{nx:s.x-1,ny:s.y,p1:{x:s.x,y:s.y},p2:{x:s.x,y:s.y+1}},{nx:s.x+1,ny:s.y,p1:{x:s.x+1,y:s.y},p2:{x:s.x+1,y:s.y+1}}];for(let y of u)if(y.nx>=0&&y.nx<t.cols&&y.ny>=0&&y.ny<t.rows&&!n.has(`${y.nx},${y.ny}`)){let h=this.getEdgeKey(y.p1,y.p2),d=this.isBrokenEdge(t,y.p1,y.p2);!r.has(h)&&!d&&(n.add(`${y.nx},${y.ny}`),a.push({x:y.nx,y:y.ny}))}}o.push(c)}return o}getEdgeKey(t,e){return t.x<e.x||t.x===e.x&&t.y<e.y?`${t.x},${t.y}-${e.x},${e.y}`:`${e.x},${e.y}-${t.x},${t.y}`}countSolutions(t){let e=[];for(let n=0;n<=t.rows;n++)for(let r=0;r<=t.cols;r++)t.nodes[n][r].type===1&&e.push({x:r,y:n});let o=0;for(let n of e)o+=this.findPathsRecursively(t,n,new Set,[]);return o}findPathsRecursively(t,e,o,n){let r=`${e.x},${e.y}`;o.add(r),n.push(e);let i=0;if(t.nodes[e.y][e.x].type===2)this.validate(t,{points:n}).isValid&&(i=1);else{let l=[{dx:0,dy:-1},{dx:1,dy:0},{dx:0,dy:1},{dx:-1,dy:0}];for(let c of l){let a={x:e.x+c.dx,y:e.y+c.dy};a.x>=0&&a.x<=t.cols&&a.y>=0&&a.y<=t.rows&&(o.has(`${a.x},${a.y}`)||this.isBrokenEdge(t,e,a)||(i+=this.findPathsRecursively(t,a,o,n)))}}return n.pop(),o.delete(r),i}};var m=class{generate(t,e,o={}){let n=o.difficulty??.5,r=new g,i=null,l=1/0,c=t*e>30?3:10;for(let a=0;a<c;a++){let s=this.generateOnce(t,e,o),u=r.countSolutions(s),y;if(n>.5?y=Math.abs(u-2):u===1?y=0:y=Math.max(0,10-u)/10,u>0&&y<l&&(l=y,i=s),l===0)break}return i||this.generateOnce(t,e,o)}generateOnce(t,e,o){let n=new p(t,e),r={x:0,y:t},i={x:e,y:0};n.nodes[r.y][r.x].type=1,n.nodes[i.y][i.x].type=2;let l=this.generateRandomPath(n,r,i);return this.applyConstraintsBasedOnPath(n,l,o),n}generateRandomPath(t,e,o){let n=new Set,r=[],i=[e];new Map().set(`${e.x},${e.y}`,null);let c=a=>{if(n.add(`${a.x},${a.y}`),r.push(a),a.x===o.x&&a.y===o.y)return!0;let s=this.getValidNeighbors(t,a,n);this.shuffleArray(s);for(let u of s)if(c(u))return!0;return r.pop(),!1};return c(e),r}getValidNeighbors(t,e,o){let n=[],r=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let i of r){let l=e.x+i.x,c=e.y+i.y;l>=0&&l<=t.cols&&c>=0&&c<=t.rows&&(o.has(`${l},${c}`)||n.push({x:l,y:c}))}return n}applyConstraintsBasedOnPath(t,e,o){let n=o.complexity??.5,r=o.useHexagons??!0,i=o.useSquares??!0,l=o.useStars??!0;if(r)for(let c=0;c<e.length-1;c++){let a=e[c],s=e[c+1];Math.random()<n*.4&&this.setEdgeHexagon(t,a,s)}if(i||l){let c=this.calculateRegions(t,e),a=[1,2,3,4];for(let s of c){if(Math.random()>.4+n*.5)continue;let u=[...s];this.shuffleArray(u);let y=a[Math.floor(Math.random()*a.length)],h=0;if(i&&Math.random()<.5+n*.3){let d=Math.min(u.length,4);h=Math.floor(Math.random()*d);for(let x=0;x<h;x++){let f=u.pop();t.cells[f.y][f.x].type=1,t.cells[f.y][f.x].color=y}}if(l)for(let d of a){if(u.length<1)break;if(!(Math.random()>.2+n*.3)){if(d===y){if(h===1&&u.length>=1){let x=u.pop();t.cells[x.y][x.x].type=2,t.cells[x.y][x.x].color=d}else if(h===0&&u.length>=2)for(let x=0;x<2;x++){let f=u.pop();t.cells[f.y][f.x].type=2,t.cells[f.y][f.x].color=d}}else if(u.length>=2)for(let x=0;x<2;x++){let f=u.pop();t.cells[f.y][f.x].type=2,t.cells[f.y][f.x].color=d}}}}}}calculateRegions(t,e){let o=[],n=new Set,r=new Set;for(let i=0;i<e.length-1;i++){let l=e[i],c=e[i+1],a=l.x<c.x||l.y<c.y?`${l.x},${l.y}-${c.x},${c.y}`:`${c.x},${c.y}-${l.x},${l.y}`;r.add(a)}for(let i=0;i<t.rows;i++)for(let l=0;l<t.cols;l++){if(n.has(`${l},${i}`))continue;let c=[],a=[{x:l,y:i}];for(n.add(`${l},${i}`);a.length>0;){let s=a.shift();c.push(s);let u=[{dx:0,dy:-1,boundary:{p1:{x:s.x,y:s.y},p2:{x:s.x+1,y:s.y}}},{dx:0,dy:1,boundary:{p1:{x:s.x,y:s.y+1},p2:{x:s.x+1,y:s.y+1}}},{dx:-1,dy:0,boundary:{p1:{x:s.x,y:s.y},p2:{x:s.x,y:s.y+1}}},{dx:1,dy:0,boundary:{p1:{x:s.x+1,y:s.y},p2:{x:s.x+1,y:s.y+1}}}];for(let y of u){let h=s.x+y.dx,d=s.y+y.dy;if(h>=0&&h<t.cols&&d>=0&&d<t.rows&&!n.has(`${h},${d}`)){let x=y.boundary.p1.x<y.boundary.p2.x||y.boundary.p1.y<y.boundary.p2.y?`${y.boundary.p1.x},${y.boundary.p1.y}-${y.boundary.p2.x},${y.boundary.p2.y}`:`${y.boundary.p2.x},${y.boundary.p2.y}-${y.boundary.p1.x},${y.boundary.p1.y}`;r.has(x)||(n.add(`${h},${d}`),a.push({x:h,y:d}))}}}o.push(c)}return o}setEdgeHexagon(t,e,o){if(e.x===o.x){let n=Math.min(e.y,o.y);t.vEdges[n][e.x].type=1}else{let n=Math.min(e.x,o.x);t.hEdges[e.y][n].type=1}}shuffleArray(t){for(let e=t.length-1;e>0;e--){let o=Math.floor(Math.random()*(e+1));[t[e],t[o]]=[t[o],t[e]]}}};var v=class{generator;validator;constructor(){this.generator=new m,this.validator=new g}createPuzzle(t,e,o={}){return this.generator.generate(t,e,o).export()}validateSolution(t,e){let o=p.fromData(t);return this.validator.validate(o,e)}};export{P as CellType,E as Color,w as Direction,$ as EdgeType,p as Grid,S as NodeType,m as PuzzleGenerator,g as PuzzleValidator,v as WitnessCore};
//# sourceMappingURL=MiniWitness.min.js.map
