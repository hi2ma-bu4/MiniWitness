var O=(n=>(n[n.Up=0]="Up",n[n.Right=1]="Right",n[n.Down=2]="Down",n[n.Left=3]="Left",n))(O||{}),H=(o=>(o[o.None=0]="None",o[o.Square=1]="Square",o[o.Star=2]="Star",o))(H||{}),N=(o=>(o[o.Normal=0]="Normal",o[o.Hexagon=1]="Hexagon",o[o.Broken=2]="Broken",o))(N||{}),V=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o))(V||{}),R=(a=>(a[a.None=0]="None",a[a.Black=1]="Black",a[a.White=2]="White",a[a.Red=3]="Red",a[a.Blue=4]="Blue",a))(R||{});var k=class M{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(e,t){this.rows=e,this.cols=t,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:0}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(e){let t=new M(e.rows,e.cols);return t.cells=e.cells,t.vEdges=e.vEdges,t.hEdges=e.hEdges,t.nodes=e.nodes,t}};var w=class{validate(e,t){let o=t.points;if(o.length<2)return{isValid:!1,errorReason:"Path too short"};let n=o[0],a=o[o.length-1];if(e.nodes[n.y][n.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[a.y][a.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let i=new Set;i.add(`${n.x},${n.y}`);for(let r=0;r<o.length-1;r++){let l=o[r],c=o[r+1];if(Math.abs(l.x-c.x)+Math.abs(l.y-c.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let h=`${c.x},${c.y}`;if(i.has(h))return{isValid:!1,errorReason:"Self-intersecting path"};if(i.add(h),this.isBrokenEdge(e,l,c))return{isValid:!1,errorReason:"Passed through broken edge"}}return this.checkHexagonConstraint(e,o)?this.checkCellConstraints(e,o)?{isValid:!0}:{isValid:!1,errorReason:"Cell constraints failed"}:{isValid:!1,errorReason:"Missed hexagon constraint"}}isBrokenEdge(e,t,o){if(t.x===o.x){let n=Math.min(t.y,o.y);return e.vEdges[n][t.x].type===2}else{let n=Math.min(t.x,o.x);return e.hEdges[t.y][n].type===2}}checkHexagonConstraint(e,t){let o=new Set;for(let n=0;n<t.length-1;n++)o.add(this.getEdgeKey(t[n],t[n+1]));for(let n=0;n<=e.rows;n++)for(let a=0;a<e.cols;a++)if(e.hEdges[n][a].type===1){let i=this.getEdgeKey({x:a,y:n},{x:a+1,y:n});if(!o.has(i))return!1}for(let n=0;n<e.rows;n++)for(let a=0;a<=e.cols;a++)if(e.vEdges[n][a].type===1){let i=this.getEdgeKey({x:a,y:n},{x:a,y:n+1});if(!o.has(i))return!1}return!0}checkCellConstraints(e,t){let o=this.calculateRegions(e,t);for(let n of o){let a=new Map,i=new Set,r=new Set;for(let l of n){let c=e.cells[l.y][l.x];if(c.type===0)continue;let s=c.color;if(a.set(s,(a.get(s)||0)+1),c.type===1?r.add(s):c.type===2&&i.add(s),r.size>1)return!1}for(let l of i)if(a.get(l)!==2)return!1}return!0}calculateRegions(e,t){let o=[],n=new Set,a=new Set;for(let i=0;i<t.length-1;i++)a.add(this.getEdgeKey(t[i],t[i+1]));for(let i=0;i<e.rows;i++)for(let r=0;r<e.cols;r++){if(n.has(`${r},${i}`))continue;let l=[],c=[{x:r,y:i}];for(n.add(`${r},${i}`);c.length>0;){let s=c.shift();l.push(s);let h=[{nx:s.x,ny:s.y-1,p1:{x:s.x,y:s.y},p2:{x:s.x+1,y:s.y}},{nx:s.x,ny:s.y+1,p1:{x:s.x,y:s.y+1},p2:{x:s.x+1,y:s.y+1}},{nx:s.x-1,ny:s.y,p1:{x:s.x,y:s.y},p2:{x:s.x,y:s.y+1}},{nx:s.x+1,ny:s.y,p1:{x:s.x+1,y:s.y},p2:{x:s.x+1,y:s.y+1}}];for(let u of h)if(u.nx>=0&&u.nx<e.cols&&u.ny>=0&&u.ny<e.rows&&!n.has(`${u.nx},${u.ny}`)){let f=this.getEdgeKey(u.p1,u.p2),y=this.isBrokenEdge(e,u.p1,u.p2);!a.has(f)&&!y&&(n.add(`${u.nx},${u.ny}`),c.push({x:u.nx,y:u.ny}))}}o.push(l)}return o}getEdgeKey(e,t){return e.x<t.x||e.x===t.x&&e.y<t.y?`${e.x},${e.y}-${t.x},${t.y}`:`${t.x},${t.y}-${e.x},${e.y}`}calculateDifficulty(e){let t=e.rows,o=e.cols,n=o+1,a=(t+1)*n,i=Array.from({length:a},()=>[]),r=[],l=[],c=new Set;for(let x=0;x<=t;x++)for(let g=0;g<=o;g++){let d=x*n+g;if(e.nodes[x][g].type===1&&r.push(d),e.nodes[x][g].type===2&&l.push(d),g<o){let S=d+1,$=e.hEdges[x][g].type===1,z=e.hEdges[x][g].type===2;i[d].push({next:S,isHexagon:$,isBroken:z}),i[S].push({next:d,isHexagon:$,isBroken:z}),$&&c.add(this.getEdgeKey({x:g,y:x},{x:g+1,y:x}))}if(x<t){let S=d+n,$=e.vEdges[x][g].type===1,z=e.vEdges[x][g].type===2;i[d].push({next:S,isHexagon:$,isBroken:z}),i[S].push({next:d,isHexagon:$,isBroken:z}),$&&c.add(this.getEdgeKey({x:g,y:x},{x:g,y:x+1}))}}let s={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},h=c.size,u=new Set;for(let x of r)this.exploreSearchSpace(e,x,1n<<BigInt(x),[x],0,h,i,l,u,s,500);if(s.solutions===0)return 0;let f=c.size,y=new Set;c.size>0&&y.add(999);for(let x=0;x<t;x++)for(let g=0;g<o;g++){let d=e.cells[x][g];d.type!==0&&(f++,y.add(d.type))}let p=s.branchingPoints/(s.totalNodesVisited||1),m=Math.log10(s.totalNodesVisited+1),b=(p*10+m*1)/(Math.log2(s.solutions+1)+1),P=t*o,E=f/P,G=E<.3?Math.pow(E/.3,3):1,v=y.size<=1?.4:1;b*=G*v;let C=Math.sqrt(P)/4;return b*=C,Math.max(.01,Math.min(1,b/4))}exploreSearchSpace(e,t,o,n,a,i,r,l,c,s,h){if(s.totalNodesVisited++,s.maxDepth=Math.max(s.maxDepth,n.length),s.totalNodesVisited>h)return;if(l.includes(t)){if(a===i){let f={points:n.map(y=>({x:y%(e.cols+1),y:Math.floor(y/(e.cols+1))}))};if(this.validate(e,f).isValid){let y=this.getFingerprint(e,f.points);c.has(y)||(c.add(y),s.solutions++)}}return}if(!this.canReachEndOptimized(t,o,r,l)){s.backtracks++;return}let u=[];for(let f of r[t]){if(f.isBroken||o&1n<<BigInt(f.next))continue;let y=!0;for(let p of r[t])if(p.isHexagon){let m=n.length>=2&&p.next===n[n.length-2],b=p.next===f.next;if(!m&&!b){y=!1;break}}y&&u.push(f)}u.length>1&&s.branchingPoints++;for(let f of u)if(n.push(f.next),this.exploreSearchSpace(e,f.next,o|1n<<BigInt(f.next),n,a+(f.isHexagon?1:0),i,r,l,c,s,h),n.pop(),s.totalNodesVisited>h)return}countSolutions(e,t=100){let o=e.rows,n=e.cols,a=n+1,i=(o+1)*a,r=Array.from({length:i},()=>[]),l=[],c=[],s=new Set;for(let f=0;f<=o;f++)for(let y=0;y<=n;y++){let p=f*a+y;if(e.nodes[f][y].type===1&&l.push(p),e.nodes[f][y].type===2&&c.push(p),y<n){let m=p+1,b=e.hEdges[f][y].type===1,P=e.hEdges[f][y].type===2;r[p].push({next:m,isHexagon:b,isBroken:P}),r[m].push({next:p,isHexagon:b,isBroken:P}),b&&s.add(this.getEdgeKey({x:y,y:f},{x:y+1,y:f}))}if(f<o){let m=p+a,b=e.vEdges[f][y].type===1,P=e.vEdges[f][y].type===2;r[p].push({next:m,isHexagon:b,isBroken:P}),r[m].push({next:p,isHexagon:b,isBroken:P}),b&&s.add(this.getEdgeKey({x:y,y:f},{x:y,y:f+1}))}}let h=new Set,u=s.size;for(let f of l)if(this.findPathsOptimized(e,f,1n<<BigInt(f),[f],0,u,r,c,h,t),h.size>=t)break;return h.size}findPathsOptimized(e,t,o,n,a,i,r,l,c,s){if(!(c.size>=s)){if(l.includes(t)){if(a===i){let h={points:n.map(u=>({x:u%(e.cols+1),y:Math.floor(u/(e.cols+1))}))};this.validate(e,h).isValid&&c.add(this.getFingerprint(e,h.points))}return}if(this.canReachEndOptimized(t,o,r,l))for(let h of r[t]){if(h.isBroken||o&1n<<BigInt(h.next))continue;let u=!0;for(let f of r[t])if(f.isHexagon){let y=n.length>=2&&f.next===n[n.length-2],p=f.next===h.next;if(!y&&!p){u=!1;break}}if(u&&(n.push(h.next),this.findPathsOptimized(e,h.next,o|1n<<BigInt(h.next),n,a+(h.isHexagon?1:0),i,r,l,c,s),n.pop(),c.size>=s))return}}}canReachEndOptimized(e,t,o,n){let a=[e],i=t,r=0;for(;r<a.length;){let l=a[r++];if(n.includes(l))return!0;for(let c of o[l])!c.isBroken&&!(i&1n<<BigInt(c.next))&&(i|=1n<<BigInt(c.next),a.push(c.next))}return!1}getFingerprint(e,t){return this.calculateRegions(e,t).map(a=>a.map(r=>e.cells[r.y][r.x]).filter(r=>r.type!==0).map(r=>`${r.type}:${r.color}`).sort().join(",")).sort().filter(a=>a.length>0).join("|")||"empty"}};var B=class{generate(e,t,o={}){let n=o.difficulty??.5,a=new w,i=null,r=-1,l=e*t>30?30:60;for(let c=0;c<l;c++){let s=this.generateOnce(e,t,o);if(!this.checkAllRequestedConstraintsPresent(s,o))continue;let h=a.calculateDifficulty(s);if(h===0)continue;let u=Math.abs(h-n);if((i===null||u<Math.abs(r-n))&&(r=h,i=s),n>.8&&h>.8||u<.05)break}return i||this.generateOnce(e,t,o)}generateOnce(e,t,o){let n=new k(e,t),a={x:0,y:e},i={x:t,y:0};n.nodes[a.y][a.x].type=1,n.nodes[i.y][i.x].type=2;let r=this.generateRandomPath(n,a,i);return this.applyConstraintsBasedOnPath(n,r,o),n}generateRandomPath(e,t,o){let n=new Set,a=[],i=[t];new Map().set(`${t.x},${t.y}`,null);let l=c=>{if(n.add(`${c.x},${c.y}`),a.push(c),c.x===o.x&&c.y===o.y)return!0;let s=this.getValidNeighbors(e,c,n);this.shuffleArray(s);for(let h of s)if(l(h))return!0;return a.pop(),!1};return l(t),a}getValidNeighbors(e,t,o){let n=[],a=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let i of a){let r=t.x+i.x,l=t.y+i.y;r>=0&&r<=e.cols&&l>=0&&l<=e.rows&&(o.has(`${r},${l}`)||n.push({x:r,y:l}))}return n}applyConstraintsBasedOnPath(e,t,o){let n=o.complexity??.5,a=o.useHexagons??!0,i=o.useSquares??!0,r=o.useStars??!0,l=0,c=0,s=0;if(a){let h=o.difficulty??.5;for(let u=0;u<t.length-1;u++){let f=t[u],y=t[u+1],m=this.getValidNeighbors(e,f,new Set).length>2,b=n*.4;m&&(b=h<.4?b*1:b*.5),Math.random()<b&&(this.setEdgeHexagon(e,f,y),l++)}if(l===0&&t.length>=2){let u=Math.floor(Math.random()*(t.length-1));this.setEdgeHexagon(e,t[u],t[u+1])}}if(i||r){let h=this.calculateRegions(e,t),u=[1,2,3,4],f=Array.from({length:h.length},(y,p)=>p);this.shuffleArray(f);for(let y of f){let p=h[y],m=(o.difficulty??.5)>.7?.4:.2,b=i&&c===0||r&&s===0,P=y===f[f.length-1];if((!b||!P)&&Math.random()>m+n*.5)continue;let E=[...p];this.shuffleArray(E);let G=u[Math.floor(Math.random()*u.length)],v=0,C=i&&Math.random()<.5+n*.3;if(i&&c===0&&P&&(C=!0),C){let x=Math.min(E.length,4);v=Math.floor(Math.random()*x),v===0&&c===0&&(v=1);for(let g=0;g<v&&E.length!==0;g++){let d=E.pop();e.cells[d.y][d.x].type=1,e.cells[d.y][d.x].color=G,c++}}if(r)for(let x of u){if(E.length<1)break;let g=Math.random()<.2+n*.3;if(s===0&&P&&(g=!0),!!g){if(x===G){if(v===1&&E.length>=1){let d=E.pop();e.cells[d.y][d.x].type=2,e.cells[d.y][d.x].color=x,s++}else if(v===0&&E.length>=2)for(let d=0;d<2;d++){let S=E.pop();e.cells[S.y][S.x].type=2,e.cells[S.y][S.x].color=x,s++}}else if(E.length>=2)for(let d=0;d<2;d++){let S=E.pop();e.cells[S.y][S.x].type=2,e.cells[S.y][S.x].color=x,s++}}}}if(r&&s===0){for(let y of h)if(y.length>=2){let p=[...y].filter(m=>e.cells[m.y][m.x].type===0);if(p.length>=2){let m=u[Math.floor(Math.random()*u.length)];for(let b=0;b<2;b++){let P=p.pop();e.cells[P.y][P.x].type=2,e.cells[P.y][P.x].color=m,s++}break}}}}}calculateRegions(e,t){let o=[],n=new Set,a=new Set;for(let i=0;i<t.length-1;i++){let r=t[i],l=t[i+1],c=r.x<l.x||r.y<l.y?`${r.x},${r.y}-${l.x},${l.y}`:`${l.x},${l.y}-${r.x},${r.y}`;a.add(c)}for(let i=0;i<e.rows;i++)for(let r=0;r<e.cols;r++){if(n.has(`${r},${i}`))continue;let l=[],c=[{x:r,y:i}];for(n.add(`${r},${i}`);c.length>0;){let s=c.shift();l.push(s);let h=[{dx:0,dy:-1,boundary:{p1:{x:s.x,y:s.y},p2:{x:s.x+1,y:s.y}}},{dx:0,dy:1,boundary:{p1:{x:s.x,y:s.y+1},p2:{x:s.x+1,y:s.y+1}}},{dx:-1,dy:0,boundary:{p1:{x:s.x,y:s.y},p2:{x:s.x,y:s.y+1}}},{dx:1,dy:0,boundary:{p1:{x:s.x+1,y:s.y},p2:{x:s.x+1,y:s.y+1}}}];for(let u of h){let f=s.x+u.dx,y=s.y+u.dy;if(f>=0&&f<e.cols&&y>=0&&y<e.rows&&!n.has(`${f},${y}`)){let p=u.boundary.p1.x<u.boundary.p2.x||u.boundary.p1.y<u.boundary.p2.y?`${u.boundary.p1.x},${u.boundary.p1.y}-${u.boundary.p2.x},${u.boundary.p2.y}`:`${u.boundary.p2.x},${u.boundary.p2.y}-${u.boundary.p1.x},${u.boundary.p1.y}`;a.has(p)||(n.add(`${f},${y}`),c.push({x:f,y}))}}}o.push(l)}return o}setEdgeHexagon(e,t,o){if(t.x===o.x){let n=Math.min(t.y,o.y);e.vEdges[n][t.x].type=1}else{let n=Math.min(t.x,o.x);e.hEdges[t.y][n].type=1}}checkAllRequestedConstraintsPresent(e,t){let o=t.useHexagons??!0,n=t.useSquares??!0,a=t.useStars??!0;if(o){let i=!1;for(let r=0;r<=e.rows;r++){for(let l=0;l<e.cols;l++)if(e.hEdges[r][l].type===1){i=!0;break}if(i)break}if(!i)for(let r=0;r<e.rows;r++){for(let l=0;l<=e.cols;l++)if(e.vEdges[r][l].type===1){i=!0;break}if(i)break}if(!i)return!1}if(n||a){let i=!1,r=!1;for(let l=0;l<e.rows;l++)for(let c=0;c<e.cols;c++)e.cells[l][c].type===1&&(i=!0),e.cells[l][c].type===2&&(r=!0);if(n&&!i||a&&!r)return!1}return!0}shuffleArray(e){for(let t=e.length-1;t>0;t--){let o=Math.floor(Math.random()*(t+1));[e[t],e[o]]=[e[o],e[t]]}}};var q=class{generator;validator;constructor(){this.generator=new B,this.validator=new w}createPuzzle(e,t,o={}){return this.generator.generate(e,t,o).export()}validateSolution(e,t){let o=k.fromData(e);return this.validator.validate(o,t)}calculateDifficulty(e){let t=k.fromData(e);return this.validator.calculateDifficulty(t)}};export{H as CellType,R as Color,O as Direction,N as EdgeType,k as Grid,V as NodeType,B as PuzzleGenerator,w as PuzzleValidator,q as WitnessCore};
//# sourceMappingURL=MiniWitness.min.js.map
