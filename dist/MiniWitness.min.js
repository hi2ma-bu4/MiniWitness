var O=(t=>(t[t.Up=0]="Up",t[t.Right=1]="Right",t[t.Down=2]="Down",t[t.Left=3]="Left",t))(O||{}),N=(s=>(s[s.None=0]="None",s[s.Square=1]="Square",s[s.Star=2]="Star",s))(N||{}),H=(t=>(t[t.Normal=0]="Normal",t[t.Broken=1]="Broken",t[t.Absent=2]="Absent",t[t.Hexagon=3]="Hexagon",t))(H||{}),V=(s=>(s[s.Normal=0]="Normal",s[s.Start=1]="Start",s[s.End=2]="End",s))(V||{}),R=(c=>(c[c.None=0]="None",c[c.Black=1]="Black",c[c.White=2]="White",c[c.Red=3]="Red",c[c.Blue=4]="Blue",c))(R||{});var k=class G{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(e,n){this.rows=e,this.cols=n,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:0}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(e){let n=new G(e.rows,e.cols);return n.cells=e.cells,n.vEdges=e.vEdges,n.hEdges=e.hEdges,n.nodes=e.nodes,n}};var A=class{validate(e,n){let s=n.points;if(s.length<2)return{isValid:!1,errorReason:"Path too short"};let t=s[0],c=s[s.length-1];if(e.nodes[t.y][t.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[c.y][c.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let o=new Set;o.add(`${t.x},${t.y}`);for(let r=0;r<s.length-1;r++){let a=s[r],i=s[r+1];if(Math.abs(a.x-i.x)+Math.abs(a.y-i.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let f=`${i.x},${i.y}`;if(o.has(f))return{isValid:!1,errorReason:"Self-intersecting path"};if(o.add(f),this.isBrokenEdge(e,a,i))return{isValid:!1,errorReason:"Passed through broken edge"}}return this.checkHexagonConstraint(e,s)?this.checkCellConstraints(e,s)?{isValid:!0}:{isValid:!1,errorReason:"Cell constraints failed"}:{isValid:!1,errorReason:"Missed hexagon constraint"}}isBrokenEdge(e,n,s){let t;if(n.x===s.x){let c=Math.min(n.y,s.y);t=e.vEdges[c][n.x].type}else{let c=Math.min(n.x,s.x);t=e.hEdges[n.y][c].type}return t===1||t===2}isAbsentEdge(e,n,s){if(n.x===s.x){let t=Math.min(n.y,s.y);return e.vEdges[t][n.x].type===2}else{let t=Math.min(n.x,s.x);return e.hEdges[n.y][t].type===2}}checkHexagonConstraint(e,n){let s=new Set;for(let t=0;t<n.length-1;t++)s.add(this.getEdgeKey(n[t],n[t+1]));for(let t=0;t<=e.rows;t++)for(let c=0;c<e.cols;c++)if(e.hEdges[t][c].type===3){let o=this.getEdgeKey({x:c,y:t},{x:c+1,y:t});if(!s.has(o))return!1}for(let t=0;t<e.rows;t++)for(let c=0;c<=e.cols;c++)if(e.vEdges[t][c].type===3){let o=this.getEdgeKey({x:c,y:t},{x:c,y:t+1});if(!s.has(o))return!1}return!0}checkCellConstraints(e,n){let s=this.calculateRegions(e,n);for(let t of s){let c=new Map,o=new Set,r=new Set;for(let a of t){let i=e.cells[a.y][a.x];if(i.type===0)continue;let l=i.color;if(c.set(l,(c.get(l)||0)+1),i.type===1?r.add(l):i.type===2&&o.add(l),r.size>1)return!1}for(let a of o)if(c.get(a)!==2)return!1}return!0}calculateRegions(e,n){let s=[],t=new Set,c=new Set;for(let r=0;r<n.length-1;r++)c.add(this.getEdgeKey(n[r],n[r+1]));let o=this.getExternalCells(e);for(let r=0;r<e.rows;r++)for(let a=0;a<e.cols;a++){if(t.has(`${a},${r}`)||o.has(`${a},${r}`))continue;let i=[],l=[{x:a,y:r}];for(t.add(`${a},${r}`);l.length>0;){let f=l.shift();i.push(f);let y=[{nx:f.x,ny:f.y-1,p1:{x:f.x,y:f.y},p2:{x:f.x+1,y:f.y}},{nx:f.x,ny:f.y+1,p1:{x:f.x,y:f.y+1},p2:{x:f.x+1,y:f.y+1}},{nx:f.x-1,ny:f.y,p1:{x:f.x,y:f.y},p2:{x:f.x,y:f.y+1}},{nx:f.x+1,ny:f.y,p1:{x:f.x+1,y:f.y},p2:{x:f.x+1,y:f.y+1}}];for(let u of y)if(u.nx>=0&&u.nx<e.cols&&u.ny>=0&&u.ny<e.rows){let h=`${u.nx},${u.ny}`;if(!t.has(h)&&!o.has(h)){let b=this.getEdgeKey(u.p1,u.p2),E=this.isAbsentEdge(e,u.p1,u.p2);!c.has(b)&&!E&&(t.add(h),l.push({x:u.nx,y:u.ny}))}}}s.push(i)}return s}getExternalCells(e){let n=new Set,s=[];for(let t=0;t<e.cols;t++)e.hEdges[0][t].type===2&&(n.has(`${t},0`)||(n.add(`${t},0`),s.push({x:t,y:0}))),e.hEdges[e.rows][t].type===2&&(n.has(`${t},${e.rows-1}`)||(n.add(`${t},${e.rows-1}`),s.push({x:t,y:e.rows-1})));for(let t=0;t<e.rows;t++)e.vEdges[t][0].type===2&&(n.has(`0,${t}`)||(n.add(`0,${t}`),s.push({x:0,y:t}))),e.vEdges[t][e.cols].type===2&&(n.has(`${e.cols-1},${t}`)||(n.add(`${e.cols-1},${t}`),s.push({x:e.cols-1,y:t})));for(;s.length>0;){let t=s.shift(),c=[{nx:t.x,ny:t.y-1,edge:e.hEdges[t.y][t.x]},{nx:t.x,ny:t.y+1,edge:e.hEdges[t.y+1][t.x]},{nx:t.x-1,ny:t.y,edge:e.vEdges[t.y][t.x]},{nx:t.x+1,ny:t.y,edge:e.vEdges[t.y][t.x+1]}];for(let o of c)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!n.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(n.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return n}getEdgeKey(e,n){return e.x<n.x||e.x===n.x&&e.y<n.y?`${e.x},${e.y}-${n.x},${n.y}`:`${n.x},${n.y}-${e.x},${e.y}`}calculateDifficulty(e){let n=e.rows,s=e.cols,t=s+1,c=(n+1)*t,o=Array.from({length:c},()=>[]),r=[],a=[],i=new Set;for(let d=0;d<=n;d++)for(let p=0;p<=s;p++){let x=d*t+p;if(e.nodes[d][p].type===1&&r.push(x),e.nodes[d][p].type===2&&a.push(x),p<s){let v=x+1,w=e.hEdges[d][p].type,S=w===3,C=w===1||w===2;o[x].push({next:v,isHexagon:S,isBroken:C}),o[v].push({next:x,isHexagon:S,isBroken:C}),S&&i.add(this.getEdgeKey({x:p,y:d},{x:p+1,y:d}))}if(d<n){let v=x+t,w=e.vEdges[d][p].type,S=w===3,C=w===1||w===2;o[x].push({next:v,isHexagon:S,isBroken:C}),o[v].push({next:x,isHexagon:S,isBroken:C}),S&&i.add(this.getEdgeKey({x:p,y:d},{x:p,y:d+1}))}}let l={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},f=i.size,y=new Set;for(let d of r)this.exploreSearchSpace(e,d,1n<<BigInt(d),[d],0,f,o,a,y,l,500);if(l.solutions===0)return 0;let u=i.size,h=new Set;i.size>0&&h.add(999);for(let d=0;d<n;d++)for(let p=0;p<s;p++){let x=e.cells[d][p];x.type!==0&&(u++,h.add(x.type))}let b=l.branchingPoints/(l.totalNodesVisited||1),E=Math.log10(l.totalNodesVisited+1),m=(b*10+E*1)/(Math.log2(l.solutions+1)+1),g=n*s,$=u/g,B=$<.3?Math.pow($/.3,3):1,P=h.size<=1?.4:1;m*=B*P;let M=Math.sqrt(g)/4;return m*=M,Math.max(.01,Math.min(1,m/4))}exploreSearchSpace(e,n,s,t,c,o,r,a,i,l,f){if(l.totalNodesVisited++,l.maxDepth=Math.max(l.maxDepth,t.length),l.totalNodesVisited>f)return;if(a.includes(n)){if(c===o){let u={points:t.map(h=>({x:h%(e.cols+1),y:Math.floor(h/(e.cols+1))}))};if(this.validate(e,u).isValid){let h=this.getFingerprint(e,u.points);i.has(h)||(i.add(h),l.solutions++)}}return}if(!this.canReachEndOptimized(n,s,r,a)){l.backtracks++;return}let y=[];for(let u of r[n]){if(u.isBroken||s&1n<<BigInt(u.next))continue;let h=!0;for(let b of r[n])if(b.isHexagon){let E=t.length>=2&&b.next===t[t.length-2],m=b.next===u.next;if(!E&&!m){h=!1;break}}h&&y.push(u)}y.length>1&&l.branchingPoints++;for(let u of y)if(t.push(u.next),this.exploreSearchSpace(e,u.next,s|1n<<BigInt(u.next),t,c+(u.isHexagon?1:0),o,r,a,i,l,f),t.pop(),l.totalNodesVisited>f)return}countSolutions(e,n=100){let s=e.rows,t=e.cols,c=t+1,o=(s+1)*c,r=Array.from({length:o},()=>[]),a=[],i=[],l=new Set;for(let u=0;u<=s;u++)for(let h=0;h<=t;h++){let b=u*c+h;if(e.nodes[u][h].type===1&&a.push(b),e.nodes[u][h].type===2&&i.push(b),h<t){let E=b+1,m=e.hEdges[u][h].type,g=m===3,$=m===1||m===2;r[b].push({next:E,isHexagon:g,isBroken:$}),r[E].push({next:b,isHexagon:g,isBroken:$}),g&&l.add(this.getEdgeKey({x:h,y:u},{x:h+1,y:u}))}if(u<s){let E=b+c,m=e.vEdges[u][h].type,g=m===3,$=m===1||m===2;r[b].push({next:E,isHexagon:g,isBroken:$}),r[E].push({next:b,isHexagon:g,isBroken:$}),g&&l.add(this.getEdgeKey({x:h,y:u},{x:h,y:u+1}))}}let f=new Set,y=l.size;for(let u of a)if(this.findPathsOptimized(e,u,1n<<BigInt(u),[u],0,y,r,i,f,n),f.size>=n)break;return f.size}findPathsOptimized(e,n,s,t,c,o,r,a,i,l){if(!(i.size>=l)){if(a.includes(n)){if(c===o){let f={points:t.map(y=>({x:y%(e.cols+1),y:Math.floor(y/(e.cols+1))}))};this.validate(e,f).isValid&&i.add(this.getFingerprint(e,f.points))}return}if(this.canReachEndOptimized(n,s,r,a))for(let f of r[n]){if(f.isBroken||s&1n<<BigInt(f.next))continue;let y=!0;for(let u of r[n])if(u.isHexagon){let h=t.length>=2&&u.next===t[t.length-2],b=u.next===f.next;if(!h&&!b){y=!1;break}}if(y&&(t.push(f.next),this.findPathsOptimized(e,f.next,s|1n<<BigInt(f.next),t,c+(f.isHexagon?1:0),o,r,a,i,l),t.pop(),i.size>=l))return}}}canReachEndOptimized(e,n,s,t){let c=[e],o=n,r=0;for(;r<c.length;){let a=c[r++];if(t.includes(a))return!0;for(let i of s[a])!i.isBroken&&!(o&1n<<BigInt(i.next))&&(o|=1n<<BigInt(i.next),c.push(i.next))}return!1}getFingerprint(e,n){return this.calculateRegions(e,n).map(c=>c.map(r=>e.cells[r.y][r.x]).filter(r=>r.type!==0).map(r=>`${r.type}:${r.color}`).sort().join(",")).sort().filter(c=>c.length>0).join("|")||"empty"}};var z=class{generate(e,n,s={}){let t=s.difficulty??.5,c=new A,o=null,r=-1,a=e*n>30?30:60;for(let i=0;i<a;i++){let l=this.generateOnce(e,n,s);if(!this.checkAllRequestedConstraintsPresent(l,s))continue;let f=c.calculateDifficulty(l);if(f===0)continue;let y=Math.abs(f-t);if((o===null||y<Math.abs(r-t))&&(r=f,o=l),t>.8&&f>.8||y<.05)break}return o||this.generateOnce(e,n,s)}generateOnce(e,n,s){let t=new k(e,n),c={x:0,y:e},o={x:n,y:0};t.nodes[c.y][c.x].type=1,t.nodes[o.y][o.x].type=2;let r=this.generateRandomPath(t,c,o);return this.applyConstraintsBasedOnPath(t,r,s),s.useBrokenEdges&&this.applyBrokenEdges(t,r,s),this.cleanGrid(t),t}generateRandomPath(e,n,s){let t=new Set,c=[],o=[n];new Map().set(`${n.x},${n.y}`,null);let a=i=>{if(t.add(`${i.x},${i.y}`),c.push(i),i.x===s.x&&i.y===s.y)return!0;let l=this.getValidNeighbors(e,i,t);this.shuffleArray(l);for(let f of l)if(a(f))return!0;return c.pop(),!1};return a(n),c}getValidNeighbors(e,n,s){let t=[],c=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of c){let r=n.x+o.x,a=n.y+o.y;r>=0&&r<=e.cols&&a>=0&&a<=e.rows&&(s.has(`${r},${a}`)||t.push({x:r,y:a}))}return t}applyBrokenEdges(e,n,s){let t=s.complexity??.5,c=new Set;for(let i=0;i<n.length-1;i++)c.add(this.getEdgeKey(n[i],n[i+1]));let o=[];for(let i=0;i<=e.rows;i++)for(let l=0;l<e.cols;l++){let f={x:l,y:i},y={x:l+1,y:i};c.has(this.getEdgeKey(f,y))||o.push({type:"h",r:i,c:l,p1:f,p2:y})}for(let i=0;i<e.rows;i++)for(let l=0;l<=e.cols;l++){let f={x:l,y:i},y={x:l,y:i+1};c.has(this.getEdgeKey(f,y))||o.push({type:"v",r:i,c:l,p1:f,p2:y})}this.shuffleArray(o);let r=Math.max(1,Math.floor(t*4)),a=0;for(let i of o){if(a>=r)break;let l=Math.random()<.8?1:2;l===2&&this.isAdjacentToMark(e,i)&&(l=1),i.type==="h"?e.hEdges[i.r][i.c].type=l:e.vEdges[i.r][i.c].type=l,a++}for(let i=0;i<=e.rows;i++)for(let l=0;l<=e.cols;l++){let f=[];if(l>0&&f.push({e:e.hEdges[i][l-1],type:"h",r:i,c:l-1}),l<e.cols&&f.push({e:e.hEdges[i][l],type:"h",r:i,c:l}),i>0&&f.push({e:e.vEdges[i-1][l],type:"v",r:i-1,c:l}),i<e.rows&&f.push({e:e.vEdges[i][l],type:"v",r:i,c:l}),f.every(u=>u.e.type===1||u.e.type===2)&&f.every(h=>!this.isAdjacentToMark(e,h)))for(let h of f)h.e.type=2}}cleanGrid(e){let n=[];for(let o=0;o<=e.rows;o++)for(let r=0;r<=e.cols;r++)e.nodes[o][r].type===1&&n.push({x:r,y:o});let s=new Set,t=[...n];for(let o of n)s.add(`${o.x},${o.y}`);for(;t.length>0;){let o=t.shift(),r=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let a of r)a.edge&&a.edge.type!==2&&(s.has(`${a.nx},${a.ny}`)||(s.add(`${a.nx},${a.ny}`),t.push({x:a.nx,y:a.ny})))}for(let o=0;o<=e.rows;o++)for(let r=0;r<e.cols;r++)(!s.has(`${r},${o}`)||!s.has(`${r+1},${o}`))&&(e.hEdges[o][r].type=2);for(let o=0;o<e.rows;o++)for(let r=0;r<=e.cols;r++)(!s.has(`${r},${o}`)||!s.has(`${r},${o+1}`))&&(e.vEdges[o][r].type=2);let c=this.getExternalCells(e);for(let o of c){let[r,a]=o.split(",").map(Number);e.cells[a][r].type=0}}getExternalCells(e){let n=new Set,s=[];for(let t=0;t<e.cols;t++)e.hEdges[0][t].type===2&&(n.has(`${t},0`)||(n.add(`${t},0`),s.push({x:t,y:0}))),e.hEdges[e.rows][t].type===2&&(n.has(`${t},${e.rows-1}`)||(n.add(`${t},${e.rows-1}`),s.push({x:t,y:e.rows-1})));for(let t=0;t<e.rows;t++)e.vEdges[t][0].type===2&&(n.has(`0,${t}`)||(n.add(`0,${t}`),s.push({x:0,y:t}))),e.vEdges[t][e.cols].type===2&&(n.has(`${e.cols-1},${t}`)||(n.add(`${e.cols-1},${t}`),s.push({x:e.cols-1,y:t})));for(;s.length>0;){let t=s.shift(),c=[{nx:t.x,ny:t.y-1,edge:e.hEdges[t.y][t.x]},{nx:t.x,ny:t.y+1,edge:e.hEdges[t.y+1][t.x]},{nx:t.x-1,ny:t.y,edge:e.vEdges[t.y][t.x]},{nx:t.x+1,ny:t.y,edge:e.vEdges[t.y][t.x+1]}];for(let o of c)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!n.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(n.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return n}isAdjacentToMark(e,n){if(n.type==="h"){if(n.r>0&&e.cells[n.r-1][n.c].type!==0||n.r<e.rows&&e.cells[n.r][n.c].type!==0)return!0}else if(n.c>0&&e.cells[n.r][n.c-1].type!==0||n.c<e.cols&&e.cells[n.r][n.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let n=0;n<e.rows;n++)for(let s=0;s<e.cols;s++){if(e.cells[n][s].type===0)continue;if([e.hEdges[n][s],e.hEdges[n+1][s],e.vEdges[n][s],e.vEdges[n][s+1]].filter(o=>o.type===0||o.type===3).length===0)return!0}return!1}getEdgeKey(e,n){return e.x<n.x||e.x===n.x&&e.y<n.y?`${e.x},${e.y}-${n.x},${n.y}`:`${n.x},${n.y}-${e.x},${e.y}`}applyConstraintsBasedOnPath(e,n,s){let t=s.complexity??.5,c=s.useHexagons??!0,o=s.useSquares??!0,r=s.useStars??!0,a=0,i=0,l=0;if(c){let f=s.difficulty??.5;for(let y=0;y<n.length-1;y++){let u=n[y],h=n[y+1],E=this.getValidNeighbors(e,u,new Set).length>2,m=t*.4;E&&(m=f<.4?m*1:m*.5),Math.random()<m&&(this.setEdgeHexagon(e,u,h),a++)}if(a===0&&n.length>=2){let y=Math.floor(Math.random()*(n.length-1));this.setEdgeHexagon(e,n[y],n[y+1])}}if(o||r){let f=this.calculateRegions(e,n),y=[1,2,3,4],u=Array.from({length:f.length},(h,b)=>b);this.shuffleArray(u);for(let h of u){let b=f[h],E=(s.difficulty??.5)>.7?.4:.2,m=o&&i===0||r&&l===0,g=h===u[u.length-1];if((!m||!g)&&Math.random()>E+t*.5)continue;let $=[...b];this.shuffleArray($);let B=y[Math.floor(Math.random()*y.length)];if(o&&!r&&g){let d=new Set;for(let p=0;p<e.rows;p++)for(let x=0;x<e.cols;x++)e.cells[p][x].type===1&&d.add(e.cells[p][x].color);if(d.size===1){let p=y.filter(x=>!d.has(x));p.length>0&&(B=p[Math.floor(Math.random()*p.length)])}}let P=0,M=o&&Math.random()<.5+t*.3;if(o&&i===0&&g&&(M=!0),o&&!r&&g){let d=new Set;for(let p=0;p<e.rows;p++)for(let x=0;x<e.cols;x++)e.cells[p][x].type===1&&d.add(e.cells[p][x].color);d.size<2&&i>0&&(M=!0)}if(M){let d=Math.min($.length,4);P=Math.floor(Math.random()*d),P===0&&i===0&&(P=1);for(let p=0;p<P&&$.length!==0;p++){let x=$.pop();e.cells[x.y][x.x].type=1,e.cells[x.y][x.x].color=B,i++}}if(r)for(let d of y){if($.length<1)break;let p=Math.random()<.2+t*.3;if(l===0&&g&&(p=!0),!!p){if(d===B){if(P===1&&$.length>=1){let x=$.pop();e.cells[x.y][x.x].type=2,e.cells[x.y][x.x].color=d,l++}else if(P===0&&$.length>=2)for(let x=0;x<2;x++){let v=$.pop();e.cells[v.y][v.x].type=2,e.cells[v.y][v.x].color=d,l++}}else if($.length>=2)for(let x=0;x<2;x++){let v=$.pop();e.cells[v.y][v.x].type=2,e.cells[v.y][v.x].color=d,l++}}}}if(r&&l===0){for(let h of f)if(h.length>=2){let b=[...h].filter(E=>e.cells[E.y][E.x].type===0);if(b.length>=2){let E=y[Math.floor(Math.random()*y.length)];for(let m=0;m<2;m++){let g=b.pop();e.cells[g.y][g.x].type=2,e.cells[g.y][g.x].color=E,l++}break}}}}}calculateRegions(e,n){let s=[],t=new Set,c=new Set;for(let o=0;o<n.length-1;o++){let r=n[o],a=n[o+1],i=r.x<a.x||r.y<a.y?`${r.x},${r.y}-${a.x},${a.y}`:`${a.x},${a.y}-${r.x},${r.y}`;c.add(i)}for(let o=0;o<e.rows;o++)for(let r=0;r<e.cols;r++){if(t.has(`${r},${o}`))continue;let a=[],i=[{x:r,y:o}];for(t.add(`${r},${o}`);i.length>0;){let l=i.shift();a.push(l);let f=[{dx:0,dy:-1,boundary:{p1:{x:l.x,y:l.y},p2:{x:l.x+1,y:l.y}}},{dx:0,dy:1,boundary:{p1:{x:l.x,y:l.y+1},p2:{x:l.x+1,y:l.y+1}}},{dx:-1,dy:0,boundary:{p1:{x:l.x,y:l.y},p2:{x:l.x,y:l.y+1}}},{dx:1,dy:0,boundary:{p1:{x:l.x+1,y:l.y},p2:{x:l.x+1,y:l.y+1}}}];for(let y of f){let u=l.x+y.dx,h=l.y+y.dy;if(u>=0&&u<e.cols&&h>=0&&h<e.rows&&!t.has(`${u},${h}`)){let b=y.boundary.p1.x<y.boundary.p2.x||y.boundary.p1.y<y.boundary.p2.y?`${y.boundary.p1.x},${y.boundary.p1.y}-${y.boundary.p2.x},${y.boundary.p2.y}`:`${y.boundary.p2.x},${y.boundary.p2.y}-${y.boundary.p1.x},${y.boundary.p1.y}`;!c.has(b)&&!this.isAbsentEdge(e,y.boundary.p1,y.boundary.p2)&&(t.add(`${u},${h}`),i.push({x:u,y:h}))}}}s.push(a)}return s}isAbsentEdge(e,n,s){if(n.x===s.x){let t=Math.min(n.y,s.y);return e.vEdges[t][n.x].type===2}else{let t=Math.min(n.x,s.x);return e.hEdges[n.y][t].type===2}}setEdgeHexagon(e,n,s){if(n.x===s.x){let t=Math.min(n.y,s.y);e.vEdges[t][n.x].type=3}else{let t=Math.min(n.x,s.x);e.hEdges[n.y][t].type=3}}checkAllRequestedConstraintsPresent(e,n){let s=n.useHexagons??!0,t=n.useSquares??!0,c=n.useStars??!0;if(n.useBrokenEdges??!1){let r=!1;for(let a=0;a<=e.rows;a++){for(let i=0;i<e.cols;i++)if(e.hEdges[a][i].type===1||e.hEdges[a][i].type===2){r=!0;break}if(r)break}if(!r)for(let a=0;a<e.rows;a++){for(let i=0;i<=e.cols;i++)if(e.vEdges[a][i].type===1||e.vEdges[a][i].type===2){r=!0;break}if(r)break}if(!r)return!1}if(s){let r=!1;for(let a=0;a<=e.rows;a++){for(let i=0;i<e.cols;i++)if(e.hEdges[a][i].type===3){r=!0;break}if(r)break}if(!r)for(let a=0;a<e.rows;a++){for(let i=0;i<=e.cols;i++)if(e.vEdges[a][i].type===3){r=!0;break}if(r)break}if(!r)return!1}if(t||c){let r=!1,a=!1,i=new Set;for(let l=0;l<e.rows;l++)for(let f=0;f<e.cols;f++)e.cells[l][f].type===1&&(r=!0,i.add(e.cells[l][f].color)),e.cells[l][f].type===2&&(a=!0);if(t&&!r||c&&!a||r&&!a&&i.size<2)return!1}return!this.hasIsolatedMark(e)}shuffleArray(e){for(let n=e.length-1;n>0;n--){let s=Math.floor(Math.random()*(n+1));[e[n],e[s]]=[e[s],e[n]]}}};var q=class{generator;validator;constructor(){this.generator=new z,this.validator=new A}createPuzzle(e,n,s={}){return this.generator.generate(e,n,s).export()}validateSolution(e,n){let s=k.fromData(e);return this.validator.validate(s,n)}calculateDifficulty(e){let n=k.fromData(e);return this.validator.calculateDifficulty(n)}};export{N as CellType,R as Color,O as Direction,H as EdgeType,k as Grid,V as NodeType,z as PuzzleGenerator,A as PuzzleValidator,q as WitnessCore};
//# sourceMappingURL=MiniWitness.min.js.map
