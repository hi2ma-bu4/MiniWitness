var k=(t=>(t[t.Up=0]="Up",t[t.Right=1]="Right",t[t.Down=2]="Down",t[t.Left=3]="Left",t))(k||{}),$=(n=>(n[n.None=0]="None",n[n.Square=1]="Square",n[n.Star=2]="Star",n))($||{}),v=(n=>(n[n.Normal=0]="Normal",n[n.Hexagon=1]="Hexagon",n[n.Broken=2]="Broken",n))(v||{}),S=(n=>(n[n.Normal=0]="Normal",n[n.Start=1]="Start",n[n.End=2]="End",n))(S||{}),w=(r=>(r[r.None=0]="None",r[r.Black=1]="Black",r[r.White=2]="White",r[r.Red=3]="Red",r[r.Blue=4]="Blue",r))(w||{});var g=class E{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(e,o){this.rows=e,this.cols=o,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:0}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(e){let o=new E(e.rows,e.cols);return o.cells=e.cells,o.vEdges=e.vEdges,o.hEdges=e.hEdges,o.nodes=e.nodes,o}};var m=class{validate(e,o){let n=o.points;if(n.length<2)return{isValid:!1,errorReason:"Path too short"};let t=n[0],r=n[n.length-1];if(e.nodes[t.y][t.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[r.y][r.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let a=new Set;a.add(`${t.x},${t.y}`);for(let i=0;i<n.length-1;i++){let u=n[i],c=n[i+1];if(Math.abs(u.x-c.x)+Math.abs(u.y-c.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let x=`${c.x},${c.y}`;if(a.has(x))return{isValid:!1,errorReason:"Self-intersecting path"};if(a.add(x),this.isBrokenEdge(e,u,c))return{isValid:!1,errorReason:"Passed through broken edge"}}return this.checkHexagonConstraint(e,n)?this.checkCellConstraints(e,n)?{isValid:!0}:{isValid:!1,errorReason:"Cell constraints failed"}:{isValid:!1,errorReason:"Missed hexagon constraint"}}isBrokenEdge(e,o,n){if(o.x===n.x){let t=Math.min(o.y,n.y);return e.vEdges[t][o.x].type===2}else{let t=Math.min(o.x,n.x);return e.hEdges[o.y][t].type===2}}checkHexagonConstraint(e,o){let n=new Set;for(let t=0;t<o.length-1;t++)n.add(this.getEdgeKey(o[t],o[t+1]));for(let t=0;t<=e.rows;t++)for(let r=0;r<e.cols;r++)if(e.hEdges[t][r].type===1){let a=this.getEdgeKey({x:r,y:t},{x:r+1,y:t});if(!n.has(a))return!1}for(let t=0;t<e.rows;t++)for(let r=0;r<=e.cols;r++)if(e.vEdges[t][r].type===1){let a=this.getEdgeKey({x:r,y:t},{x:r,y:t+1});if(!n.has(a))return!1}return!0}checkCellConstraints(e,o){let n=this.calculateRegions(e,o);for(let t of n){let r=new Map,a=new Set,i=new Set;for(let u of t){let c=e.cells[u.y][u.x];if(c.type===0)continue;let s=c.color;if(r.set(s,(r.get(s)||0)+1),c.type===1?i.add(s):c.type===2&&a.add(s),i.size>1)return!1}for(let u of a)if(r.get(u)!==2)return!1}return!0}calculateRegions(e,o){let n=[],t=new Set,r=new Set;for(let a=0;a<o.length-1;a++)r.add(this.getEdgeKey(o[a],o[a+1]));for(let a=0;a<e.rows;a++)for(let i=0;i<e.cols;i++){if(t.has(`${i},${a}`))continue;let u=[],c=[{x:i,y:a}];for(t.add(`${i},${a}`);c.length>0;){let s=c.shift();u.push(s);let x=[{nx:s.x,ny:s.y-1,p1:{x:s.x,y:s.y},p2:{x:s.x+1,y:s.y}},{nx:s.x,ny:s.y+1,p1:{x:s.x,y:s.y+1},p2:{x:s.x+1,y:s.y+1}},{nx:s.x-1,ny:s.y,p1:{x:s.x,y:s.y},p2:{x:s.x,y:s.y+1}},{nx:s.x+1,ny:s.y,p1:{x:s.x+1,y:s.y},p2:{x:s.x+1,y:s.y+1}}];for(let l of x)if(l.nx>=0&&l.nx<e.cols&&l.ny>=0&&l.ny<e.rows&&!t.has(`${l.nx},${l.ny}`)){let y=this.getEdgeKey(l.p1,l.p2),f=this.isBrokenEdge(e,l.p1,l.p2);!r.has(y)&&!f&&(t.add(`${l.nx},${l.ny}`),c.push({x:l.nx,y:l.ny}))}}n.push(u)}return n}getEdgeKey(e,o){return e.x<o.x||e.x===o.x&&e.y<o.y?`${e.x},${e.y}-${o.x},${o.y}`:`${o.x},${o.y}-${e.x},${e.y}`}countSolutions(e,o=100){let n=e.rows,t=e.cols,r=t+1,a=(n+1)*r,i=Array.from({length:a},()=>[]),u=[],c=[],s=new Set;for(let y=0;y<=n;y++)for(let f=0;f<=t;f++){let h=y*r+f;if(e.nodes[y][f].type===1&&u.push(h),e.nodes[y][f].type===2&&c.push(h),f<t){let p=h+1,d=e.hEdges[y][f].type===1,b=e.hEdges[y][f].type===2;i[h].push({next:p,isHexagon:d,isBroken:b}),i[p].push({next:h,isHexagon:d,isBroken:b}),d&&s.add(this.getEdgeKey({x:f,y},{x:f+1,y}))}if(y<n){let p=h+r,d=e.vEdges[y][f].type===1,b=e.vEdges[y][f].type===2;i[h].push({next:p,isHexagon:d,isBroken:b}),i[p].push({next:h,isHexagon:d,isBroken:b}),d&&s.add(this.getEdgeKey({x:f,y},{x:f,y:y+1}))}}let x=new Set,l=s.size;for(let y of u)if(this.findPathsOptimized(e,y,1n<<BigInt(y),[y],0,l,i,c,x,o),x.size>=o)break;return x.size}findPathsOptimized(e,o,n,t,r,a,i,u,c,s){if(!(c.size>=s)){if(u.includes(o)){if(r===a){let x={points:t.map(l=>({x:l%(e.cols+1),y:Math.floor(l/(e.cols+1))}))};this.validate(e,x).isValid&&c.add(this.getFingerprint(e,x.points))}return}if(this.canReachEndOptimized(o,n,i,u))for(let x of i[o]){if(x.isBroken||n&1n<<BigInt(x.next))continue;let l=!0;for(let y of i[o])if(y.isHexagon){let f=t.length>=2&&y.next===t[t.length-2],h=y.next===x.next;if(!f&&!h){l=!1;break}}if(l&&(t.push(x.next),this.findPathsOptimized(e,x.next,n|1n<<BigInt(x.next),t,r+(x.isHexagon?1:0),a,i,u,c,s),t.pop(),c.size>=s))return}}}canReachEndOptimized(e,o,n,t){let r=[e],a=o,i=0;for(;i<r.length;){let u=r[i++];if(t.includes(u))return!0;for(let c of n[u])!c.isBroken&&!(a&1n<<BigInt(c.next))&&(a|=1n<<BigInt(c.next),r.push(c.next))}return!1}getFingerprint(e,o){return this.calculateRegions(e,o).map(r=>r.map(i=>e.cells[i.y][i.x]).filter(i=>i.type!==0).map(i=>`${i.type}:${i.color}`).sort().join(",")).sort().filter(r=>r.length>0).join("|")||"empty"}};var P=class{generate(e,o,n={}){let t=n.difficulty??.5,r=new m,a=null,i=-1,u=e*o>30?30:60;for(let c=0;c<u;c++){let s=this.generateOnce(e,o,n),x=r.countSolutions(s,20);if(x===0)continue;let l=0;x===1?l+=50:l+=Math.max(0,20-x);let y=this.countConstraints(s);l+=y*5;let f=Math.min(1,l/100),h=Math.abs(f-t);if((a===null||h<Math.abs(Math.min(1,i/100)-t))&&(i=l,a=s),t>.8&&f>.9)break}return a||this.generateOnce(e,o,n)}countConstraints(e){let o=0;for(let n=0;n<e.rows;n++)for(let t=0;t<e.cols;t++)e.cells[n][t].type!==0&&o++;for(let n=0;n<=e.rows;n++)for(let t=0;t<e.cols;t++)e.hEdges[n][t].type===1&&o++;for(let n=0;n<e.rows;n++)for(let t=0;t<=e.cols;t++)e.vEdges[n][t].type===1&&o++;return o}generateOnce(e,o,n){let t=new g(e,o),r={x:0,y:e},a={x:o,y:0};t.nodes[r.y][r.x].type=1,t.nodes[a.y][a.x].type=2;let i=this.generateRandomPath(t,r,a);return this.applyConstraintsBasedOnPath(t,i,n),t}generateRandomPath(e,o,n){let t=new Set,r=[],a=[o];new Map().set(`${o.x},${o.y}`,null);let u=c=>{if(t.add(`${c.x},${c.y}`),r.push(c),c.x===n.x&&c.y===n.y)return!0;let s=this.getValidNeighbors(e,c,t);this.shuffleArray(s);for(let x of s)if(u(x))return!0;return r.pop(),!1};return u(o),r}getValidNeighbors(e,o,n){let t=[],r=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let a of r){let i=o.x+a.x,u=o.y+a.y;i>=0&&i<=e.cols&&u>=0&&u<=e.rows&&(n.has(`${i},${u}`)||t.push({x:i,y:u}))}return t}applyConstraintsBasedOnPath(e,o,n){let t=n.complexity??.5,r=n.useHexagons??!0,a=n.useSquares??!0,i=n.useStars??!0;if(r)for(let u=0;u<o.length-1;u++){let c=o[u],s=o[u+1],x=(n.difficulty??.5)>.7?t*.2:t*.5;Math.random()<x&&this.setEdgeHexagon(e,c,s)}if(a||i){let u=this.calculateRegions(e,o),c=[1,2,3,4];for(let s of u){let x=(n.difficulty??.5)>.7?.4:.2;if(Math.random()>x+t*.5)continue;let l=[...s];this.shuffleArray(l);let y=c[Math.floor(Math.random()*c.length)],f=0;if(a&&Math.random()<.5+t*.3){let h=Math.min(l.length,4);f=Math.floor(Math.random()*h);for(let p=0;p<f;p++){let d=l.pop();e.cells[d.y][d.x].type=1,e.cells[d.y][d.x].color=y}}if(i)for(let h of c){if(l.length<1)break;if(!(Math.random()>.2+t*.3)){if(h===y){if(f===1&&l.length>=1){let p=l.pop();e.cells[p.y][p.x].type=2,e.cells[p.y][p.x].color=h}else if(f===0&&l.length>=2)for(let p=0;p<2;p++){let d=l.pop();e.cells[d.y][d.x].type=2,e.cells[d.y][d.x].color=h}}else if(l.length>=2)for(let p=0;p<2;p++){let d=l.pop();e.cells[d.y][d.x].type=2,e.cells[d.y][d.x].color=h}}}}}}calculateRegions(e,o){let n=[],t=new Set,r=new Set;for(let a=0;a<o.length-1;a++){let i=o[a],u=o[a+1],c=i.x<u.x||i.y<u.y?`${i.x},${i.y}-${u.x},${u.y}`:`${u.x},${u.y}-${i.x},${i.y}`;r.add(c)}for(let a=0;a<e.rows;a++)for(let i=0;i<e.cols;i++){if(t.has(`${i},${a}`))continue;let u=[],c=[{x:i,y:a}];for(t.add(`${i},${a}`);c.length>0;){let s=c.shift();u.push(s);let x=[{dx:0,dy:-1,boundary:{p1:{x:s.x,y:s.y},p2:{x:s.x+1,y:s.y}}},{dx:0,dy:1,boundary:{p1:{x:s.x,y:s.y+1},p2:{x:s.x+1,y:s.y+1}}},{dx:-1,dy:0,boundary:{p1:{x:s.x,y:s.y},p2:{x:s.x,y:s.y+1}}},{dx:1,dy:0,boundary:{p1:{x:s.x+1,y:s.y},p2:{x:s.x+1,y:s.y+1}}}];for(let l of x){let y=s.x+l.dx,f=s.y+l.dy;if(y>=0&&y<e.cols&&f>=0&&f<e.rows&&!t.has(`${y},${f}`)){let h=l.boundary.p1.x<l.boundary.p2.x||l.boundary.p1.y<l.boundary.p2.y?`${l.boundary.p1.x},${l.boundary.p1.y}-${l.boundary.p2.x},${l.boundary.p2.y}`:`${l.boundary.p2.x},${l.boundary.p2.y}-${l.boundary.p1.x},${l.boundary.p1.y}`;r.has(h)||(t.add(`${y},${f}`),c.push({x:y,y:f}))}}}n.push(u)}return n}setEdgeHexagon(e,o,n){if(o.x===n.x){let t=Math.min(o.y,n.y);e.vEdges[t][o.x].type=1}else{let t=Math.min(o.x,n.x);e.hEdges[o.y][t].type=1}}shuffleArray(e){for(let o=e.length-1;o>0;o--){let n=Math.floor(Math.random()*(o+1));[e[o],e[n]]=[e[n],e[o]]}}};var z=class{generator;validator;constructor(){this.generator=new P,this.validator=new m}createPuzzle(e,o,n={}){return this.generator.generate(e,o,n).export()}validateSolution(e,o){let n=g.fromData(e);return this.validator.validate(n,o)}};export{$ as CellType,w as Color,k as Direction,v as EdgeType,g as Grid,S as NodeType,P as PuzzleGenerator,m as PuzzleValidator,z as WitnessCore};
//# sourceMappingURL=MiniWitness.min.js.map
