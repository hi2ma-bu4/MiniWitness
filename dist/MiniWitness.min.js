var I=(t=>(t[t.Up=0]="Up",t[t.Right=1]="Right",t[t.Down=2]="Down",t[t.Left=3]="Left",t))(I||{}),V=(r=>(r[r.None=0]="None",r[r.Square=1]="Square",r[r.Star=2]="Star",r[r.Tetris=3]="Tetris",r[r.TetrisRotated=4]="TetrisRotated",r))(V||{}),q=(t=>(t[t.Normal=0]="Normal",t[t.Broken=1]="Broken",t[t.Absent=2]="Absent",t[t.Hexagon=3]="Hexagon",t))(q||{}),O=(s=>(s[s.Normal=0]="Normal",s[s.Start=1]="Start",s[s.End=2]="End",s))(O||{}),D=(r=>(r[r.None=0]="None",r[r.Black=1]="Black",r[r.White=2]="White",r[r.Red=3]="Red",r[r.Blue=4]="Blue",r))(D||{});var R=class T{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(e,n){this.rows=e,this.cols=n,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:0}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(e){let n=new T(e.rows,e.cols);return n.cells=e.cells,n.vEdges=e.vEdges,n.hEdges=e.hEdges,n.nodes=e.nodes,n}};var z=class{validate(e,n){let s=n.points;if(s.length<2)return{isValid:!1,errorReason:"Path too short"};let t=s[0],r=s[s.length-1];if(e.nodes[t.y][t.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[r.y][r.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let o=new Set;o.add(`${t.x},${t.y}`);for(let i=0;i<s.length-1;i++){let f=s[i],l=s[i+1];if(Math.abs(f.x-l.x)+Math.abs(f.y-l.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let c=`${l.x},${l.y}`;if(o.has(c))return{isValid:!1,errorReason:"Self-intersecting path"};if(o.add(c),this.isBrokenEdge(e,f,l))return{isValid:!1,errorReason:"Passed through broken edge"}}return this.checkHexagonConstraint(e,s)?this.checkCellConstraints(e,s)?{isValid:!0}:{isValid:!1,errorReason:"Cell constraints failed"}:{isValid:!1,errorReason:"Missed hexagon constraint"}}isBrokenEdge(e,n,s){let t;if(n.x===s.x){let r=Math.min(n.y,s.y);t=e.vEdges[r][n.x].type}else{let r=Math.min(n.x,s.x);t=e.hEdges[n.y][r].type}return t===1||t===2}isAbsentEdge(e,n,s){if(n.x===s.x){let t=Math.min(n.y,s.y);return e.vEdges[t][n.x].type===2}else{let t=Math.min(n.x,s.x);return e.hEdges[n.y][t].type===2}}checkHexagonConstraint(e,n){let s=new Set;for(let t=0;t<n.length-1;t++)s.add(this.getEdgeKey(n[t],n[t+1]));for(let t=0;t<=e.rows;t++)for(let r=0;r<e.cols;r++)if(e.hEdges[t][r].type===3){let o=this.getEdgeKey({x:r,y:t},{x:r+1,y:t});if(!s.has(o))return!1}for(let t=0;t<e.rows;t++)for(let r=0;r<=e.cols;r++)if(e.vEdges[t][r].type===3){let o=this.getEdgeKey({x:r,y:t},{x:r,y:t+1});if(!s.has(o))return!1}return!0}checkCellConstraints(e,n){let s=this.calculateRegions(e,n);for(let t of s){let r=new Map,o=new Set,i=new Set,f=[];for(let l of t){let a=e.cells[l.y][l.x];if(a.type===0)continue;let c=a.color;if(r.set(c,(r.get(c)||0)+1),a.type===1?i.add(c):a.type===2?o.add(c):(a.type===3||a.type===4)&&a.shape&&f.push({shape:a.shape,rotatable:a.type===4}),i.size>1)return!1}for(let l of o)if(r.get(l)!==2)return!1;if(f.length>0&&!this.checkTetrisConstraint(t,f))return!1}return!0}checkTetrisConstraint(e,n){if(n.reduce((c,h)=>c+this.getShapeArea(h.shape),0)!==e.length)return!1;let t=Math.min(...e.map(c=>c.x)),r=Math.min(...e.map(c=>c.y)),o=Math.max(...e.map(c=>c.x)),i=Math.max(...e.map(c=>c.y)),f=o-t+1,l=i-r+1,a=Array.from({length:l},()=>Array(f).fill(!1));for(let c of e)a[c.y-r][c.x-t]=!0;return this.canTile(a,n)}getShapeArea(e){let n=0;for(let s of e)for(let t of s)t&&n++;return n}canTile(e,n){let s=-1,t=-1;for(let r=0;r<e.length;r++){for(let o=0;o<e[0].length;o++)if(e[r][o]){s=r,t=o;break}if(s!==-1)break}if(s===-1)return n.length===0;if(n.length===0)return!1;for(let r=0;r<n.length;r++){let o=n[r],i=[...n.slice(0,r),...n.slice(r+1)],f=o.rotatable?this.getAllRotations(o.shape):[o.shape];for(let l of f){let a=[];for(let c=0;c<l.length;c++)for(let h=0;h<l[0].length;h++)l[c][h]&&a.push({r:c,c:h});for(let c of a){let h=s-c.r,u=t-c.c;if(this.canPlace(e,l,h,u)){if(this.placePiece(e,l,h,u,!1),this.canTile(e,i))return!0;this.placePiece(e,l,h,u,!0)}}}}return!1}canPlace(e,n,s,t){for(let r=0;r<n.length;r++)for(let o=0;o<n[0].length;o++)if(n[r][o]){let i=s+r,f=t+o;if(i<0||i>=e.length||f<0||f>=e[0].length||!e[i][f])return!1}return!0}placePiece(e,n,s,t,r){for(let o=0;o<n.length;o++)for(let i=0;i<n[0].length;i++)n[o][i]&&(e[s+o][t+i]=r)}getAllRotations(e){let n=[],s=new Set,t=e;for(let r=0;r<4;r++){let o=JSON.stringify(t);s.has(o)||(n.push(t),s.add(o)),t=this.rotate90(t)}return n}rotate90(e){let n=e.length,s=e[0].length,t=Array.from({length:s},()=>Array(n).fill(0));for(let r=0;r<n;r++)for(let o=0;o<s;o++)t[o][n-1-r]=e[r][o];return t}calculateRegions(e,n){let s=[],t=new Set,r=new Set;for(let i=0;i<n.length-1;i++)r.add(this.getEdgeKey(n[i],n[i+1]));let o=this.getExternalCells(e);for(let i=0;i<e.rows;i++)for(let f=0;f<e.cols;f++){if(t.has(`${f},${i}`)||o.has(`${f},${i}`))continue;let l=[],a=[{x:f,y:i}];for(t.add(`${f},${i}`);a.length>0;){let c=a.shift();l.push(c);let h=[{nx:c.x,ny:c.y-1,p1:{x:c.x,y:c.y},p2:{x:c.x+1,y:c.y}},{nx:c.x,ny:c.y+1,p1:{x:c.x,y:c.y+1},p2:{x:c.x+1,y:c.y+1}},{nx:c.x-1,ny:c.y,p1:{x:c.x,y:c.y},p2:{x:c.x,y:c.y+1}},{nx:c.x+1,ny:c.y,p1:{x:c.x+1,y:c.y},p2:{x:c.x+1,y:c.y+1}}];for(let u of h)if(u.nx>=0&&u.nx<e.cols&&u.ny>=0&&u.ny<e.rows){let y=`${u.nx},${u.ny}`;if(!t.has(y)&&!o.has(y)){let x=this.getEdgeKey(u.p1,u.p2),b=this.isAbsentEdge(e,u.p1,u.p2);!r.has(x)&&!b&&(t.add(y),a.push({x:u.nx,y:u.ny}))}}}s.push(l)}return s}getExternalCells(e){let n=new Set,s=[];for(let t=0;t<e.cols;t++)e.hEdges[0][t].type===2&&(n.has(`${t},0`)||(n.add(`${t},0`),s.push({x:t,y:0}))),e.hEdges[e.rows][t].type===2&&(n.has(`${t},${e.rows-1}`)||(n.add(`${t},${e.rows-1}`),s.push({x:t,y:e.rows-1})));for(let t=0;t<e.rows;t++)e.vEdges[t][0].type===2&&(n.has(`0,${t}`)||(n.add(`0,${t}`),s.push({x:0,y:t}))),e.vEdges[t][e.cols].type===2&&(n.has(`${e.cols-1},${t}`)||(n.add(`${e.cols-1},${t}`),s.push({x:e.cols-1,y:t})));for(;s.length>0;){let t=s.shift(),r=[{nx:t.x,ny:t.y-1,edge:e.hEdges[t.y][t.x]},{nx:t.x,ny:t.y+1,edge:e.hEdges[t.y+1][t.x]},{nx:t.x-1,ny:t.y,edge:e.vEdges[t.y][t.x]},{nx:t.x+1,ny:t.y,edge:e.vEdges[t.y][t.x+1]}];for(let o of r)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!n.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(n.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return n}getEdgeKey(e,n){return e.x<n.x||e.x===n.x&&e.y<n.y?`${e.x},${e.y}-${n.x},${n.y}`:`${n.x},${n.y}-${e.x},${e.y}`}calculateDifficulty(e){let n=e.rows,s=e.cols,t=s+1,r=(n+1)*t,o=Array.from({length:r},()=>[]),i=[],f=[],l=new Set;for(let v=0;v<=n;v++)for(let S=0;S<=s;S++){let p=v*t+S;if(e.nodes[v][S].type===1&&i.push(p),e.nodes[v][S].type===2&&f.push(p),S<s){let g=p+1,d=e.hEdges[v][S].type,k=d===3,m=d===1||d===2;o[p].push({next:g,isHexagon:k,isBroken:m}),o[g].push({next:p,isHexagon:k,isBroken:m}),k&&l.add(this.getEdgeKey({x:S,y:v},{x:S+1,y:v}))}if(v<n){let g=p+t,d=e.vEdges[v][S].type,k=d===3,m=d===1||d===2;o[p].push({next:g,isHexagon:k,isBroken:m}),o[g].push({next:p,isHexagon:k,isBroken:m}),k&&l.add(this.getEdgeKey({x:S,y:v},{x:S,y:v+1}))}}let a={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},c=l.size,h=new Set;for(let v of i)this.exploreSearchSpace(e,v,1n<<BigInt(v),[v],0,c,o,f,h,a,500);if(a.solutions===0)return 0;let u=l.size,y=new Set;l.size>0&&y.add(999);let x=0,b=0;for(let v=0;v<n;v++)for(let S=0;S<s;S++){let p=e.cells[v][S];p.type!==0&&(u++,y.add(p.type),p.type===3?x++:p.type===4&&(x++,b++))}let P=a.branchingPoints/(a.totalNodesVisited||1),$=Math.log10(a.totalNodesVisited+1),E=(P*10+$*1)/(Math.log2(a.solutions+1)+1);x>0&&(E+=b*.5,E+=(x-b)*.2);let B=n*s,M=u/B,w=M<.3?Math.pow(M/.3,3):1,A=y.size<=1?.4:1;E*=w*A;let H=Math.sqrt(B)/4;return E*=H,Math.max(.01,Math.min(1,E/4))}exploreSearchSpace(e,n,s,t,r,o,i,f,l,a,c){if(a.totalNodesVisited++,a.maxDepth=Math.max(a.maxDepth,t.length),a.totalNodesVisited>c)return;if(f.includes(n)){if(r===o){let u={points:t.map(y=>({x:y%(e.cols+1),y:Math.floor(y/(e.cols+1))}))};if(this.validate(e,u).isValid){let y=this.getFingerprint(e,u.points);l.has(y)||(l.add(y),a.solutions++)}}return}if(!this.canReachEndOptimized(n,s,i,f)){a.backtracks++;return}let h=[];for(let u of i[n]){if(u.isBroken||s&1n<<BigInt(u.next))continue;let y=!0;for(let x of i[n])if(x.isHexagon){let b=t.length>=2&&x.next===t[t.length-2],P=x.next===u.next;if(!b&&!P){y=!1;break}}y&&h.push(u)}h.length>1&&a.branchingPoints++;for(let u of h)if(t.push(u.next),this.exploreSearchSpace(e,u.next,s|1n<<BigInt(u.next),t,r+(u.isHexagon?1:0),o,i,f,l,a,c),t.pop(),a.totalNodesVisited>c)return}countSolutions(e,n=100){let s=e.rows,t=e.cols,r=t+1,o=(s+1)*r,i=Array.from({length:o},()=>[]),f=[],l=[],a=new Set;for(let u=0;u<=s;u++)for(let y=0;y<=t;y++){let x=u*r+y;if(e.nodes[u][y].type===1&&f.push(x),e.nodes[u][y].type===2&&l.push(x),y<t){let b=x+1,P=e.hEdges[u][y].type,$=P===3,E=P===1||P===2;i[x].push({next:b,isHexagon:$,isBroken:E}),i[b].push({next:x,isHexagon:$,isBroken:E}),$&&a.add(this.getEdgeKey({x:y,y:u},{x:y+1,y:u}))}if(u<s){let b=x+r,P=e.vEdges[u][y].type,$=P===3,E=P===1||P===2;i[x].push({next:b,isHexagon:$,isBroken:E}),i[b].push({next:x,isHexagon:$,isBroken:E}),$&&a.add(this.getEdgeKey({x:y,y:u},{x:y,y:u+1}))}}let c=new Set,h=a.size;for(let u of f)if(this.findPathsOptimized(e,u,1n<<BigInt(u),[u],0,h,i,l,c,n),c.size>=n)break;return c.size}findPathsOptimized(e,n,s,t,r,o,i,f,l,a){if(!(l.size>=a)){if(f.includes(n)){if(r===o){let c={points:t.map(h=>({x:h%(e.cols+1),y:Math.floor(h/(e.cols+1))}))};this.validate(e,c).isValid&&l.add(this.getFingerprint(e,c.points))}return}if(this.canReachEndOptimized(n,s,i,f))for(let c of i[n]){if(c.isBroken||s&1n<<BigInt(c.next))continue;let h=!0;for(let u of i[n])if(u.isHexagon){let y=t.length>=2&&u.next===t[t.length-2],x=u.next===c.next;if(!y&&!x){h=!1;break}}if(h&&(t.push(c.next),this.findPathsOptimized(e,c.next,s|1n<<BigInt(c.next),t,r+(c.isHexagon?1:0),o,i,f,l,a),t.pop(),l.size>=a))return}}}canReachEndOptimized(e,n,s,t){let r=[e],o=n,i=0;for(;i<r.length;){let f=r[i++];if(t.includes(f))return!0;for(let l of s[f])!l.isBroken&&!(o&1n<<BigInt(l.next))&&(o|=1n<<BigInt(l.next),r.push(l.next))}return!1}getFingerprint(e,n){return this.calculateRegions(e,n).map(r=>r.map(i=>e.cells[i.y][i.x]).filter(i=>i.type!==0).map(i=>`${i.type}:${i.color}`).sort().join(",")).sort().filter(r=>r.length>0).join("|")||"empty"}};var G=class{generate(e,n,s={}){let t=s.difficulty??.5,r=new z,o=null,i=-1,f=e*n>30?30:60;for(let l=0;l<f;l++){let a=this.generateOnce(e,n,s);if(!this.checkAllRequestedConstraintsPresent(a,s))continue;let c=r.calculateDifficulty(a);if(c===0)continue;let h=Math.abs(c-t);if((o===null||h<Math.abs(i-t))&&(i=c,o=a),t>.8&&c>.8||h<.05)break}return o||this.generateOnce(e,n,s)}generateOnce(e,n,s){let t=new R(e,n),r={x:0,y:e},o={x:n,y:0};t.nodes[r.y][r.x].type=1,t.nodes[o.y][o.x].type=2;let i=this.generateRandomPath(t,r,o);return this.applyConstraintsBasedOnPath(t,i,s),s.useBrokenEdges&&this.applyBrokenEdges(t,i,s),this.cleanGrid(t),t}generateRandomPath(e,n,s){let t=new Set,r=[],o=[n];new Map().set(`${n.x},${n.y}`,null);let f=l=>{if(t.add(`${l.x},${l.y}`),r.push(l),l.x===s.x&&l.y===s.y)return!0;let a=this.getValidNeighbors(e,l,t);this.shuffleArray(a);for(let c of a)if(f(c))return!0;return r.pop(),!1};return f(n),r}getValidNeighbors(e,n,s){let t=[],r=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of r){let i=n.x+o.x,f=n.y+o.y;i>=0&&i<=e.cols&&f>=0&&f<=e.rows&&(s.has(`${i},${f}`)||t.push({x:i,y:f}))}return t}applyBrokenEdges(e,n,s){let t=s.complexity??.5,r=new Set;for(let l=0;l<n.length-1;l++)r.add(this.getEdgeKey(n[l],n[l+1]));let o=[];for(let l=0;l<=e.rows;l++)for(let a=0;a<e.cols;a++){let c={x:a,y:l},h={x:a+1,y:l};r.has(this.getEdgeKey(c,h))||o.push({type:"h",r:l,c:a,p1:c,p2:h})}for(let l=0;l<e.rows;l++)for(let a=0;a<=e.cols;a++){let c={x:a,y:l},h={x:a,y:l+1};r.has(this.getEdgeKey(c,h))||o.push({type:"v",r:l,c:a,p1:c,p2:h})}this.shuffleArray(o);let i=Math.max(1,Math.floor(t*4)),f=0;for(let l of o){if(f>=i)break;let a=Math.random()<.8?1:2;a===2&&this.isAdjacentToMark(e,l)&&(a=1),l.type==="h"?e.hEdges[l.r][l.c].type=a:e.vEdges[l.r][l.c].type=a,f++}for(let l=0;l<=e.rows;l++)for(let a=0;a<=e.cols;a++){let c=[];if(a>0&&c.push({e:e.hEdges[l][a-1],type:"h",r:l,c:a-1}),a<e.cols&&c.push({e:e.hEdges[l][a],type:"h",r:l,c:a}),l>0&&c.push({e:e.vEdges[l-1][a],type:"v",r:l-1,c:a}),l<e.rows&&c.push({e:e.vEdges[l][a],type:"v",r:l,c:a}),c.every(u=>u.e.type===1||u.e.type===2)&&c.every(y=>!this.isAdjacentToMark(e,y)))for(let y of c)y.e.type=2}}cleanGrid(e){let n=[];for(let o=0;o<=e.rows;o++)for(let i=0;i<=e.cols;i++)e.nodes[o][i].type===1&&n.push({x:i,y:o});let s=new Set,t=[...n];for(let o of n)s.add(`${o.x},${o.y}`);for(;t.length>0;){let o=t.shift(),i=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let f of i)f.edge&&f.edge.type!==2&&(s.has(`${f.nx},${f.ny}`)||(s.add(`${f.nx},${f.ny}`),t.push({x:f.nx,y:f.ny})))}for(let o=0;o<=e.rows;o++)for(let i=0;i<e.cols;i++)(!s.has(`${i},${o}`)||!s.has(`${i+1},${o}`))&&(e.hEdges[o][i].type=2);for(let o=0;o<e.rows;o++)for(let i=0;i<=e.cols;i++)(!s.has(`${i},${o}`)||!s.has(`${i},${o+1}`))&&(e.vEdges[o][i].type=2);let r=this.getExternalCells(e);for(let o of r){let[i,f]=o.split(",").map(Number);e.cells[f][i].type=0}}getExternalCells(e){let n=new Set,s=[];for(let t=0;t<e.cols;t++)e.hEdges[0][t].type===2&&(n.has(`${t},0`)||(n.add(`${t},0`),s.push({x:t,y:0}))),e.hEdges[e.rows][t].type===2&&(n.has(`${t},${e.rows-1}`)||(n.add(`${t},${e.rows-1}`),s.push({x:t,y:e.rows-1})));for(let t=0;t<e.rows;t++)e.vEdges[t][0].type===2&&(n.has(`0,${t}`)||(n.add(`0,${t}`),s.push({x:0,y:t}))),e.vEdges[t][e.cols].type===2&&(n.has(`${e.cols-1},${t}`)||(n.add(`${e.cols-1},${t}`),s.push({x:e.cols-1,y:t})));for(;s.length>0;){let t=s.shift(),r=[{nx:t.x,ny:t.y-1,edge:e.hEdges[t.y][t.x]},{nx:t.x,ny:t.y+1,edge:e.hEdges[t.y+1][t.x]},{nx:t.x-1,ny:t.y,edge:e.vEdges[t.y][t.x]},{nx:t.x+1,ny:t.y,edge:e.vEdges[t.y][t.x+1]}];for(let o of r)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!n.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(n.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return n}isAdjacentToMark(e,n){if(n.type==="h"){if(n.r>0&&e.cells[n.r-1][n.c].type!==0||n.r<e.rows&&e.cells[n.r][n.c].type!==0)return!0}else if(n.c>0&&e.cells[n.r][n.c-1].type!==0||n.c<e.cols&&e.cells[n.r][n.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let n=0;n<e.rows;n++)for(let s=0;s<e.cols;s++){if(e.cells[n][s].type===0)continue;if([e.hEdges[n][s],e.hEdges[n+1][s],e.vEdges[n][s],e.vEdges[n][s+1]].filter(o=>o.type===0||o.type===3).length===0)return!0}return!1}getEdgeKey(e,n){return e.x<n.x||e.x===n.x&&e.y<n.y?`${e.x},${e.y}-${n.x},${n.y}`:`${n.x},${n.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1],[1,0]],[[0,1],[1,0]],[[1,1,1,1]],[[1,1],[1,1]],[[1,1,1],[0,1,0]],[[1,1,0],[0,1,1]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,n,s){let t=s.complexity??.5,r=s.useHexagons??!0,o=s.useSquares??!0,i=s.useStars??!0,f=s.useTetris??!1,l=0,a=0,c=0,h=0,u=0,y=Math.floor(e.rows*e.cols*.45);if(r){let x=s.difficulty??.5;for(let b=0;b<n.length-1;b++){let P=n[b],$=n[b+1],B=this.getValidNeighbors(e,P,new Set).length>2,M=t*.4;B&&(M=x<.4?M*1:M*.5),Math.random()<M&&(this.setEdgeHexagon(e,P,$),l++)}if(l===0&&n.length>=2){let b=Math.floor(Math.random()*(n.length-1));this.setEdgeHexagon(e,n[b],n[b+1])}}if(o||i){let x=this.calculateRegions(e,n),b=[1,2,3,4],P=Array.from({length:x.length},($,E)=>E);this.shuffleArray(P);for(let $ of P){let E=x[$],B=(s.difficulty??.5)>.7?.4:.2,M=o&&a===0||i&&c===0||f&&h===0,w=$===P[P.length-1];if((!M||!w)&&Math.random()>B+t*.5)continue;let A=[...E];this.shuffleArray(A);let H=b[Math.floor(Math.random()*b.length)];if(o&&!i&&w){let p=new Set;for(let g=0;g<e.rows;g++)for(let d=0;d<e.cols;d++)e.cells[g][d].type===1&&p.add(e.cells[g][d].color);if(p.size===1){let g=b.filter(d=>!p.has(d));g.length>0&&(H=g[Math.floor(Math.random()*g.length)])}}let v=0,S=o&&Math.random()<.5+t*.3;if(o&&a===0&&w&&(S=!0),o&&!i&&w){let p=new Set;for(let g=0;g<e.rows;g++)for(let d=0;d<e.cols;d++)e.cells[g][d].type===1&&p.add(e.cells[g][d].color);p.size<2&&a>0&&(S=!0)}if(S){let p=Math.min(A.length,4);v=Math.floor(Math.random()*p),v===0&&a===0&&(v=1);for(let g=0;g<v&&A.length!==0;g++){let d=A.pop();e.cells[d.y][d.x].type=1,e.cells[d.y][d.x].color=H,a++}}if(f&&u<y){let p=Math.random()<.1+t*.4;h===0&&w&&(p=!0);let g=h===0&&w?6:4;if(p&&A.length>0&&E.length<=g*4&&u+E.length<=y){let d=this.generateTiling(E,g,s);if(d){for(let k of d){if(A.length===0)break;let m=A.pop();e.cells[m.y][m.x].type=k.isRotated?4:3,e.cells[m.y][m.x].shape=k.isRotated?k.displayShape:k.shape,e.cells[m.y][m.x].color=0,h++}u+=E.length}}}if(i)for(let p of b){if(A.length<1)break;let g=Math.random()<.2+t*.3;if(c===0&&w&&(g=!0),!g)continue;let d=E.map(m=>e.cells[m.y][m.x]).filter(m=>m.type===3||m.type===4),k=0;if(p===H&&(k+=v),k+=d.filter(m=>m.color===p).length,k===1){let m=A.pop();e.cells[m.y][m.x].type=2,e.cells[m.y][m.x].color=p,c++}else if(k===0){let m=d.filter(N=>N.color===0);if(p!==4&&Math.random()<.5&&m.length>0){let N=m[Math.floor(Math.random()*m.length)];N.color=p;let C=A.pop();e.cells[C.y][C.x].type=2,e.cells[C.y][C.x].color=p,c++}else if(A.length>=2)for(let N=0;N<2;N++){let C=A.pop();e.cells[C.y][C.x].type=2,e.cells[C.y][C.x].color=p,c++}}}}if(i&&c===0){for(let $ of x)if($.length>=2){let E=[...$].filter(B=>e.cells[B.y][B.x].type===0);if(E.length>=2){let B=b[Math.floor(Math.random()*b.length)];for(let M=0;M<2;M++){let w=E.pop();e.cells[w.y][w.x].type=2,e.cells[w.y][w.x].color=B,c++}break}}}}}calculateRegions(e,n){let s=[],t=new Set,r=new Set;for(let o=0;o<n.length-1;o++){let i=n[o],f=n[o+1],l=i.x<f.x||i.y<f.y?`${i.x},${i.y}-${f.x},${f.y}`:`${f.x},${f.y}-${i.x},${i.y}`;r.add(l)}for(let o=0;o<e.rows;o++)for(let i=0;i<e.cols;i++){if(t.has(`${i},${o}`))continue;let f=[],l=[{x:i,y:o}];for(t.add(`${i},${o}`);l.length>0;){let a=l.shift();f.push(a);let c=[{dx:0,dy:-1,boundary:{p1:{x:a.x,y:a.y},p2:{x:a.x+1,y:a.y}}},{dx:0,dy:1,boundary:{p1:{x:a.x,y:a.y+1},p2:{x:a.x+1,y:a.y+1}}},{dx:-1,dy:0,boundary:{p1:{x:a.x,y:a.y},p2:{x:a.x,y:a.y+1}}},{dx:1,dy:0,boundary:{p1:{x:a.x+1,y:a.y},p2:{x:a.x+1,y:a.y+1}}}];for(let h of c){let u=a.x+h.dx,y=a.y+h.dy;if(u>=0&&u<e.cols&&y>=0&&y<e.rows&&!t.has(`${u},${y}`)){let x=h.boundary.p1.x<h.boundary.p2.x||h.boundary.p1.y<h.boundary.p2.y?`${h.boundary.p1.x},${h.boundary.p1.y}-${h.boundary.p2.x},${h.boundary.p2.y}`:`${h.boundary.p2.x},${h.boundary.p2.y}-${h.boundary.p1.x},${h.boundary.p1.y}`;!r.has(x)&&!this.isAbsentEdge(e,h.boundary.p1,h.boundary.p2)&&(t.add(`${u},${y}`),l.push({x:u,y}))}}}s.push(f)}return s}isAbsentEdge(e,n,s){if(n.x===s.x){let t=Math.min(n.y,s.y);return e.vEdges[t][n.x].type===2}else{let t=Math.min(n.x,s.x);return e.hEdges[n.y][t].type===2}}setEdgeHexagon(e,n,s){if(n.x===s.x){let t=Math.min(n.y,s.y);e.vEdges[t][n.x].type=3}else{let t=Math.min(n.x,s.x);e.hEdges[n.y][t].type=3}}checkAllRequestedConstraintsPresent(e,n){let s=n.useHexagons??!0,t=n.useSquares??!0,r=n.useStars??!0,o=n.useTetris??!1;if(n.useBrokenEdges??!1){let f=!1;for(let l=0;l<=e.rows;l++){for(let a=0;a<e.cols;a++)if(e.hEdges[l][a].type===1||e.hEdges[l][a].type===2){f=!0;break}if(f)break}if(!f)for(let l=0;l<e.rows;l++){for(let a=0;a<=e.cols;a++)if(e.vEdges[l][a].type===1||e.vEdges[l][a].type===2){f=!0;break}if(f)break}if(!f)return!1}if(s){let f=!1;for(let l=0;l<=e.rows;l++){for(let a=0;a<e.cols;a++)if(e.hEdges[l][a].type===3){f=!0;break}if(f)break}if(!f)for(let l=0;l<e.rows;l++){for(let a=0;a<=e.cols;a++)if(e.vEdges[l][a].type===3){f=!0;break}if(f)break}if(!f)return!1}if(t||r||o){let f=!1,l=!1,a=!1,c=new Set;for(let h=0;h<e.rows;h++)for(let u=0;u<e.cols;u++)e.cells[h][u].type===1&&(f=!0,c.add(e.cells[h][u].color)),e.cells[h][u].type===2&&(l=!0),(e.cells[h][u].type===3||e.cells[h][u].type===4)&&(a=!0);if(t&&!f||r&&!l||o&&!a||f&&!l&&c.size<2)return!1}return!this.hasIsolatedMark(e)}generateTiling(e,n,s){let t=Math.min(...e.map(c=>c.x)),r=Math.min(...e.map(c=>c.y)),o=Math.max(...e.map(c=>c.x)),i=Math.max(...e.map(c=>c.y)),f=o-t+1,l=i-r+1,a=Array.from({length:l},()=>Array(f).fill(!1));for(let c of e)a[c.y-r][c.x-t]=!0;return this.tilingDfs(a,[],n,s)}tilingDfs(e,n,s,t){let r=-1,o=-1;for(let l=0;l<e.length;l++){for(let a=0;a<e[0].length;a++)if(e[l][a]){r=l,o=a;break}if(r!==-1)break}if(r===-1)return n;if(n.length>=s)return null;let i=t.difficulty??.5,f=[...this.TETRIS_SHAPES];this.shuffleArray(f),i>.6&&f.sort((l,a)=>{let c=this.getShapeArea(l),h=this.getShapeArea(a);return c<=2&&h>2?1:h<=2&&c>2?-1:0});for(let l of f){let a=this.isRotationallyInvariant(l),c=a?[l]:this.getAllRotations(l);this.shuffleArray(c);for(let h of c){let u=[];for(let y=0;y<h.length;y++)for(let x=0;x<h[0].length;x++)h[y][x]&&u.push({r:y,c:x});for(let y of u){let x=r-y.r,b=o-y.c;if(this.canPlace(e,h,x,b)){this.placePiece(e,h,x,b,!1);let P=.3+i*.6,$=!a&&Math.random()<P,E=this.tilingDfs(e,[...n,{shape:h,displayShape:l,isRotated:$}],s,t);if(E)return E;this.placePiece(e,h,x,b,!0)}}}}return null}getShapeArea(e){let n=0;for(let s of e)for(let t of s)t&&n++;return n}isRotationallyInvariant(e){let n=this.getShapeArea(e);return n===1||n===4&&e.length===2&&e[0].length===2}getAllRotations(e){let n=[],s=new Set,t=e;for(let r=0;r<4;r++){let o=JSON.stringify(t);s.has(o)||(n.push(t),s.add(o)),t=this.rotate90(t)}return n}rotate90(e){let n=e.length,s=e[0].length,t=Array.from({length:s},()=>Array(n).fill(0));for(let r=0;r<n;r++)for(let o=0;o<s;o++)t[o][n-1-r]=e[r][o];return t}canPlace(e,n,s,t){for(let r=0;r<n.length;r++)for(let o=0;o<n[0].length;o++)if(n[r][o]){let i=s+r,f=t+o;if(i<0||i>=e.length||f<0||f>=e[0].length||!e[i][f])return!1}return!0}placePiece(e,n,s,t,r){for(let o=0;o<n.length;o++)for(let i=0;i<n[0].length;i++)n[o][i]&&(e[s+o][t+i]=r)}shuffleArray(e){for(let n=e.length-1;n>0;n--){let s=Math.floor(Math.random()*(n+1));[e[n],e[s]]=[e[s],e[n]]}}};var K=class{generator;validator;constructor(){this.generator=new G,this.validator=new z}createPuzzle(e,n,s={}){return this.generator.generate(e,n,s).export()}validateSolution(e,n){let s=R.fromData(e);return this.validator.validate(s,n)}calculateDifficulty(e){let n=R.fromData(e);return this.validator.calculateDifficulty(n)}};export{V as CellType,D as Color,I as Direction,q as EdgeType,R as Grid,O as NodeType,G as PuzzleGenerator,z as PuzzleValidator,K as WitnessCore};
//# sourceMappingURL=MiniWitness.min.js.map
