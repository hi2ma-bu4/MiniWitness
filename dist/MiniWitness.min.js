var D=(t=>(t[t.Up=0]="Up",t[t.Right=1]="Right",t[t.Down=2]="Down",t[t.Left=3]="Left",t))(D||{}),G=(l=>(l[l.None=0]="None",l[l.Square=1]="Square",l[l.Star=2]="Star",l[l.Tetris=3]="Tetris",l[l.TetrisRotated=4]="TetrisRotated",l))(G||{}),V=(t=>(t[t.Normal=0]="Normal",t[t.Broken=1]="Broken",t[t.Absent=2]="Absent",t[t.Hexagon=3]="Hexagon",t))(V||{}),q=(s=>(s[s.Normal=0]="Normal",s[s.Start=1]="Start",s[s.End=2]="End",s))(q||{}),T=(l=>(l[l.None=0]="None",l[l.Black=1]="Black",l[l.White=2]="White",l[l.Red=3]="Red",l[l.Blue=4]="Blue",l))(T||{});var B=class H{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(e,n){this.rows=e,this.cols=n,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:0}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(e){let n=new H(e.rows,e.cols);return n.cells=e.cells,n.vEdges=e.vEdges,n.hEdges=e.hEdges,n.nodes=e.nodes,n}};var R=class{validate(e,n){let s=n.points;if(s.length<2)return{isValid:!1,errorReason:"Path too short"};let t=s[0],l=s[s.length-1];if(e.nodes[t.y][t.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[l.y][l.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let o=new Set;o.add(`${t.x},${t.y}`);for(let a=0;a<s.length-1;a++){let f=s[a],i=s[a+1];if(Math.abs(f.x-i.x)+Math.abs(f.y-i.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let c=`${i.x},${i.y}`;if(o.has(c))return{isValid:!1,errorReason:"Self-intersecting path"};if(o.add(c),this.isBrokenEdge(e,f,i))return{isValid:!1,errorReason:"Passed through broken edge"}}return this.checkHexagonConstraint(e,s)?this.checkCellConstraints(e,s)?{isValid:!0}:{isValid:!1,errorReason:"Cell constraints failed"}:{isValid:!1,errorReason:"Missed hexagon constraint"}}isBrokenEdge(e,n,s){let t;if(n.x===s.x){let l=Math.min(n.y,s.y);t=e.vEdges[l][n.x].type}else{let l=Math.min(n.x,s.x);t=e.hEdges[n.y][l].type}return t===1||t===2}isAbsentEdge(e,n,s){if(n.x===s.x){let t=Math.min(n.y,s.y);return e.vEdges[t][n.x].type===2}else{let t=Math.min(n.x,s.x);return e.hEdges[n.y][t].type===2}}checkHexagonConstraint(e,n){let s=new Set;for(let t=0;t<n.length-1;t++)s.add(this.getEdgeKey(n[t],n[t+1]));for(let t=0;t<=e.rows;t++)for(let l=0;l<e.cols;l++)if(e.hEdges[t][l].type===3){let o=this.getEdgeKey({x:l,y:t},{x:l+1,y:t});if(!s.has(o))return!1}for(let t=0;t<e.rows;t++)for(let l=0;l<=e.cols;l++)if(e.vEdges[t][l].type===3){let o=this.getEdgeKey({x:l,y:t},{x:l,y:t+1});if(!s.has(o))return!1}return!0}checkCellConstraints(e,n){let s=this.calculateRegions(e,n);for(let t of s){let l=new Map,o=new Set,a=new Set,f=[];for(let i of t){let r=e.cells[i.y][i.x];if(r.type===0)continue;let c=r.color;if(l.set(c,(l.get(c)||0)+1),r.type===1?a.add(c):r.type===2?o.add(c):(r.type===3||r.type===4)&&r.shape&&f.push({shape:r.shape,rotatable:r.type===4}),a.size>1)return!1}for(let i of o)if(l.get(i)!==2)return!1;if(f.length>0&&!this.checkTetrisConstraint(t,f))return!1}return!0}checkTetrisConstraint(e,n){if(n.reduce((c,h)=>c+this.getShapeArea(h.shape),0)!==e.length)return!1;let t=Math.min(...e.map(c=>c.x)),l=Math.min(...e.map(c=>c.y)),o=Math.max(...e.map(c=>c.x)),a=Math.max(...e.map(c=>c.y)),f=o-t+1,i=a-l+1,r=Array.from({length:i},()=>Array(f).fill(!1));for(let c of e)r[c.y-l][c.x-t]=!0;return this.canTile(r,n)}getShapeArea(e){let n=0;for(let s of e)for(let t of s)t&&n++;return n}canTile(e,n){let s=-1,t=-1;for(let l=0;l<e.length;l++){for(let o=0;o<e[0].length;o++)if(e[l][o]){s=l,t=o;break}if(s!==-1)break}if(s===-1)return n.length===0;if(n.length===0)return!1;for(let l=0;l<n.length;l++){let o=n[l],a=[...n.slice(0,l),...n.slice(l+1)],f=o.rotatable?this.getAllRotations(o.shape):[o.shape];for(let i of f){let r=[];for(let c=0;c<i.length;c++)for(let h=0;h<i[0].length;h++)i[c][h]&&r.push({r:c,c:h});for(let c of r){let h=s-c.r,u=t-c.c;if(this.canPlace(e,i,h,u)){if(this.placePiece(e,i,h,u,!1),this.canTile(e,a))return!0;this.placePiece(e,i,h,u,!0)}}}}return!1}canPlace(e,n,s,t){for(let l=0;l<n.length;l++)for(let o=0;o<n[0].length;o++)if(n[l][o]){let a=s+l,f=t+o;if(a<0||a>=e.length||f<0||f>=e[0].length||!e[a][f])return!1}return!0}placePiece(e,n,s,t,l){for(let o=0;o<n.length;o++)for(let a=0;a<n[0].length;a++)n[o][a]&&(e[s+o][t+a]=l)}getAllRotations(e){let n=[],s=new Set,t=e;for(let l=0;l<4;l++){let o=JSON.stringify(t);s.has(o)||(n.push(t),s.add(o)),t=this.rotate90(t)}return n}rotate90(e){let n=e.length,s=e[0].length,t=Array.from({length:s},()=>Array(n).fill(0));for(let l=0;l<n;l++)for(let o=0;o<s;o++)t[o][n-1-l]=e[l][o];return t}calculateRegions(e,n){let s=[],t=new Set,l=new Set;for(let a=0;a<n.length-1;a++)l.add(this.getEdgeKey(n[a],n[a+1]));let o=this.getExternalCells(e);for(let a=0;a<e.rows;a++)for(let f=0;f<e.cols;f++){if(t.has(`${f},${a}`)||o.has(`${f},${a}`))continue;let i=[],r=[{x:f,y:a}];for(t.add(`${f},${a}`);r.length>0;){let c=r.shift();i.push(c);let h=[{nx:c.x,ny:c.y-1,p1:{x:c.x,y:c.y},p2:{x:c.x+1,y:c.y}},{nx:c.x,ny:c.y+1,p1:{x:c.x,y:c.y+1},p2:{x:c.x+1,y:c.y+1}},{nx:c.x-1,ny:c.y,p1:{x:c.x,y:c.y},p2:{x:c.x,y:c.y+1}},{nx:c.x+1,ny:c.y,p1:{x:c.x+1,y:c.y},p2:{x:c.x+1,y:c.y+1}}];for(let u of h)if(u.nx>=0&&u.nx<e.cols&&u.ny>=0&&u.ny<e.rows){let y=`${u.nx},${u.ny}`;if(!t.has(y)&&!o.has(y)){let b=this.getEdgeKey(u.p1,u.p2),v=this.isAbsentEdge(e,u.p1,u.p2);!l.has(b)&&!v&&(t.add(y),r.push({x:u.nx,y:u.ny}))}}}s.push(i)}return s}getExternalCells(e){let n=new Set,s=[];for(let t=0;t<e.cols;t++)e.hEdges[0][t].type===2&&(n.has(`${t},0`)||(n.add(`${t},0`),s.push({x:t,y:0}))),e.hEdges[e.rows][t].type===2&&(n.has(`${t},${e.rows-1}`)||(n.add(`${t},${e.rows-1}`),s.push({x:t,y:e.rows-1})));for(let t=0;t<e.rows;t++)e.vEdges[t][0].type===2&&(n.has(`0,${t}`)||(n.add(`0,${t}`),s.push({x:0,y:t}))),e.vEdges[t][e.cols].type===2&&(n.has(`${e.cols-1},${t}`)||(n.add(`${e.cols-1},${t}`),s.push({x:e.cols-1,y:t})));for(;s.length>0;){let t=s.shift(),l=[{nx:t.x,ny:t.y-1,edge:e.hEdges[t.y][t.x]},{nx:t.x,ny:t.y+1,edge:e.hEdges[t.y+1][t.x]},{nx:t.x-1,ny:t.y,edge:e.vEdges[t.y][t.x]},{nx:t.x+1,ny:t.y,edge:e.vEdges[t.y][t.x+1]}];for(let o of l)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!n.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(n.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return n}getEdgeKey(e,n){return e.x<n.x||e.x===n.x&&e.y<n.y?`${e.x},${e.y}-${n.x},${n.y}`:`${n.x},${n.y}-${e.x},${e.y}`}calculateDifficulty(e){let n=e.rows,s=e.cols,t=s+1,l=(n+1)*t,o=Array.from({length:l},()=>[]),a=[],f=[],i=new Set;for(let g=0;g<=n;g++)for(let P=0;P<=s;P++){let x=g*t+P;if(e.nodes[g][P].type===1&&a.push(x),e.nodes[g][P].type===2&&f.push(x),P<s){let m=x+1,p=e.hEdges[g][P].type,S=p===3,d=p===1||p===2;o[x].push({next:m,isHexagon:S,isBroken:d}),o[m].push({next:x,isHexagon:S,isBroken:d}),S&&i.add(this.getEdgeKey({x:P,y:g},{x:P+1,y:g}))}if(g<n){let m=x+t,p=e.vEdges[g][P].type,S=p===3,d=p===1||p===2;o[x].push({next:m,isHexagon:S,isBroken:d}),o[m].push({next:x,isHexagon:S,isBroken:d}),S&&i.add(this.getEdgeKey({x:P,y:g},{x:P,y:g+1}))}}let r={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},c=i.size,h=new Set;for(let g of a)this.exploreSearchSpace(e,g,1n<<BigInt(g),[g],0,c,o,f,h,r,500);if(r.solutions===0)return 0;let u=i.size,y=new Set;i.size>0&&y.add(999);for(let g=0;g<n;g++)for(let P=0;P<s;P++){let x=e.cells[g][P];x.type!==0&&(u++,y.add(x.type))}let b=r.branchingPoints/(r.totalNodesVisited||1),v=Math.log10(r.totalNodesVisited+1),E=(b*10+v*1)/(Math.log2(r.solutions+1)+1),$=n*s,k=u/$,w=k<.3?Math.pow(k/.3,3):1,A=y.size<=1?.4:1;E*=w*A;let z=Math.sqrt($)/4;return E*=z,Math.max(.01,Math.min(1,E/4))}exploreSearchSpace(e,n,s,t,l,o,a,f,i,r,c){if(r.totalNodesVisited++,r.maxDepth=Math.max(r.maxDepth,t.length),r.totalNodesVisited>c)return;if(f.includes(n)){if(l===o){let u={points:t.map(y=>({x:y%(e.cols+1),y:Math.floor(y/(e.cols+1))}))};if(this.validate(e,u).isValid){let y=this.getFingerprint(e,u.points);i.has(y)||(i.add(y),r.solutions++)}}return}if(!this.canReachEndOptimized(n,s,a,f)){r.backtracks++;return}let h=[];for(let u of a[n]){if(u.isBroken||s&1n<<BigInt(u.next))continue;let y=!0;for(let b of a[n])if(b.isHexagon){let v=t.length>=2&&b.next===t[t.length-2],E=b.next===u.next;if(!v&&!E){y=!1;break}}y&&h.push(u)}h.length>1&&r.branchingPoints++;for(let u of h)if(t.push(u.next),this.exploreSearchSpace(e,u.next,s|1n<<BigInt(u.next),t,l+(u.isHexagon?1:0),o,a,f,i,r,c),t.pop(),r.totalNodesVisited>c)return}countSolutions(e,n=100){let s=e.rows,t=e.cols,l=t+1,o=(s+1)*l,a=Array.from({length:o},()=>[]),f=[],i=[],r=new Set;for(let u=0;u<=s;u++)for(let y=0;y<=t;y++){let b=u*l+y;if(e.nodes[u][y].type===1&&f.push(b),e.nodes[u][y].type===2&&i.push(b),y<t){let v=b+1,E=e.hEdges[u][y].type,$=E===3,k=E===1||E===2;a[b].push({next:v,isHexagon:$,isBroken:k}),a[v].push({next:b,isHexagon:$,isBroken:k}),$&&r.add(this.getEdgeKey({x:y,y:u},{x:y+1,y:u}))}if(u<s){let v=b+l,E=e.vEdges[u][y].type,$=E===3,k=E===1||E===2;a[b].push({next:v,isHexagon:$,isBroken:k}),a[v].push({next:b,isHexagon:$,isBroken:k}),$&&r.add(this.getEdgeKey({x:y,y:u},{x:y,y:u+1}))}}let c=new Set,h=r.size;for(let u of f)if(this.findPathsOptimized(e,u,1n<<BigInt(u),[u],0,h,a,i,c,n),c.size>=n)break;return c.size}findPathsOptimized(e,n,s,t,l,o,a,f,i,r){if(!(i.size>=r)){if(f.includes(n)){if(l===o){let c={points:t.map(h=>({x:h%(e.cols+1),y:Math.floor(h/(e.cols+1))}))};this.validate(e,c).isValid&&i.add(this.getFingerprint(e,c.points))}return}if(this.canReachEndOptimized(n,s,a,f))for(let c of a[n]){if(c.isBroken||s&1n<<BigInt(c.next))continue;let h=!0;for(let u of a[n])if(u.isHexagon){let y=t.length>=2&&u.next===t[t.length-2],b=u.next===c.next;if(!y&&!b){h=!1;break}}if(h&&(t.push(c.next),this.findPathsOptimized(e,c.next,s|1n<<BigInt(c.next),t,l+(c.isHexagon?1:0),o,a,f,i,r),t.pop(),i.size>=r))return}}}canReachEndOptimized(e,n,s,t){let l=[e],o=n,a=0;for(;a<l.length;){let f=l[a++];if(t.includes(f))return!0;for(let i of s[f])!i.isBroken&&!(o&1n<<BigInt(i.next))&&(o|=1n<<BigInt(i.next),l.push(i.next))}return!1}getFingerprint(e,n){return this.calculateRegions(e,n).map(l=>l.map(a=>e.cells[a.y][a.x]).filter(a=>a.type!==0).map(a=>`${a.type}:${a.color}`).sort().join(",")).sort().filter(l=>l.length>0).join("|")||"empty"}};var N=class{generate(e,n,s={}){let t=s.difficulty??.5,l=new R,o=null,a=-1,f=e*n>30?60:100;for(let i=0;i<f;i++){let r=this.generateOnce(e,n,s);if(!this.checkAllRequestedConstraintsPresent(r,s))continue;let c=l.calculateDifficulty(r);if(c===0)continue;let h=Math.abs(c-t);if((o===null||h<Math.abs(a-t))&&(a=c,o=r),t>.8&&c>.8||h<.05)break}return o||this.generateOnce(e,n,s)}generateOnce(e,n,s){let t=new B(e,n),l={x:0,y:e},o={x:n,y:0};t.nodes[l.y][l.x].type=1,t.nodes[o.y][o.x].type=2;let a=this.generateRandomPath(t,l,o);return this.applyConstraintsBasedOnPath(t,a,s),s.useBrokenEdges&&this.applyBrokenEdges(t,a,s),this.cleanGrid(t),t}generateRandomPath(e,n,s){let t=new Set,l=[],o=[n];new Map().set(`${n.x},${n.y}`,null);let f=i=>{if(t.add(`${i.x},${i.y}`),l.push(i),i.x===s.x&&i.y===s.y)return!0;let r=this.getValidNeighbors(e,i,t);this.shuffleArray(r);for(let c of r)if(f(c))return!0;return l.pop(),!1};return f(n),l}getValidNeighbors(e,n,s){let t=[],l=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of l){let a=n.x+o.x,f=n.y+o.y;a>=0&&a<=e.cols&&f>=0&&f<=e.rows&&(s.has(`${a},${f}`)||t.push({x:a,y:f}))}return t}applyBrokenEdges(e,n,s){let t=s.complexity??.5,l=new Set;for(let i=0;i<n.length-1;i++)l.add(this.getEdgeKey(n[i],n[i+1]));let o=[];for(let i=0;i<=e.rows;i++)for(let r=0;r<e.cols;r++){let c={x:r,y:i},h={x:r+1,y:i};l.has(this.getEdgeKey(c,h))||o.push({type:"h",r:i,c:r,p1:c,p2:h})}for(let i=0;i<e.rows;i++)for(let r=0;r<=e.cols;r++){let c={x:r,y:i},h={x:r,y:i+1};l.has(this.getEdgeKey(c,h))||o.push({type:"v",r:i,c:r,p1:c,p2:h})}this.shuffleArray(o);let a=Math.max(1,Math.floor(t*4)),f=0;for(let i of o){if(f>=a)break;let r=Math.random()<.8?1:2;r===2&&this.isAdjacentToMark(e,i)&&(r=1),i.type==="h"?e.hEdges[i.r][i.c].type=r:e.vEdges[i.r][i.c].type=r,f++}for(let i=0;i<=e.rows;i++)for(let r=0;r<=e.cols;r++){let c=[];if(r>0&&c.push({e:e.hEdges[i][r-1],type:"h",r:i,c:r-1}),r<e.cols&&c.push({e:e.hEdges[i][r],type:"h",r:i,c:r}),i>0&&c.push({e:e.vEdges[i-1][r],type:"v",r:i-1,c:r}),i<e.rows&&c.push({e:e.vEdges[i][r],type:"v",r:i,c:r}),c.every(u=>u.e.type===1||u.e.type===2)&&c.every(y=>!this.isAdjacentToMark(e,y)))for(let y of c)y.e.type=2}}cleanGrid(e){let n=[];for(let o=0;o<=e.rows;o++)for(let a=0;a<=e.cols;a++)e.nodes[o][a].type===1&&n.push({x:a,y:o});let s=new Set,t=[...n];for(let o of n)s.add(`${o.x},${o.y}`);for(;t.length>0;){let o=t.shift(),a=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let f of a)f.edge&&f.edge.type!==2&&(s.has(`${f.nx},${f.ny}`)||(s.add(`${f.nx},${f.ny}`),t.push({x:f.nx,y:f.ny})))}for(let o=0;o<=e.rows;o++)for(let a=0;a<e.cols;a++)(!s.has(`${a},${o}`)||!s.has(`${a+1},${o}`))&&(e.hEdges[o][a].type=2);for(let o=0;o<e.rows;o++)for(let a=0;a<=e.cols;a++)(!s.has(`${a},${o}`)||!s.has(`${a},${o+1}`))&&(e.vEdges[o][a].type=2);let l=this.getExternalCells(e);for(let o of l){let[a,f]=o.split(",").map(Number);e.cells[f][a].type=0}}getExternalCells(e){let n=new Set,s=[];for(let t=0;t<e.cols;t++)e.hEdges[0][t].type===2&&(n.has(`${t},0`)||(n.add(`${t},0`),s.push({x:t,y:0}))),e.hEdges[e.rows][t].type===2&&(n.has(`${t},${e.rows-1}`)||(n.add(`${t},${e.rows-1}`),s.push({x:t,y:e.rows-1})));for(let t=0;t<e.rows;t++)e.vEdges[t][0].type===2&&(n.has(`0,${t}`)||(n.add(`0,${t}`),s.push({x:0,y:t}))),e.vEdges[t][e.cols].type===2&&(n.has(`${e.cols-1},${t}`)||(n.add(`${e.cols-1},${t}`),s.push({x:e.cols-1,y:t})));for(;s.length>0;){let t=s.shift(),l=[{nx:t.x,ny:t.y-1,edge:e.hEdges[t.y][t.x]},{nx:t.x,ny:t.y+1,edge:e.hEdges[t.y+1][t.x]},{nx:t.x-1,ny:t.y,edge:e.vEdges[t.y][t.x]},{nx:t.x+1,ny:t.y,edge:e.vEdges[t.y][t.x+1]}];for(let o of l)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!n.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(n.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return n}isAdjacentToMark(e,n){if(n.type==="h"){if(n.r>0&&e.cells[n.r-1][n.c].type!==0||n.r<e.rows&&e.cells[n.r][n.c].type!==0)return!0}else if(n.c>0&&e.cells[n.r][n.c-1].type!==0||n.c<e.cols&&e.cells[n.r][n.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let n=0;n<e.rows;n++)for(let s=0;s<e.cols;s++){if(e.cells[n][s].type===0)continue;if([e.hEdges[n][s],e.hEdges[n+1][s],e.vEdges[n][s],e.vEdges[n][s+1]].filter(o=>o.type===0||o.type===3).length===0)return!0}return!1}getEdgeKey(e,n){return e.x<n.x||e.x===n.x&&e.y<n.y?`${e.x},${e.y}-${n.x},${n.y}`:`${n.x},${n.y}-${e.x},${e.y}`}TETRIS_SHAPES=[[[1]],[[1,1]],[[1,1,1]],[[1,1],[1,0]],[[0,1],[1,0]],[[1,1,1,1]],[[1,1],[1,1]],[[1,1,1],[0,1,0]],[[1,1,0],[0,1,1]],[[1,1,1],[1,0,0]],[[1,1,1],[0,0,1]],[[1,1,1],[1,0,1]],[[0,1,0],[1,0,1]],[[1,0,0,1],[1,0,0,1]],[[1,1,1],[0,1,0],[0,1,0]],[[1,1,0],[0,1,0],[0,1,1]],[[0,1,1],[0,1,0],[1,1,0]],[[1,1,1],[1,0,1],[1,1,1]]];applyConstraintsBasedOnPath(e,n,s){let t=s.complexity??.5,l=s.useHexagons??!0,o=s.useSquares??!0,a=s.useStars??!0,f=s.useTetris??!1,i=0,r=0,c=0,h=0;if(l){let u=s.difficulty??.5;for(let y=0;y<n.length-1;y++){let b=n[y],v=n[y+1],$=this.getValidNeighbors(e,b,new Set).length>2,k=t*.4;$&&(k=u<.4?k*1:k*.5),Math.random()<k&&(this.setEdgeHexagon(e,b,v),i++)}if(i===0&&n.length>=2){let y=Math.floor(Math.random()*(n.length-1));this.setEdgeHexagon(e,n[y],n[y+1])}}if(o||a){let u=this.calculateRegions(e,n),y=[1,2,3,4],b=Array.from({length:u.length},(v,E)=>E);this.shuffleArray(b);for(let v of b){let E=u[v],$=(s.difficulty??.5)>.7?.4:.2,k=o&&r===0||a&&c===0||f&&h===0,w=v===b[b.length-1];if((!k||!w)&&Math.random()>$+t*.5)continue;let A=[...E];this.shuffleArray(A);let z=y[Math.floor(Math.random()*y.length)];if(o&&!a&&w){let x=new Set;for(let m=0;m<e.rows;m++)for(let p=0;p<e.cols;p++)e.cells[m][p].type===1&&x.add(e.cells[m][p].color);if(x.size===1){let m=y.filter(p=>!x.has(p));m.length>0&&(z=m[Math.floor(Math.random()*m.length)])}}let g=0,P=o&&Math.random()<.5+t*.3;if(o&&r===0&&w&&(P=!0),o&&!a&&w){let x=new Set;for(let m=0;m<e.rows;m++)for(let p=0;p<e.cols;p++)e.cells[m][p].type===1&&x.add(e.cells[m][p].color);x.size<2&&r>0&&(P=!0)}if(P){let x=Math.min(A.length,4);g=Math.floor(Math.random()*x),g===0&&r===0&&(g=1);for(let m=0;m<g&&A.length!==0;m++){let p=A.pop();e.cells[p.y][p.x].type=1,e.cells[p.y][p.x].color=z,r++}}if(f){let x=Math.random()<.2+t*.3;h===0&&w&&(x=!0);let m=h===0&&w?6:4;if(x&&A.length>0&&E.length<=m*4){let p=this.generateTiling(E,m);if(p)for(let S of p){if(A.length===0)break;let d=A.pop();e.cells[d.y][d.x].type=S.isRotated?4:3,e.cells[d.y][d.x].shape=S.shape,e.cells[d.y][d.x].color=0,h++}}}if(a)for(let x of y){if(A.length<1)break;let m=Math.random()<.2+t*.3;if(c===0&&w&&(m=!0),!m)continue;let p=E.map(d=>e.cells[d.y][d.x]).filter(d=>d.type===3||d.type===4),S=0;if(x===z&&(S+=g),S+=p.filter(d=>d.color===x).length,S===1){let d=A.pop();e.cells[d.y][d.x].type=2,e.cells[d.y][d.x].color=x,c++}else if(S===0){let d=p.filter(C=>C.color===0);if(x!==4&&Math.random()<.5&&d.length>0){let C=d[Math.floor(Math.random()*d.length)];C.color=x;let M=A.pop();e.cells[M.y][M.x].type=2,e.cells[M.y][M.x].color=x,c++}else if(A.length>=2)for(let C=0;C<2;C++){let M=A.pop();e.cells[M.y][M.x].type=2,e.cells[M.y][M.x].color=x,c++}}}}if(a&&c===0){for(let v of u)if(v.length>=2){let E=[...v].filter($=>e.cells[$.y][$.x].type===0);if(E.length>=2){let $=y[Math.floor(Math.random()*y.length)];for(let k=0;k<2;k++){let w=E.pop();e.cells[w.y][w.x].type=2,e.cells[w.y][w.x].color=$,c++}break}}}}}calculateRegions(e,n){let s=[],t=new Set,l=new Set;for(let o=0;o<n.length-1;o++){let a=n[o],f=n[o+1],i=a.x<f.x||a.y<f.y?`${a.x},${a.y}-${f.x},${f.y}`:`${f.x},${f.y}-${a.x},${a.y}`;l.add(i)}for(let o=0;o<e.rows;o++)for(let a=0;a<e.cols;a++){if(t.has(`${a},${o}`))continue;let f=[],i=[{x:a,y:o}];for(t.add(`${a},${o}`);i.length>0;){let r=i.shift();f.push(r);let c=[{dx:0,dy:-1,boundary:{p1:{x:r.x,y:r.y},p2:{x:r.x+1,y:r.y}}},{dx:0,dy:1,boundary:{p1:{x:r.x,y:r.y+1},p2:{x:r.x+1,y:r.y+1}}},{dx:-1,dy:0,boundary:{p1:{x:r.x,y:r.y},p2:{x:r.x,y:r.y+1}}},{dx:1,dy:0,boundary:{p1:{x:r.x+1,y:r.y},p2:{x:r.x+1,y:r.y+1}}}];for(let h of c){let u=r.x+h.dx,y=r.y+h.dy;if(u>=0&&u<e.cols&&y>=0&&y<e.rows&&!t.has(`${u},${y}`)){let b=h.boundary.p1.x<h.boundary.p2.x||h.boundary.p1.y<h.boundary.p2.y?`${h.boundary.p1.x},${h.boundary.p1.y}-${h.boundary.p2.x},${h.boundary.p2.y}`:`${h.boundary.p2.x},${h.boundary.p2.y}-${h.boundary.p1.x},${h.boundary.p1.y}`;!l.has(b)&&!this.isAbsentEdge(e,h.boundary.p1,h.boundary.p2)&&(t.add(`${u},${y}`),i.push({x:u,y}))}}}s.push(f)}return s}isAbsentEdge(e,n,s){if(n.x===s.x){let t=Math.min(n.y,s.y);return e.vEdges[t][n.x].type===2}else{let t=Math.min(n.x,s.x);return e.hEdges[n.y][t].type===2}}setEdgeHexagon(e,n,s){if(n.x===s.x){let t=Math.min(n.y,s.y);e.vEdges[t][n.x].type=3}else{let t=Math.min(n.x,s.x);e.hEdges[n.y][t].type=3}}checkAllRequestedConstraintsPresent(e,n){let s=n.useHexagons??!0,t=n.useSquares??!0,l=n.useStars??!0,o=n.useTetris??!1;if(n.useBrokenEdges??!1){let f=!1;for(let i=0;i<=e.rows;i++){for(let r=0;r<e.cols;r++)if(e.hEdges[i][r].type===1||e.hEdges[i][r].type===2){f=!0;break}if(f)break}if(!f)for(let i=0;i<e.rows;i++){for(let r=0;r<=e.cols;r++)if(e.vEdges[i][r].type===1||e.vEdges[i][r].type===2){f=!0;break}if(f)break}if(!f)return!1}if(s){let f=!1;for(let i=0;i<=e.rows;i++){for(let r=0;r<e.cols;r++)if(e.hEdges[i][r].type===3){f=!0;break}if(f)break}if(!f)for(let i=0;i<e.rows;i++){for(let r=0;r<=e.cols;r++)if(e.vEdges[i][r].type===3){f=!0;break}if(f)break}if(!f)return!1}if(t||l||o){let f=!1,i=!1,r=!1,c=new Set;for(let h=0;h<e.rows;h++)for(let u=0;u<e.cols;u++)e.cells[h][u].type===1&&(f=!0,c.add(e.cells[h][u].color)),e.cells[h][u].type===2&&(i=!0),(e.cells[h][u].type===3||e.cells[h][u].type===4)&&(r=!0);if(t&&!f||l&&!i||o&&!r||f&&!i&&c.size<2)return!1}return!this.hasIsolatedMark(e)}generateTiling(e,n){let s=Math.min(...e.map(r=>r.x)),t=Math.min(...e.map(r=>r.y)),l=Math.max(...e.map(r=>r.x)),o=Math.max(...e.map(r=>r.y)),a=l-s+1,f=o-t+1,i=Array.from({length:f},()=>Array(a).fill(!1));for(let r of e)i[r.y-t][r.x-s]=!0;return this.tilingDfs(i,[],n)}tilingDfs(e,n,s){let t=-1,l=-1;for(let a=0;a<e.length;a++){for(let f=0;f<e[0].length;f++)if(e[a][f]){t=a,l=f;break}if(t!==-1)break}if(t===-1)return n;if(n.length>=s)return null;let o=[...this.TETRIS_SHAPES];this.shuffleArray(o);for(let a of o){let f=this.isRotationallyInvariant(a),i=f?[a]:this.getAllRotations(a);this.shuffleArray(i);for(let r of i){let c=[];for(let h=0;h<r.length;h++)for(let u=0;u<r[0].length;u++)r[h][u]&&c.push({r:h,c:u});for(let h of c){let u=t-h.r,y=l-h.c;if(this.canPlace(e,r,u,y)){this.placePiece(e,r,u,y,!1);let b=!f&&Math.random()<.5,v=this.tilingDfs(e,[...n,{shape:r,isRotated:!f}],s);if(v)return v;this.placePiece(e,r,u,y,!0)}}}}return null}isRotationallyInvariant(e){let n=0;for(let s of e)for(let t of s)t&&n++;return n===1||n===4&&e.length===2&&e[0].length===2}getAllRotations(e){let n=[],s=new Set,t=e;for(let l=0;l<4;l++){let o=JSON.stringify(t);s.has(o)||(n.push(t),s.add(o)),t=this.rotate90(t)}return n}rotate90(e){let n=e.length,s=e[0].length,t=Array.from({length:s},()=>Array(n).fill(0));for(let l=0;l<n;l++)for(let o=0;o<s;o++)t[o][n-1-l]=e[l][o];return t}canPlace(e,n,s,t){for(let l=0;l<n.length;l++)for(let o=0;o<n[0].length;o++)if(n[l][o]){let a=s+l,f=t+o;if(a<0||a>=e.length||f<0||f>=e[0].length||!e[a][f])return!1}return!0}placePiece(e,n,s,t,l){for(let o=0;o<n.length;o++)for(let a=0;a<n[0].length;a++)n[o][a]&&(e[s+o][t+a]=l)}shuffleArray(e){for(let n=e.length-1;n>0;n--){let s=Math.floor(Math.random()*(n+1));[e[n],e[s]]=[e[s],e[n]]}}};var O=class{generator;validator;constructor(){this.generator=new N,this.validator=new R}createPuzzle(e,n,s={}){return this.generator.generate(e,n,s).export()}validateSolution(e,n){let s=B.fromData(e);return this.validator.validate(s,n)}calculateDifficulty(e){let n=B.fromData(e);return this.validator.calculateDifficulty(n)}};export{G as CellType,T as Color,D as Direction,V as EdgeType,B as Grid,q as NodeType,N as PuzzleGenerator,R as PuzzleValidator,O as WitnessCore};
//# sourceMappingURL=MiniWitness.min.js.map
