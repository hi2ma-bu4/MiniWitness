var w=(e=>(e[e.Up=0]="Up",e[e.Right=1]="Right",e[e.Down=2]="Down",e[e.Left=3]="Left",e))(w||{}),p=(o=>(o[o.None=0]="None",o[o.Square=1]="Square",o[o.Star=2]="Star",o))(p||{}),g=(o=>(o[o.Normal=0]="Normal",o[o.Hexagon=1]="Hexagon",o[o.Broken=2]="Broken",o))(g||{}),m=(o=>(o[o.Normal=0]="Normal",o[o.Start=1]="Start",o[o.End=2]="End",o))(m||{}),$=(s=>(s[s.None=0]="None",s[s.Black=1]="Black",s[s.White=2]="White",s[s.Red=3]="Red",s[s.Blue=4]="Blue",s))($||{});var h=class f{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(t,n){this.rows=t,this.cols=n,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:0}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(t){let n=new f(t.rows,t.cols);return n.cells=t.cells,n.vEdges=t.vEdges,n.hEdges=t.hEdges,n.nodes=t.nodes,n}};var P=class{generate(t,n,o=.5){let e=new h(t,n),s={x:0,y:t},i={x:n,y:0};e.nodes[s.y][s.x].type=1,e.nodes[i.y][i.x].type=2;let a=this.generateRandomPath(e,s,i);return this.applyConstraintsBasedOnPath(e,a,o),e}generateRandomPath(t,n,o){let e=new Set,s=[],i=[n];new Map().set(`${n.x},${n.y}`,null);let l=c=>{if(e.add(`${c.x},${c.y}`),s.push(c),c.x===o.x&&c.y===o.y)return!0;let r=this.getValidNeighbors(t,c,e);this.shuffleArray(r);for(let d of r)if(l(d))return!0;return s.pop(),!1};return l(n),s}getValidNeighbors(t,n,o){let e=[],s=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let i of s){let a=n.x+i.x,l=n.y+i.y;a>=0&&a<=t.cols&&l>=0&&l<=t.rows&&(o.has(`${a},${l}`)||e.push({x:a,y:l}))}return e}applyConstraintsBasedOnPath(t,n,o){for(let i=0;i<n.length-1;i++){let a=n[i],l=n[i+1];Math.random()<o*.4&&this.setEdgeHexagon(t,a,l)}let e=this.calculateRegions(t,n),s=[1,2,3,4];for(let i=0;i<e.length;i++){let a=e[i],l=s[i%s.length];Math.random()<.3+o*.4&&(Math.random()<.3?this.fillRegionWithStarPairs(t,a,l):this.fillRegionWithColor(t,a,l,o))}}calculateRegions(t,n){let o=[],e=new Set,s=new Set;for(let i=0;i<n.length-1;i++){let a=n[i],l=n[i+1],c=a.x<l.x||a.y<l.y?`${a.x},${a.y}-${l.x},${l.y}`:`${l.x},${l.y}-${a.x},${a.y}`;s.add(c)}for(let i=0;i<t.rows;i++)for(let a=0;a<t.cols;a++){if(e.has(`${a},${i}`))continue;let l=[],c=[{x:a,y:i}];for(e.add(`${a},${i}`);c.length>0;){let r=c.shift();l.push(r);let d=[{dx:0,dy:-1,boundary:{p1:{x:r.x,y:r.y},p2:{x:r.x+1,y:r.y}}},{dx:0,dy:1,boundary:{p1:{x:r.x,y:r.y+1},p2:{x:r.x+1,y:r.y+1}}},{dx:-1,dy:0,boundary:{p1:{x:r.x,y:r.y},p2:{x:r.x,y:r.y+1}}},{dx:1,dy:0,boundary:{p1:{x:r.x+1,y:r.y},p2:{x:r.x+1,y:r.y+1}}}];for(let y of d){let x=r.x+y.dx,u=r.y+y.dy;if(x>=0&&x<t.cols&&u>=0&&u<t.rows&&!e.has(`${x},${u}`)){let v=y.boundary.p1.x<y.boundary.p2.x||y.boundary.p1.y<y.boundary.p2.y?`${y.boundary.p1.x},${y.boundary.p1.y}-${y.boundary.p2.x},${y.boundary.p2.y}`:`${y.boundary.p2.x},${y.boundary.p2.y}-${y.boundary.p1.x},${y.boundary.p1.y}`;s.has(v)||(e.add(`${x},${u}`),c.push({x,y:u}))}}}o.push(l)}return o}fillRegionWithColor(t,n,o,e){for(let s of n)Math.random()<e*.7&&(t.cells[s.y][s.x].type=1,t.cells[s.y][s.x].color=o)}fillRegionWithStarPairs(t,n,o){if(n.length<2)return;let e=[...n];this.shuffleArray(e);for(let s=0;s<2;s++)t.cells[e[s].y][e[s].x].type=2,t.cells[e[s].y][e[s].x].color=o}setEdgeHexagon(t,n,o){if(n.x===o.x){let e=Math.min(n.y,o.y);t.vEdges[e][n.x].type=1}else{let e=Math.min(n.x,o.x);t.hEdges[n.y][e].type=1}}shuffleArray(t){for(let n=t.length-1;n>0;n--){let o=Math.floor(Math.random()*(n+1));[t[n],t[o]]=[t[o],t[n]]}}};var b=class{validate(t,n){let o=n.points;if(o.length<2)return{isValid:!1,errorReason:"Path too short"};let e=o[0],s=o[o.length-1];if(t.nodes[e.y][e.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(t.nodes[s.y][s.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let i=new Set;i.add(`${e.x},${e.y}`);for(let a=0;a<o.length-1;a++){let l=o[a],c=o[a+1];if(Math.abs(l.x-c.x)+Math.abs(l.y-c.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let d=`${c.x},${c.y}`;if(i.has(d))return{isValid:!1,errorReason:"Self-intersecting path"};if(i.add(d),this.isBrokenEdge(t,l,c))return{isValid:!1,errorReason:"Passed through broken edge"}}return this.checkHexagonConstraint(t,o)?this.checkCellConstraints(t,o)?{isValid:!0}:{isValid:!1,errorReason:"Cell constraints failed"}:{isValid:!1,errorReason:"Missed hexagon constraint"}}isBrokenEdge(t,n,o){if(n.x===o.x){let e=Math.min(n.y,o.y);return t.vEdges[e][n.x].type===2}else{let e=Math.min(n.x,o.x);return t.hEdges[n.y][e].type===2}}checkHexagonConstraint(t,n){let o=new Set;for(let e=0;e<n.length-1;e++){let s=n[e],i=n[e+1];o.add(this.getEdgeKey(s,i))}for(let e=0;e<=t.rows;e++)for(let s=0;s<t.cols;s++)if(e<t.rows+1&&t.hEdges[e][s].type===1){let i=this.getEdgeKey({x:s,y:e},{x:s+1,y:e});if(!o.has(i))return!1}for(let e=0;e<t.rows;e++)for(let s=0;s<=t.cols;s++)if(t.vEdges[e][s].type===1){let i=this.getEdgeKey({x:s,y:e},{x:s,y:e+1});if(!o.has(i))return!1}return!0}checkCellConstraints(t,n){let o=this.calculateRegions(t,n);for(let e of o){let s=new Map,i=new Set,a=new Set;for(let l of e){let c=t.cells[l.y][l.x];if(c.type===0)continue;let r=c.color;if(s.set(r,(s.get(r)||0)+1),c.type===1?a.add(r):c.type===2&&i.add(r),a.size>1)return!1}for(let l of i)if(s.get(l)!==2)return!1}return!0}calculateRegions(t,n){let o=[],e=new Set,s=new Set;for(let i=0;i<n.length-1;i++)s.add(this.getEdgeKey(n[i],n[i+1]));for(let i=0;i<t.rows;i++)for(let a=0;a<t.cols;a++){if(e.has(`${a},${i}`))continue;let l=[],c=[{x:a,y:i}];for(e.add(`${a},${i}`);c.length>0;){let r=c.shift();l.push(r);let d=[{nx:r.x,ny:r.y-1,p1:{x:r.x,y:r.y},p2:{x:r.x+1,y:r.y}},{nx:r.x,ny:r.y+1,p1:{x:r.x,y:r.y+1},p2:{x:r.x+1,y:r.y+1}},{nx:r.x-1,ny:r.y,p1:{x:r.x,y:r.y},p2:{x:r.x,y:r.y+1}},{nx:r.x+1,ny:r.y,p1:{x:r.x+1,y:r.y},p2:{x:r.x+1,y:r.y+1}}];for(let y of d)if(y.nx>=0&&y.nx<t.cols&&y.ny>=0&&y.ny<t.rows&&!e.has(`${y.nx},${y.ny}`)){let x=this.getEdgeKey(y.p1,y.p2),u=this.isBrokenEdge(t,y.p1,y.p2);!s.has(x)&&!u&&(e.add(`${y.nx},${y.ny}`),c.push({x:y.nx,y:y.ny}))}}o.push(l)}return o}getEdgeKey(t,n){return t.x<n.x||t.x===n.x&&t.y<n.y?`${t.x},${t.y}-${n.x},${n.y}`:`${n.x},${n.y}-${t.x},${t.y}`}};var E=class{generator;validator;constructor(){this.generator=new P,this.validator=new b}createPuzzle(t,n,o=.5){return this.generator.generate(t,n,o).export()}validateSolution(t,n){let o=h.fromData(t);return this.validator.validate(o,n)}};export{p as CellType,$ as Color,w as Direction,g as EdgeType,m as NodeType,E as WitnessCore};
//# sourceMappingURL=MiniWitness.min.js.map
