var O=(t=>(t[t.Up=0]="Up",t[t.Right=1]="Right",t[t.Down=2]="Down",t[t.Left=3]="Left",t))(O||{}),N=(s=>(s[s.None=0]="None",s[s.Square=1]="Square",s[s.Star=2]="Star",s))(N||{}),H=(t=>(t[t.Normal=0]="Normal",t[t.Broken=1]="Broken",t[t.Absent=2]="Absent",t[t.Hexagon=3]="Hexagon",t))(H||{}),V=(s=>(s[s.Normal=0]="Normal",s[s.Start=1]="Start",s[s.End=2]="End",s))(V||{}),R=(c=>(c[c.None=0]="None",c[c.Black=1]="Black",c[c.White=2]="White",c[c.Red=3]="Red",c[c.Blue=4]="Blue",c))(R||{});var k=class z{rows;cols;cells=[];hEdges=[];vEdges=[];nodes=[];constructor(e,n){this.rows=e,this.cols=n,this.initializeGrid()}initializeGrid(){this.cells=Array.from({length:this.rows},()=>Array.from({length:this.cols},()=>({type:0,color:0}))),this.hEdges=Array.from({length:this.rows+1},()=>Array.from({length:this.cols},()=>({type:0}))),this.vEdges=Array.from({length:this.rows},()=>Array.from({length:this.cols+1},()=>({type:0}))),this.nodes=Array.from({length:this.rows+1},()=>Array.from({length:this.cols+1},()=>({type:0})))}export(){return JSON.parse(JSON.stringify({rows:this.rows,cols:this.cols,cells:this.cells,vEdges:this.vEdges,hEdges:this.hEdges,nodes:this.nodes}))}static fromData(e){let n=new z(e.rows,e.cols);return n.cells=e.cells,n.vEdges=e.vEdges,n.hEdges=e.hEdges,n.nodes=e.nodes,n}};var A=class{validate(e,n){let s=n.points;if(s.length<2)return{isValid:!1,errorReason:"Path too short"};let t=s[0],c=s[s.length-1];if(e.nodes[t.y][t.x].type!==1)return{isValid:!1,errorReason:"Must start at Start Node"};if(e.nodes[c.y][c.x].type!==2)return{isValid:!1,errorReason:"Must end at End Node"};let o=new Set;o.add(`${t.x},${t.y}`);for(let r=0;r<s.length-1;r++){let l=s[r],i=s[r+1];if(Math.abs(l.x-i.x)+Math.abs(l.y-i.y)!==1)return{isValid:!1,errorReason:"Invalid jump in path"};let y=`${i.x},${i.y}`;if(o.has(y))return{isValid:!1,errorReason:"Self-intersecting path"};if(o.add(y),this.isBrokenEdge(e,l,i))return{isValid:!1,errorReason:"Passed through broken edge"}}return this.checkHexagonConstraint(e,s)?this.checkCellConstraints(e,s)?{isValid:!0}:{isValid:!1,errorReason:"Cell constraints failed"}:{isValid:!1,errorReason:"Missed hexagon constraint"}}isBrokenEdge(e,n,s){let t;if(n.x===s.x){let c=Math.min(n.y,s.y);t=e.vEdges[c][n.x].type}else{let c=Math.min(n.x,s.x);t=e.hEdges[n.y][c].type}return t===1||t===2}isAbsentEdge(e,n,s){if(n.x===s.x){let t=Math.min(n.y,s.y);return e.vEdges[t][n.x].type===2}else{let t=Math.min(n.x,s.x);return e.hEdges[n.y][t].type===2}}checkHexagonConstraint(e,n){let s=new Set;for(let t=0;t<n.length-1;t++)s.add(this.getEdgeKey(n[t],n[t+1]));for(let t=0;t<=e.rows;t++)for(let c=0;c<e.cols;c++)if(e.hEdges[t][c].type===3){let o=this.getEdgeKey({x:c,y:t},{x:c+1,y:t});if(!s.has(o))return!1}for(let t=0;t<e.rows;t++)for(let c=0;c<=e.cols;c++)if(e.vEdges[t][c].type===3){let o=this.getEdgeKey({x:c,y:t},{x:c,y:t+1});if(!s.has(o))return!1}return!0}checkCellConstraints(e,n){let s=this.calculateRegions(e,n);for(let t of s){let c=new Map,o=new Set,r=new Set;for(let l of t){let i=e.cells[l.y][l.x];if(i.type===0)continue;let a=i.color;if(c.set(a,(c.get(a)||0)+1),i.type===1?r.add(a):i.type===2&&o.add(a),r.size>1)return!1}for(let l of o)if(c.get(l)!==2)return!1}return!0}calculateRegions(e,n){let s=[],t=new Set,c=new Set;for(let r=0;r<n.length-1;r++)c.add(this.getEdgeKey(n[r],n[r+1]));let o=this.getExternalCells(e);for(let r=0;r<e.rows;r++)for(let l=0;l<e.cols;l++){if(t.has(`${l},${r}`)||o.has(`${l},${r}`))continue;let i=[],a=[{x:l,y:r}];for(t.add(`${l},${r}`);a.length>0;){let y=a.shift();i.push(y);let u=[{nx:y.x,ny:y.y-1,p1:{x:y.x,y:y.y},p2:{x:y.x+1,y:y.y}},{nx:y.x,ny:y.y+1,p1:{x:y.x,y:y.y+1},p2:{x:y.x+1,y:y.y+1}},{nx:y.x-1,ny:y.y,p1:{x:y.x,y:y.y},p2:{x:y.x,y:y.y+1}},{nx:y.x+1,ny:y.y,p1:{x:y.x+1,y:y.y},p2:{x:y.x+1,y:y.y+1}}];for(let f of u)if(f.nx>=0&&f.nx<e.cols&&f.ny>=0&&f.ny<e.rows){let h=`${f.nx},${f.ny}`;if(!t.has(h)&&!o.has(h)){let x=this.getEdgeKey(f.p1,f.p2),m=this.isAbsentEdge(e,f.p1,f.p2);!c.has(x)&&!m&&(t.add(h),a.push({x:f.nx,y:f.ny}))}}}s.push(i)}return s}getExternalCells(e){let n=new Set,s=[];for(let t=0;t<e.cols;t++)e.hEdges[0][t].type===2&&(n.has(`${t},0`)||(n.add(`${t},0`),s.push({x:t,y:0}))),e.hEdges[e.rows][t].type===2&&(n.has(`${t},${e.rows-1}`)||(n.add(`${t},${e.rows-1}`),s.push({x:t,y:e.rows-1})));for(let t=0;t<e.rows;t++)e.vEdges[t][0].type===2&&(n.has(`0,${t}`)||(n.add(`0,${t}`),s.push({x:0,y:t}))),e.vEdges[t][e.cols].type===2&&(n.has(`${e.cols-1},${t}`)||(n.add(`${e.cols-1},${t}`),s.push({x:e.cols-1,y:t})));for(;s.length>0;){let t=s.shift(),c=[{nx:t.x,ny:t.y-1,edge:e.hEdges[t.y][t.x]},{nx:t.x,ny:t.y+1,edge:e.hEdges[t.y+1][t.x]},{nx:t.x-1,ny:t.y,edge:e.vEdges[t.y][t.x]},{nx:t.x+1,ny:t.y,edge:e.vEdges[t.y][t.x+1]}];for(let o of c)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!n.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(n.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return n}getEdgeKey(e,n){return e.x<n.x||e.x===n.x&&e.y<n.y?`${e.x},${e.y}-${n.x},${n.y}`:`${n.x},${n.y}-${e.x},${e.y}`}calculateDifficulty(e){let n=e.rows,s=e.cols,t=s+1,c=(n+1)*t,o=Array.from({length:c},()=>[]),r=[],l=[],i=new Set;for(let p=0;p<=n;p++)for(let g=0;g<=s;g++){let d=p*t+g;if(e.nodes[p][g].type===1&&r.push(d),e.nodes[p][g].type===2&&l.push(d),g<s){let v=d+1,w=e.hEdges[p][g].type,S=w===3,B=w===1||w===2;o[d].push({next:v,isHexagon:S,isBroken:B}),o[v].push({next:d,isHexagon:S,isBroken:B}),S&&i.add(this.getEdgeKey({x:g,y:p},{x:g+1,y:p}))}if(p<n){let v=d+t,w=e.vEdges[p][g].type,S=w===3,B=w===1||w===2;o[d].push({next:v,isHexagon:S,isBroken:B}),o[v].push({next:d,isHexagon:S,isBroken:B}),S&&i.add(this.getEdgeKey({x:g,y:p},{x:g,y:p+1}))}}let a={totalNodesVisited:0,branchingPoints:0,solutions:0,maxDepth:0,backtracks:0},y=i.size,u=new Set;for(let p of r)this.exploreSearchSpace(e,p,1n<<BigInt(p),[p],0,y,o,l,u,a,500);if(a.solutions===0)return 0;let f=i.size,h=new Set;i.size>0&&h.add(999);for(let p=0;p<n;p++)for(let g=0;g<s;g++){let d=e.cells[p][g];d.type!==0&&(f++,h.add(d.type))}let x=a.branchingPoints/(a.totalNodesVisited||1),m=Math.log10(a.totalNodesVisited+1),b=(x*10+m*1)/(Math.log2(a.solutions+1)+1),$=n*s,E=f/$,C=E<.3?Math.pow(E/.3,3):1,P=h.size<=1?.4:1;b*=C*P;let G=Math.sqrt($)/4;return b*=G,Math.max(.01,Math.min(1,b/4))}exploreSearchSpace(e,n,s,t,c,o,r,l,i,a,y){if(a.totalNodesVisited++,a.maxDepth=Math.max(a.maxDepth,t.length),a.totalNodesVisited>y)return;if(l.includes(n)){if(c===o){let f={points:t.map(h=>({x:h%(e.cols+1),y:Math.floor(h/(e.cols+1))}))};if(this.validate(e,f).isValid){let h=this.getFingerprint(e,f.points);i.has(h)||(i.add(h),a.solutions++)}}return}if(!this.canReachEndOptimized(n,s,r,l)){a.backtracks++;return}let u=[];for(let f of r[n]){if(f.isBroken||s&1n<<BigInt(f.next))continue;let h=!0;for(let x of r[n])if(x.isHexagon){let m=t.length>=2&&x.next===t[t.length-2],b=x.next===f.next;if(!m&&!b){h=!1;break}}h&&u.push(f)}u.length>1&&a.branchingPoints++;for(let f of u)if(t.push(f.next),this.exploreSearchSpace(e,f.next,s|1n<<BigInt(f.next),t,c+(f.isHexagon?1:0),o,r,l,i,a,y),t.pop(),a.totalNodesVisited>y)return}countSolutions(e,n=100){let s=e.rows,t=e.cols,c=t+1,o=(s+1)*c,r=Array.from({length:o},()=>[]),l=[],i=[],a=new Set;for(let f=0;f<=s;f++)for(let h=0;h<=t;h++){let x=f*c+h;if(e.nodes[f][h].type===1&&l.push(x),e.nodes[f][h].type===2&&i.push(x),h<t){let m=x+1,b=e.hEdges[f][h].type,$=b===3,E=b===1||b===2;r[x].push({next:m,isHexagon:$,isBroken:E}),r[m].push({next:x,isHexagon:$,isBroken:E}),$&&a.add(this.getEdgeKey({x:h,y:f},{x:h+1,y:f}))}if(f<s){let m=x+c,b=e.vEdges[f][h].type,$=b===3,E=b===1||b===2;r[x].push({next:m,isHexagon:$,isBroken:E}),r[m].push({next:x,isHexagon:$,isBroken:E}),$&&a.add(this.getEdgeKey({x:h,y:f},{x:h,y:f+1}))}}let y=new Set,u=a.size;for(let f of l)if(this.findPathsOptimized(e,f,1n<<BigInt(f),[f],0,u,r,i,y,n),y.size>=n)break;return y.size}findPathsOptimized(e,n,s,t,c,o,r,l,i,a){if(!(i.size>=a)){if(l.includes(n)){if(c===o){let y={points:t.map(u=>({x:u%(e.cols+1),y:Math.floor(u/(e.cols+1))}))};this.validate(e,y).isValid&&i.add(this.getFingerprint(e,y.points))}return}if(this.canReachEndOptimized(n,s,r,l))for(let y of r[n]){if(y.isBroken||s&1n<<BigInt(y.next))continue;let u=!0;for(let f of r[n])if(f.isHexagon){let h=t.length>=2&&f.next===t[t.length-2],x=f.next===y.next;if(!h&&!x){u=!1;break}}if(u&&(t.push(y.next),this.findPathsOptimized(e,y.next,s|1n<<BigInt(y.next),t,c+(y.isHexagon?1:0),o,r,l,i,a),t.pop(),i.size>=a))return}}}canReachEndOptimized(e,n,s,t){let c=[e],o=n,r=0;for(;r<c.length;){let l=c[r++];if(t.includes(l))return!0;for(let i of s[l])!i.isBroken&&!(o&1n<<BigInt(i.next))&&(o|=1n<<BigInt(i.next),c.push(i.next))}return!1}getFingerprint(e,n){return this.calculateRegions(e,n).map(c=>c.map(r=>e.cells[r.y][r.x]).filter(r=>r.type!==0).map(r=>`${r.type}:${r.color}`).sort().join(",")).sort().filter(c=>c.length>0).join("|")||"empty"}};var M=class{generate(e,n,s={}){let t=s.difficulty??.5,c=new A,o=null,r=-1,l=e*n>30?30:60;for(let i=0;i<l;i++){let a=this.generateOnce(e,n,s);if(!this.checkAllRequestedConstraintsPresent(a,s))continue;let y=c.calculateDifficulty(a);if(y===0)continue;let u=Math.abs(y-t);if((o===null||u<Math.abs(r-t))&&(r=y,o=a),t>.8&&y>.8||u<.05)break}return o||this.generateOnce(e,n,s)}generateOnce(e,n,s){let t=new k(e,n),c={x:0,y:e},o={x:n,y:0};t.nodes[c.y][c.x].type=1,t.nodes[o.y][o.x].type=2;let r=this.generateRandomPath(t,c,o);return this.applyConstraintsBasedOnPath(t,r,s),s.useBrokenEdges&&this.applyBrokenEdges(t,r,s),this.cleanGrid(t),t}generateRandomPath(e,n,s){let t=new Set,c=[],o=[n];new Map().set(`${n.x},${n.y}`,null);let l=i=>{if(t.add(`${i.x},${i.y}`),c.push(i),i.x===s.x&&i.y===s.y)return!0;let a=this.getValidNeighbors(e,i,t);this.shuffleArray(a);for(let y of a)if(l(y))return!0;return c.pop(),!1};return l(n),c}getValidNeighbors(e,n,s){let t=[],c=[{x:0,y:-1},{x:1,y:0},{x:0,y:1},{x:-1,y:0}];for(let o of c){let r=n.x+o.x,l=n.y+o.y;r>=0&&r<=e.cols&&l>=0&&l<=e.rows&&(s.has(`${r},${l}`)||t.push({x:r,y:l}))}return t}applyBrokenEdges(e,n,s){let t=s.complexity??.5,c=new Set;for(let i=0;i<n.length-1;i++)c.add(this.getEdgeKey(n[i],n[i+1]));let o=[];for(let i=0;i<=e.rows;i++)for(let a=0;a<e.cols;a++){let y={x:a,y:i},u={x:a+1,y:i};c.has(this.getEdgeKey(y,u))||o.push({type:"h",r:i,c:a,p1:y,p2:u})}for(let i=0;i<e.rows;i++)for(let a=0;a<=e.cols;a++){let y={x:a,y:i},u={x:a,y:i+1};c.has(this.getEdgeKey(y,u))||o.push({type:"v",r:i,c:a,p1:y,p2:u})}this.shuffleArray(o);let r=Math.max(1,Math.floor(t*4)),l=0;for(let i of o){if(l>=r)break;let a=Math.random()<.8?1:2;a===2&&this.isAdjacentToMark(e,i)&&(a=1),i.type==="h"?e.hEdges[i.r][i.c].type=a:e.vEdges[i.r][i.c].type=a,l++}for(let i=0;i<=e.rows;i++)for(let a=0;a<=e.cols;a++){let y=[];if(a>0&&y.push({e:e.hEdges[i][a-1],type:"h",r:i,c:a-1}),a<e.cols&&y.push({e:e.hEdges[i][a],type:"h",r:i,c:a}),i>0&&y.push({e:e.vEdges[i-1][a],type:"v",r:i-1,c:a}),i<e.rows&&y.push({e:e.vEdges[i][a],type:"v",r:i,c:a}),y.every(f=>f.e.type===1||f.e.type===2)&&y.every(h=>!this.isAdjacentToMark(e,h)))for(let h of y)h.e.type=2}}cleanGrid(e){let n=[];for(let o=0;o<=e.rows;o++)for(let r=0;r<=e.cols;r++)e.nodes[o][r].type===1&&n.push({x:r,y:o});let s=new Set,t=[...n];for(let o of n)s.add(`${o.x},${o.y}`);for(;t.length>0;){let o=t.shift(),r=[{nx:o.x,ny:o.y-1,edge:e.vEdges[o.y-1]?.[o.x]},{nx:o.x,ny:o.y+1,edge:e.vEdges[o.y]?.[o.x]},{nx:o.x-1,ny:o.y,edge:e.hEdges[o.y]?.[o.x-1]},{nx:o.x+1,ny:o.y,edge:e.hEdges[o.y]?.[o.x]}];for(let l of r)l.edge&&l.edge.type!==2&&(s.has(`${l.nx},${l.ny}`)||(s.add(`${l.nx},${l.ny}`),t.push({x:l.nx,y:l.ny})))}for(let o=0;o<=e.rows;o++)for(let r=0;r<e.cols;r++)(!s.has(`${r},${o}`)||!s.has(`${r+1},${o}`))&&(e.hEdges[o][r].type=2);for(let o=0;o<e.rows;o++)for(let r=0;r<=e.cols;r++)(!s.has(`${r},${o}`)||!s.has(`${r},${o+1}`))&&(e.vEdges[o][r].type=2);let c=this.getExternalCells(e);for(let o of c){let[r,l]=o.split(",").map(Number);e.cells[l][r].type=0}}getExternalCells(e){let n=new Set,s=[];for(let t=0;t<e.cols;t++)e.hEdges[0][t].type===2&&(n.has(`${t},0`)||(n.add(`${t},0`),s.push({x:t,y:0}))),e.hEdges[e.rows][t].type===2&&(n.has(`${t},${e.rows-1}`)||(n.add(`${t},${e.rows-1}`),s.push({x:t,y:e.rows-1})));for(let t=0;t<e.rows;t++)e.vEdges[t][0].type===2&&(n.has(`0,${t}`)||(n.add(`0,${t}`),s.push({x:0,y:t}))),e.vEdges[t][e.cols].type===2&&(n.has(`${e.cols-1},${t}`)||(n.add(`${e.cols-1},${t}`),s.push({x:e.cols-1,y:t})));for(;s.length>0;){let t=s.shift(),c=[{nx:t.x,ny:t.y-1,edge:e.hEdges[t.y][t.x]},{nx:t.x,ny:t.y+1,edge:e.hEdges[t.y+1][t.x]},{nx:t.x-1,ny:t.y,edge:e.vEdges[t.y][t.x]},{nx:t.x+1,ny:t.y,edge:e.vEdges[t.y][t.x+1]}];for(let o of c)o.nx>=0&&o.nx<e.cols&&o.ny>=0&&o.ny<e.rows&&!n.has(`${o.nx},${o.ny}`)&&o.edge.type===2&&(n.add(`${o.nx},${o.ny}`),s.push({x:o.nx,y:o.ny}))}return n}isAdjacentToMark(e,n){if(n.type==="h"){if(n.r>0&&e.cells[n.r-1][n.c].type!==0||n.r<e.rows&&e.cells[n.r][n.c].type!==0)return!0}else if(n.c>0&&e.cells[n.r][n.c-1].type!==0||n.c<e.cols&&e.cells[n.r][n.c].type!==0)return!0;return!1}hasIsolatedMark(e){for(let n=0;n<e.rows;n++)for(let s=0;s<e.cols;s++){if(e.cells[n][s].type===0)continue;if([e.hEdges[n][s],e.hEdges[n+1][s],e.vEdges[n][s],e.vEdges[n][s+1]].filter(o=>o.type===0||o.type===3).length===0)return!0}return!1}getEdgeKey(e,n){return e.x<n.x||e.x===n.x&&e.y<n.y?`${e.x},${e.y}-${n.x},${n.y}`:`${n.x},${n.y}-${e.x},${e.y}`}applyConstraintsBasedOnPath(e,n,s){let t=s.complexity??.5,c=s.useHexagons??!0,o=s.useSquares??!0,r=s.useStars??!0,l=0,i=0,a=0;if(c){let y=s.difficulty??.5;for(let u=0;u<n.length-1;u++){let f=n[u],h=n[u+1],m=this.getValidNeighbors(e,f,new Set).length>2,b=t*.4;m&&(b=y<.4?b*1:b*.5),Math.random()<b&&(this.setEdgeHexagon(e,f,h),l++)}if(l===0&&n.length>=2){let u=Math.floor(Math.random()*(n.length-1));this.setEdgeHexagon(e,n[u],n[u+1])}}if(o||r){let y=this.calculateRegions(e,n),u=[1,2,3,4],f=Array.from({length:y.length},(h,x)=>x);this.shuffleArray(f);for(let h of f){let x=y[h],m=(s.difficulty??.5)>.7?.4:.2,b=o&&i===0||r&&a===0,$=h===f[f.length-1];if((!b||!$)&&Math.random()>m+t*.5)continue;let E=[...x];this.shuffleArray(E);let C=u[Math.floor(Math.random()*u.length)],P=0,G=o&&Math.random()<.5+t*.3;if(o&&i===0&&$&&(G=!0),G){let p=Math.min(E.length,4);P=Math.floor(Math.random()*p),P===0&&i===0&&(P=1);for(let g=0;g<P&&E.length!==0;g++){let d=E.pop();e.cells[d.y][d.x].type=1,e.cells[d.y][d.x].color=C,i++}}if(r)for(let p of u){if(E.length<1)break;let g=Math.random()<.2+t*.3;if(a===0&&$&&(g=!0),!!g){if(p===C){if(P===1&&E.length>=1){let d=E.pop();e.cells[d.y][d.x].type=2,e.cells[d.y][d.x].color=p,a++}else if(P===0&&E.length>=2)for(let d=0;d<2;d++){let v=E.pop();e.cells[v.y][v.x].type=2,e.cells[v.y][v.x].color=p,a++}}else if(E.length>=2)for(let d=0;d<2;d++){let v=E.pop();e.cells[v.y][v.x].type=2,e.cells[v.y][v.x].color=p,a++}}}}if(r&&a===0){for(let h of y)if(h.length>=2){let x=[...h].filter(m=>e.cells[m.y][m.x].type===0);if(x.length>=2){let m=u[Math.floor(Math.random()*u.length)];for(let b=0;b<2;b++){let $=x.pop();e.cells[$.y][$.x].type=2,e.cells[$.y][$.x].color=m,a++}break}}}}}calculateRegions(e,n){let s=[],t=new Set,c=new Set;for(let o=0;o<n.length-1;o++){let r=n[o],l=n[o+1],i=r.x<l.x||r.y<l.y?`${r.x},${r.y}-${l.x},${l.y}`:`${l.x},${l.y}-${r.x},${r.y}`;c.add(i)}for(let o=0;o<e.rows;o++)for(let r=0;r<e.cols;r++){if(t.has(`${r},${o}`))continue;let l=[],i=[{x:r,y:o}];for(t.add(`${r},${o}`);i.length>0;){let a=i.shift();l.push(a);let y=[{dx:0,dy:-1,boundary:{p1:{x:a.x,y:a.y},p2:{x:a.x+1,y:a.y}}},{dx:0,dy:1,boundary:{p1:{x:a.x,y:a.y+1},p2:{x:a.x+1,y:a.y+1}}},{dx:-1,dy:0,boundary:{p1:{x:a.x,y:a.y},p2:{x:a.x,y:a.y+1}}},{dx:1,dy:0,boundary:{p1:{x:a.x+1,y:a.y},p2:{x:a.x+1,y:a.y+1}}}];for(let u of y){let f=a.x+u.dx,h=a.y+u.dy;if(f>=0&&f<e.cols&&h>=0&&h<e.rows&&!t.has(`${f},${h}`)){let x=u.boundary.p1.x<u.boundary.p2.x||u.boundary.p1.y<u.boundary.p2.y?`${u.boundary.p1.x},${u.boundary.p1.y}-${u.boundary.p2.x},${u.boundary.p2.y}`:`${u.boundary.p2.x},${u.boundary.p2.y}-${u.boundary.p1.x},${u.boundary.p1.y}`;!c.has(x)&&!this.isAbsentEdge(e,u.boundary.p1,u.boundary.p2)&&(t.add(`${f},${h}`),i.push({x:f,y:h}))}}}s.push(l)}return s}isAbsentEdge(e,n,s){if(n.x===s.x){let t=Math.min(n.y,s.y);return e.vEdges[t][n.x].type===2}else{let t=Math.min(n.x,s.x);return e.hEdges[n.y][t].type===2}}setEdgeHexagon(e,n,s){if(n.x===s.x){let t=Math.min(n.y,s.y);e.vEdges[t][n.x].type=3}else{let t=Math.min(n.x,s.x);e.hEdges[n.y][t].type=3}}checkAllRequestedConstraintsPresent(e,n){let s=n.useHexagons??!0,t=n.useSquares??!0,c=n.useStars??!0;if(n.useBrokenEdges??!1){let r=!1;for(let l=0;l<=e.rows;l++){for(let i=0;i<e.cols;i++)if(e.hEdges[l][i].type===1||e.hEdges[l][i].type===2){r=!0;break}if(r)break}if(!r)for(let l=0;l<e.rows;l++){for(let i=0;i<=e.cols;i++)if(e.vEdges[l][i].type===1||e.vEdges[l][i].type===2){r=!0;break}if(r)break}if(!r)return!1}if(s){let r=!1;for(let l=0;l<=e.rows;l++){for(let i=0;i<e.cols;i++)if(e.hEdges[l][i].type===3){r=!0;break}if(r)break}if(!r)for(let l=0;l<e.rows;l++){for(let i=0;i<=e.cols;i++)if(e.vEdges[l][i].type===3){r=!0;break}if(r)break}if(!r)return!1}if(t||c){let r=!1,l=!1;for(let i=0;i<e.rows;i++)for(let a=0;a<e.cols;a++)e.cells[i][a].type===1&&(r=!0),e.cells[i][a].type===2&&(l=!0);if(t&&!r||c&&!l)return!1}return!this.hasIsolatedMark(e)}shuffleArray(e){for(let n=e.length-1;n>0;n--){let s=Math.floor(Math.random()*(n+1));[e[n],e[s]]=[e[s],e[n]]}}};var q=class{generator;validator;constructor(){this.generator=new M,this.validator=new A}createPuzzle(e,n,s={}){return this.generator.generate(e,n,s).export()}validateSolution(e,n){let s=k.fromData(e);return this.validator.validate(s,n)}calculateDifficulty(e){let n=k.fromData(e);return this.validator.calculateDifficulty(n)}};export{N as CellType,R as Color,O as Direction,H as EdgeType,k as Grid,V as NodeType,M as PuzzleGenerator,A as PuzzleValidator,q as WitnessCore};
//# sourceMappingURL=MiniWitness.min.js.map
