{
  "version": 3,
  "sources": ["../src/types.ts", "../src/grid.ts", "../src/validator.ts", "../src/generator.ts", "../src/index.ts"],
  "sourcesContent": ["export enum Direction {\n\tUp = 0,\n\tRight = 1,\n\tDown = 2,\n\tLeft = 3,\n}\n\nexport enum CellType {\n\tNone = 0,\n\tSquare = 1, // \u8272\u5206\u3051\u304C\u5FC5\u8981\u306A\u30D6\u30ED\u30C3\u30AF\n\tStar = 2, // \u540C\u3058\u8272\u306E\u30DA\u30A2\u4F5C\u6210 (\u661F)\n\t// \u5FC5\u8981\u306B\u5FDC\u3058\u3066Tetris\u578B\u306A\u3069\u3092\u8FFD\u52A0\n}\n\nexport enum EdgeType {\n\tNormal = 0,\n\tBroken = 1, // \u7DDA\u306E\u771F\u3093\u4E2D\u3067\u65AD\u7DDA (\u901A\u884C\u4E0D\u53EF)\n\tAbsent = 2, // \u305D\u3082\u305D\u3082\u5206\u5C90\u3082\u306A\u3057 (\u901A\u884C\u4E0D\u53EF)\n\tHexagon = 3, // \u901A\u904E\u5FC5\u9808\n}\n\nexport enum NodeType {\n\tNormal = 0,\n\tStart = 1,\n\tEnd = 2,\n}\n\nexport enum Color {\n\tNone = 0,\n\tBlack = 1,\n\tWhite = 2,\n\tRed = 3,\n\tBlue = 4,\n\t// \u62E1\u5F35\u53EF\u80FD\n}\n\nexport interface Point {\n\tx: number;\n\ty: number;\n}\n\nexport interface CellConstraint {\n\ttype: CellType;\n\tcolor: Color;\n}\n\nexport interface EdgeConstraint {\n\ttype: EdgeType;\n}\n\nexport interface NodeConstraint {\n\ttype: NodeType;\n}\n\n/**\n * \u30D1\u30BA\u30EB\u306E\u9759\u7684\u306A\u5B9A\u7FA9\u30C7\u30FC\u30BF\n */\nexport interface PuzzleData {\n\trows: number;\n\tcols: number;\n\tcells: CellConstraint[][]; // [row][col]\n\tvEdges: EdgeConstraint[][]; // Vertical edges [row][col] (row: 0..rows-1, col: 0..cols)\n\thEdges: EdgeConstraint[][]; // Horizontal edges [row][col] (row: 0..rows, col: 0..cols-1)\n\tnodes: NodeConstraint[][]; // [row][col]\n}\n\n/**\n * \u30E6\u30FC\u30B6\u30FC\u306E\u5165\u529B\uFF08\u56DE\u7B54\u30D1\u30B9\uFF09\n */\nexport interface SolutionPath {\n\tpoints: Point[]; // \u901A\u904E\u3057\u305F\u30CE\u30FC\u30C9\u306E\u5EA7\u6A19\u914D\u5217\n}\n\nexport interface ValidationResult {\n\tisValid: boolean;\n\terrorReason?: string;\n}\n\n/**\n * \u30D1\u30BA\u30EB\u751F\u6210\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\n */\nexport interface GenerationOptions {\n\tuseHexagons?: boolean;\n\tuseSquares?: boolean;\n\tuseStars?: boolean;\n\tuseBrokenEdges?: boolean;\n\tcomplexity?: number; // 0.0 - 1.0 (\u5236\u7D04\u306E\u5BC6\u5EA6)\n\tdifficulty?: number; // 0.0 (Easy) - 1.0 (Hard) (\u89E3\u30D1\u30BF\u30FC\u30F3\u306E\u6570\u306B\u57FA\u3065\u304F)\n}\n", "import { type CellConstraint, CellType, Color, type EdgeConstraint, EdgeType, type NodeConstraint, NodeType, type PuzzleData } from \"./types\";\n\nexport class Grid {\n\tpublic readonly rows: number;\n\tpublic readonly cols: number;\n\n\t// \u30C7\u30FC\u30BF\u30DE\u30C8\u30EA\u30AF\u30B9\n\tpublic cells: CellConstraint[][] = [];\n\tpublic hEdges: EdgeConstraint[][] = []; // \u6A2A\u68D2\n\tpublic vEdges: EdgeConstraint[][] = []; // \u7E26\u68D2\n\tpublic nodes: NodeConstraint[][] = [];\n\n\tconstructor(rows: number, cols: number) {\n\t\tthis.rows = rows;\n\t\tthis.cols = cols;\n\t\tthis.initializeGrid();\n\t}\n\n\tprivate initializeGrid() {\n\t\t// Cells: rows * cols\n\t\tthis.cells = Array.from({ length: this.rows }, () => Array.from({ length: this.cols }, () => ({ type: CellType.None, color: Color.None })));\n\n\t\t// H-Edges: (rows + 1) * cols\n\t\tthis.hEdges = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols }, () => ({ type: EdgeType.Normal })));\n\n\t\t// V-Edges: rows * (cols + 1)\n\t\tthis.vEdges = Array.from({ length: this.rows }, () => Array.from({ length: this.cols + 1 }, () => ({ type: EdgeType.Normal })));\n\n\t\t// Nodes: (rows + 1) * (cols + 1)\n\t\tthis.nodes = Array.from({ length: this.rows + 1 }, () => Array.from({ length: this.cols + 1 }, () => ({ type: NodeType.Normal })));\n\t}\n\n\tpublic export(): PuzzleData {\n\t\t// \u30C7\u30FC\u30BF\u306E\u30C7\u30A3\u30FC\u30D7\u30B3\u30D4\u30FC\u3092\u8FD4\u3059\n\t\treturn JSON.parse(\n\t\t\tJSON.stringify({\n\t\t\t\trows: this.rows,\n\t\t\t\tcols: this.cols,\n\t\t\t\tcells: this.cells,\n\t\t\t\tvEdges: this.vEdges,\n\t\t\t\thEdges: this.hEdges,\n\t\t\t\tnodes: this.nodes,\n\t\t\t}),\n\t\t);\n\t}\n\n\tpublic static fromData(data: PuzzleData): Grid {\n\t\tconst grid = new Grid(data.rows, data.cols);\n\t\tgrid.cells = data.cells;\n\t\tgrid.vEdges = data.vEdges;\n\t\tgrid.hEdges = data.hEdges;\n\t\tgrid.nodes = data.nodes;\n\t\treturn grid;\n\t}\n}\n", "import { Grid } from \"./grid\";\nimport { CellType, EdgeType, NodeType, type Point, type SolutionPath, type ValidationResult } from \"./types\";\n\nexport class PuzzleValidator {\n\tpublic validate(grid: Grid, solution: SolutionPath): ValidationResult {\n\t\tconst path = solution.points;\n\n\t\t// 1. \u57FA\u672C\u7684\u306A\u30D1\u30B9\u306E\u6709\u52B9\u6027\u30C1\u30A7\u30C3\u30AF (\u9023\u7D9A\u6027\u3001\u59CB\u70B9\u7D42\u70B9)\n\t\tif (path.length < 2) return { isValid: false, errorReason: \"Path too short\" };\n\n\t\tconst start = path[0];\n\t\tconst end = path[path.length - 1];\n\n\t\tif (grid.nodes[start.y][start.x].type !== NodeType.Start) {\n\t\t\treturn { isValid: false, errorReason: \"Must start at Start Node\" };\n\t\t}\n\t\tif (grid.nodes[end.y][end.x].type !== NodeType.End) {\n\t\t\treturn { isValid: false, errorReason: \"Must end at End Node\" };\n\t\t}\n\n\t\t// 2. \u30D1\u30B9\u306E\u9023\u7D9A\u6027\u3068\u81EA\u5DF1\u4EA4\u5DEE\u306E\u30C1\u30A7\u30C3\u30AF\n\t\tconst visitedNodes = new Set<string>();\n\t\tvisitedNodes.add(`${start.x},${start.y}`);\n\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst p1 = path[i];\n\t\t\tconst p2 = path[i + 1];\n\n\t\t\t// \u8DDD\u96E2\u304C1\u3067\u3042\u308B\u3053\u3068\n\t\t\tconst dist = Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n\t\t\tif (dist !== 1) return { isValid: false, errorReason: \"Invalid jump in path\" };\n\n\t\t\t// \u65E2\u306B\u901A\u3063\u305F\u30CE\u30FC\u30C9\u3067\u306F\u306A\u3044\u3053\u3068 (\u81EA\u5DF1\u4EA4\u5DEE\u7981\u6B62)\n\t\t\tconst key = `${p2.x},${p2.y}`;\n\t\t\tif (visitedNodes.has(key)) return { isValid: false, errorReason: \"Self-intersecting path\" };\n\t\t\tvisitedNodes.add(key);\n\n\t\t\t// \u901A\u884C\u4E0D\u53EF\u30A8\u30C3\u30B8(Broken)\u3067\u306A\u3044\u304B\u30C1\u30A7\u30C3\u30AF\n\t\t\tif (this.isBrokenEdge(grid, p1, p2)) {\n\t\t\t\treturn { isValid: false, errorReason: \"Passed through broken edge\" };\n\t\t\t}\n\t\t}\n\n\t\t// 3. \u30EB\u30FC\u30EB\u691C\u8A3C: Hexagon (\u901A\u904E\u5FC5\u9808)\n\t\tif (!this.checkHexagonConstraint(grid, path)) {\n\t\t\treturn { isValid: false, errorReason: \"Missed hexagon constraint\" };\n\t\t}\n\n\t\t// 4. \u30EB\u30FC\u30EB\u691C\u8A3C: \u30BB\u30EB\u5236\u7D04 (Squares & Stars)\n\t\tif (!this.checkCellConstraints(grid, path)) {\n\t\t\treturn { isValid: false, errorReason: \"Cell constraints failed\" };\n\t\t}\n\n\t\treturn { isValid: true };\n\t}\n\n\tprivate isBrokenEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tlet type: EdgeType;\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\ttype = grid.vEdges[y][p1.x].type;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\ttype = grid.hEdges[p1.y][x].type;\n\t\t}\n\t\treturn type === EdgeType.Broken || type === EdgeType.Absent;\n\t}\n\n\tprivate isAbsentEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\treturn grid.vEdges[y][p1.x].type === EdgeType.Absent;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\treturn grid.hEdges[p1.y][x].type === EdgeType.Absent;\n\t\t}\n\t}\n\n\tprivate checkHexagonConstraint(grid: Grid, path: Point[]): boolean {\n\t\t// \u30D1\u30B9\u4E0A\u306E\u30A8\u30C3\u30B8\u30AD\u30FC\u96C6\u5408\u3092\u4F5C\u6210\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t}\n\n\t\t// \u30B0\u30EA\u30C3\u30C9\u4E0A\u306E\u5168\u30D8\u30AD\u30B5\u30B4\u30F3\u30A8\u30C3\u30B8\u3092\u78BA\u8A8D\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r });\n\t\t\t\t\tif (!pathEdges.has(key)) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\tconst key = this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 });\n\t\t\t\t\tif (!pathEdges.has(key)) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate checkCellConstraints(grid: Grid, path: Point[]): boolean {\n\t\tconst regions = this.calculateRegions(grid, path);\n\n\t\tfor (const region of regions) {\n\t\t\tconst colorCounts = new Map<number, number>();\n\t\t\tconst starColors = new Set<number>();\n\t\t\tconst squareColors = new Set<number>();\n\n\t\t\tfor (const cell of region) {\n\t\t\t\tconst constraint = grid.cells[cell.y][cell.x];\n\t\t\t\tif (constraint.type === CellType.None) continue;\n\n\t\t\t\tconst color = constraint.color;\n\t\t\t\tcolorCounts.set(color, (colorCounts.get(color) || 0) + 1);\n\n\t\t\t\tif (constraint.type === CellType.Square) {\n\t\t\t\t\tsquareColors.add(color);\n\t\t\t\t} else if (constraint.type === CellType.Star) {\n\t\t\t\t\tstarColors.add(color);\n\t\t\t\t}\n\t\t\t\t// Squares: All squares in a region must be the same color\n\t\t\t\tif (squareColors.size > 1) return false;\n\t\t\t}\n\t\t\t// Stars: For each color that has a star, there must be exactly 2 marks of that color\n\t\t\tfor (const color of starColors) {\n\t\t\t\tif (colorCounts.get(color) !== 2) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate calculateRegions(grid: Grid, path: Point[]): Point[][] {\n\t\tconst regions: Point[][] = [];\n\t\tconst visitedCells = new Set<string>();\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t}\n\n\t\t// \u76E4\u9762\u5916\u306B\u30EA\u30FC\u30AF\u3057\u3066\u3044\u308B\u30BB\u30EB\u3092\u7279\u5B9A\n\t\tconst externalCells = this.getExternalCells(grid);\n\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (visitedCells.has(`${c},${r}`) || externalCells.has(`${c},${r}`)) continue;\n\n\t\t\t\tconst region: Point[] = [];\n\t\t\t\tconst queue: Point[] = [{ x: c, y: r }];\n\t\t\t\tvisitedCells.add(`${c},${r}`);\n\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst curr = queue.shift()!;\n\t\t\t\t\tregion.push(curr);\n\n\t\t\t\t\tconst neighbors = [\n\t\t\t\t\t\t{ nx: curr.x, ny: curr.y - 1, p1: { x: curr.x, y: curr.y }, p2: { x: curr.x + 1, y: curr.y } }, // Up\n\t\t\t\t\t\t{ nx: curr.x, ny: curr.y + 1, p1: { x: curr.x, y: curr.y + 1 }, p2: { x: curr.x + 1, y: curr.y + 1 } }, // Down\n\t\t\t\t\t\t{ nx: curr.x - 1, ny: curr.y, p1: { x: curr.x, y: curr.y }, p2: { x: curr.x, y: curr.y + 1 } }, // Left\n\t\t\t\t\t\t{ nx: curr.x + 1, ny: curr.y, p1: { x: curr.x + 1, y: curr.y }, p2: { x: curr.x + 1, y: curr.y + 1 } }, // Right\n\t\t\t\t\t];\n\n\t\t\t\t\tfor (const n of neighbors) {\n\t\t\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\t\t\tconst neighborKey = `${n.nx},${n.ny}`;\n\t\t\t\t\t\t\tif (!visitedCells.has(neighborKey) && !externalCells.has(neighborKey)) {\n\t\t\t\t\t\t\t\tconst edgeKey = this.getEdgeKey(n.p1, n.p2);\n\t\t\t\t\t\t\t\tconst isAbsent = this.isAbsentEdge(grid, n.p1, n.p2);\n\t\t\t\t\t\t\t\t// \u30D1\u30B9\u307E\u305F\u306FAbsent\u30A8\u30C3\u30B8\u3001\u3042\u308B\u3044\u306F\u300C\u5916\u5468\u306E\u8FC2\u56DE\u300D\u306B\u3088\u308A\u906E\u3089\u308C\u3066\u3044\u306A\u3044\u304B\n\t\t\t\t\t\t\t\tif (!pathEdges.has(edgeKey) && !isAbsent) {\n\t\t\t\t\t\t\t\t\tvisitedCells.add(neighborKey);\n\t\t\t\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregions.push(region);\n\t\t\t}\n\t\t}\n\t\treturn regions;\n\t}\n\n\tprivate getExternalCells(grid: Grid): Set<string> {\n\t\tconst external = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [];\n\n\t\t// 1. \u30B0\u30EA\u30C3\u30C9\u5883\u754C\u304B\u3089\u306E\u30EA\u30FC\u30AF\u3092\u53CE\u96C6\n\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\tif (grid.hEdges[0][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},0`)) {\n\t\t\t\t\texternal.add(`${c},0`);\n\t\t\t\t\tqueue.push({ x: c, y: 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.hEdges[grid.rows][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},${grid.rows - 1}`)) {\n\t\t\t\t\texternal.add(`${c},${grid.rows - 1}`);\n\t\t\t\t\tqueue.push({ x: c, y: grid.rows - 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tif (grid.vEdges[r][0].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`0,${r}`)) {\n\t\t\t\t\texternal.add(`0,${r}`);\n\t\t\t\t\tqueue.push({ x: 0, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.vEdges[r][grid.cols].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${grid.cols - 1},${r}`)) {\n\t\t\t\t\texternal.add(`${grid.cols - 1},${r}`);\n\t\t\t\t\tqueue.push({ x: grid.cols - 1, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 2. Absent\u30A8\u30C3\u30B8\u3092\u901A\u3058\u305F\u30EA\u30FC\u30AF\u306E\u4F1D\u642C\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.hEdges[curr.y][curr.x] }, // Up\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.hEdges[curr.y + 1][curr.x] }, // Down\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x] }, // Left\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x + 1] }, // Right\n\t\t\t];\n\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\tif (!external.has(`${n.nx},${n.ny}`) && n.edge.type === EdgeType.Absent) {\n\t\t\t\t\t\texternal.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn external;\n\t}\n\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u306E\u96E3\u6613\u5EA6\u3092\u8A08\u7B97\u3059\u308B\uFF080.0 - 1.0\uFF09\n\t * \u77E5\u7684\u306A\u30A2\u30EB\u30B4\u30EA\u30BA\u30E0\uFF1A\u63A2\u7D22\u7A7A\u9593\u306E\u5E83\u3055\u3001\u5206\u5C90\u6570\u3001\u5F37\u5236\u624B\u3001\u89E3\u306E\u6570\u306A\u3069\u3092\u5206\u6790\n\t */\n\tpublic calculateDifficulty(grid: Grid): number {\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst nodeCols = cols + 1;\n\t\tconst nodeCount = (rows + 1) * nodeCols;\n\n\t\t// \u63A2\u7D22\u7528\u30C7\u30FC\u30BF\u306E\u6E96\u5099\n\t\tconst adj = Array.from({ length: nodeCount }, () => [] as { next: number; isHexagon: boolean; isBroken: boolean }[]);\n\t\tconst startNodes: number[] = [];\n\t\tconst endNodes: number[] = [];\n\t\tconst hexagonEdges = new Set<string>();\n\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tconst u = r * nodeCols + c;\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) startNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.End) endNodes.push(u);\n\t\t\t\tif (c < cols) {\n\t\t\t\t\tconst v = u + 1;\n\t\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBlocked = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r }));\n\t\t\t\t}\n\t\t\t\tif (r < rows) {\n\t\t\t\t\tconst v = u + nodeCols;\n\t\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBlocked = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 }));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst stats = {\n\t\t\ttotalNodesVisited: 0,\n\t\t\tbranchingPoints: 0,\n\t\t\tsolutions: 0,\n\t\t\tmaxDepth: 0,\n\t\t\tbacktracks: 0,\n\t\t};\n\n\t\tconst totalHexagons = hexagonEdges.size;\n\t\tconst fingerprints = new Set<string>();\n\n\t\tfor (const startIdx of startNodes) {\n\t\t\tthis.exploreSearchSpace(grid, startIdx, 1n << BigInt(startIdx), [startIdx], 0, totalHexagons, adj, endNodes, fingerprints, stats, 500);\n\t\t}\n\n\t\tif (stats.solutions === 0) return 0;\n\n\t\t// \u96E3\u6613\u5EA6\u8A08\u7B97\u30ED\u30B8\u30C3\u30AF\n\t\t// 1. \u5236\u7D04\u306E\u6570\u3068\u7A2E\u985E (\u5C11\u306A\u3044\u307B\u3069\u5358\u7D14)\n\t\tlet constraintCount = hexagonEdges.size;\n\t\tconst constraintTypes = new Set<number>();\n\t\tif (hexagonEdges.size > 0) constraintTypes.add(999); // \u30D8\u30AD\u30B5\u30B4\u30F3\u7528\u30C0\u30DF\u30FCID\n\n\t\tfor (let r = 0; r < rows; r++) {\n\t\t\tfor (let c = 0; c < cols; c++) {\n\t\t\t\tconst cell = grid.cells[r][c];\n\t\t\t\tif (cell.type !== CellType.None) {\n\t\t\t\t\tconstraintCount++;\n\t\t\t\t\tconstraintTypes.add(cell.type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 2. \u5206\u5C90\u306E\u591A\u3055\u306F\u601D\u8003\u306E\u8907\u96D1\u3055\u306B\u6BD4\u4F8B\u3059\u308B\n\t\t// 3. \u63A2\u7D22\u7A7A\u9593\u306E\u5E83\u3055\u306F\u7DCF\u5F53\u305F\u308A\u306E\u5927\u5909\u3055\u306B\u6BD4\u4F8B\u3059\u308B\n\t\t// 4. \u89E3\u306E\u6570\u304C\u591A\u3044\u307B\u3069\u3001\u5076\u7136\u6B63\u89E3\u3092\u898B\u3064\u3051\u3084\u3059\u3044\uFF08\u96E3\u6613\u5EA6\u4F4E\u4E0B\uFF09\n\n\t\tconst branchingFactor = stats.branchingPoints / (stats.totalNodesVisited || 1);\n\t\tconst searchComplexity = Math.log10(stats.totalNodesVisited + 1);\n\n\t\t// \u57FA\u672C\u30B9\u30B3\u30A2\u306E\u8A08\u7B97\n\t\tlet difficulty = (branchingFactor * 10 + searchComplexity * 1.0) / (Math.log2(stats.solutions + 1) + 1);\n\n\t\t// \u5BC6\u5EA6\u306E\u8A08\u7B97\u3068\u88DC\u6B63\n\t\t// \u7A7A\u767D\u30DE\u30B9\u304C\u591A\u3059\u304E\u308B\uFF08\u5236\u7D04\u5BC6\u5EA6\u304C\u4F4E\u3044\uFF09\u30D1\u30BA\u30EB\u306F\u4EBA\u9593\u306B\u306F\u975E\u5E38\u306B\u7C21\u5358\u306B\u611F\u3058\u3089\u308C\u308B\n\t\tconst cellCount = rows * cols;\n\t\tconst density = constraintCount / cellCount;\n\n\t\t// \u5BC6\u5EA6\u304C 0.3 (30%) \u3092\u4E0B\u56DE\u308B\u5834\u5408\u3001\u6025\u6FC0\u306B\u96E3\u6613\u5EA6\u3092\u6E1B\u8870\u3055\u305B\u308B\uFF083\u4E57\u30AB\u30FC\u30D6\uFF09\n\t\tconst densityFactor = density < 0.3 ? Math.pow(density / 0.3, 3) : 1.0;\n\n\t\t// \u5236\u7D04\u306E\u7A2E\u985E\u304C\u5C11\u306A\u3044\u5834\u5408\u306E\u66F4\u306A\u308B\u6E1B\u8870\n\t\tconst typeFactor = constraintTypes.size <= 1 ? 0.4 : 1.0;\n\n\t\tdifficulty *= densityFactor * typeFactor;\n\n\t\t// \u30B0\u30EA\u30C3\u30C9\u30B5\u30A4\u30BA\u3067\u6B63\u898F\u5316 (\u5927\u304D\u3044\u30B0\u30EA\u30C3\u30C9\u307B\u3069\u63A2\u7D22\u7A7A\u9593\u304C\u5E83\u3044\u305F\u3081)\n\t\tconst sizeFactor = Math.sqrt(cellCount) / 4;\n\t\tdifficulty *= sizeFactor;\n\n\t\t// \u6700\u7D42\u7684\u306A\u5024\u3092 0.0 - 1.0 \u306B\u53CE\u3081\u308B\n\t\treturn Math.max(0.01, Math.min(1.0, difficulty / 4));\n\t}\n\n\tprivate exploreSearchSpace(grid: Grid, currIdx: number, visitedMask: bigint, path: number[], hexagonsOnPath: number, totalHexagons: number, adj: { next: number; isHexagon: boolean; isBroken: boolean }[][], endNodes: number[], fingerprints: Set<string>, stats: { totalNodesVisited: number; branchingPoints: number; solutions: number; maxDepth: number; backtracks: number }, limit: number): void {\n\t\tstats.totalNodesVisited++;\n\t\tstats.maxDepth = Math.max(stats.maxDepth, path.length);\n\n\t\tif (stats.totalNodesVisited > limit) return;\n\n\t\tif (endNodes.includes(currIdx)) {\n\t\t\tif (hexagonsOnPath === totalHexagons) {\n\t\t\t\tconst solutionPath = {\n\t\t\t\t\tpoints: path.map((idx) => ({\n\t\t\t\t\t\tx: idx % (grid.cols + 1),\n\t\t\t\t\t\ty: Math.floor(idx / (grid.cols + 1)),\n\t\t\t\t\t})),\n\t\t\t\t};\n\t\t\t\tif (this.validate(grid, solutionPath).isValid) {\n\t\t\t\t\tconst fp = this.getFingerprint(grid, solutionPath.points);\n\t\t\t\t\tif (!fingerprints.has(fp)) {\n\t\t\t\t\t\tfingerprints.add(fp);\n\t\t\t\t\t\tstats.solutions++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.canReachEndOptimized(currIdx, visitedMask, adj, endNodes)) {\n\t\t\tstats.backtracks++;\n\t\t\treturn;\n\t\t}\n\n\t\tconst validMoves = [];\n\t\tfor (const edge of adj[currIdx]) {\n\t\t\tif (edge.isBroken) continue;\n\t\t\tif (visitedMask & (1n << BigInt(edge.next))) continue;\n\n\t\t\tlet possible = true;\n\t\t\tfor (const otherEdge of adj[currIdx]) {\n\t\t\t\tif (otherEdge.isHexagon) {\n\t\t\t\t\tconst isAlreadyOnPath = path.length >= 2 && otherEdge.next === path[path.length - 2];\n\t\t\t\t\tconst isNextMove = otherEdge.next === edge.next;\n\t\t\t\t\tif (!isAlreadyOnPath && !isNextMove) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (possible) {\n\t\t\t\tvalidMoves.push(edge);\n\t\t\t}\n\t\t}\n\n\t\tif (validMoves.length > 1) {\n\t\t\tstats.branchingPoints++;\n\t\t}\n\n\t\tfor (const move of validMoves) {\n\t\t\tpath.push(move.next);\n\t\t\tthis.exploreSearchSpace(grid, move.next, visitedMask | (1n << BigInt(move.next)), path, hexagonsOnPath + (move.isHexagon ? 1 : 0), totalHexagons, adj, endNodes, fingerprints, stats, limit);\n\t\t\tpath.pop();\n\t\t\tif (stats.totalNodesVisited > limit) return;\n\t\t}\n\t}\n\n\t/**\n\t * \u5168\u3066\u306E\u6709\u52B9\u306A\u89E3\u7B54\u30D1\u30B9\u306E\u500B\u6570\u3092\u30AB\u30A6\u30F3\u30C8\u3059\u308B\n\t */\n\tpublic countSolutions(grid: Grid, limit: number = 100): number {\n\t\tconst rows = grid.rows;\n\t\tconst cols = grid.cols;\n\t\tconst nodeCols = cols + 1;\n\t\tconst nodeCount = (rows + 1) * nodeCols;\n\n\t\t// \u30CE\u30FC\u30C9\u60C5\u5831\u306E\u4E8B\u524D\u8A08\u7B97\n\t\tconst adj = Array.from({ length: nodeCount }, () => [] as { next: number; isHexagon: boolean; isBroken: boolean }[]);\n\t\tconst startNodes: number[] = [];\n\t\tconst endNodes: number[] = [];\n\t\tconst hexagonEdges = new Set<string>();\n\n\t\tfor (let r = 0; r <= rows; r++) {\n\t\t\tfor (let c = 0; c <= cols; c++) {\n\t\t\t\tconst u = r * nodeCols + c;\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) startNodes.push(u);\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.End) endNodes.push(u);\n\n\t\t\t\t// Right\n\t\t\t\tif (c < cols) {\n\t\t\t\t\tconst v = u + 1;\n\t\t\t\t\tconst type = grid.hEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBlocked = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c + 1, y: r }));\n\t\t\t\t}\n\t\t\t\t// Down\n\t\t\t\tif (r < rows) {\n\t\t\t\t\tconst v = u + nodeCols;\n\t\t\t\t\tconst type = grid.vEdges[r][c].type;\n\t\t\t\t\tconst isHexagon = type === EdgeType.Hexagon;\n\t\t\t\t\tconst isBlocked = type === EdgeType.Broken || type === EdgeType.Absent;\n\t\t\t\t\tadj[u].push({ next: v, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tadj[v].push({ next: u, isHexagon, isBroken: isBlocked });\n\t\t\t\t\tif (isHexagon) hexagonEdges.add(this.getEdgeKey({ x: c, y: r }, { x: c, y: r + 1 }));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst fingerprints = new Set<string>();\n\t\tconst totalHexagons = hexagonEdges.size;\n\n\t\tfor (const startIdx of startNodes) {\n\t\t\tthis.findPathsOptimized(grid, startIdx, 1n << BigInt(startIdx), [startIdx], 0, totalHexagons, adj, endNodes, fingerprints, limit);\n\t\t\tif (fingerprints.size >= limit) break;\n\t\t}\n\n\t\treturn fingerprints.size;\n\t}\n\n\tprivate findPathsOptimized(grid: Grid, currIdx: number, visitedMask: bigint, path: number[], hexagonsOnPath: number, totalHexagons: number, adj: { next: number; isHexagon: boolean; isBroken: boolean }[][], endNodes: number[], fingerprints: Set<string>, limit: number): void {\n\t\tif (fingerprints.size >= limit) return;\n\n\t\t// \u7D42\u70B9\u306B\u5230\u9054\u3057\u305F\u5834\u5408\n\t\tif (endNodes.includes(currIdx)) {\n\t\t\tif (hexagonsOnPath === totalHexagons) {\n\t\t\t\tconst solutionPath = {\n\t\t\t\t\tpoints: path.map((idx) => ({\n\t\t\t\t\t\tx: idx % (grid.cols + 1),\n\t\t\t\t\t\ty: Math.floor(idx / (grid.cols + 1)),\n\t\t\t\t\t})),\n\t\t\t\t};\n\t\t\t\tif (this.validate(grid, solutionPath).isValid) {\n\t\t\t\t\tfingerprints.add(this.getFingerprint(grid, solutionPath.points));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Note: The Witness\u306E\u30EB\u30FC\u30EB\u4E0A\u3001\u7D42\u70B9\u304B\u3089\u3055\u3089\u306B\u9032\u3080\u3053\u3068\u306F\u3067\u304D\u306A\u3044\n\t\t\treturn;\n\t\t}\n\n\t\t// \u679D\u5208\u308A: \u7D42\u70B9\u3078\u306E\u5230\u9054\u53EF\u80FD\u6027\n\t\tif (!this.canReachEndOptimized(currIdx, visitedMask, adj, endNodes)) return;\n\n\t\tfor (const edge of adj[currIdx]) {\n\t\t\tif (edge.isBroken) continue;\n\t\t\tif (visitedMask & (1n << BigInt(edge.next))) continue;\n\n\t\t\t// Hexagon pruning:\n\t\t\t// \u73FE\u5728\u306E\u30CE\u30FC\u30C9(currIdx)\u306B\u63A5\u7D9A\u3055\u308C\u3066\u3044\u308B\u30D8\u30AD\u30B5\u30B4\u30F3\u30A8\u30C3\u30B8\u306E\u3046\u3061\u3001\n\t\t\t// \u307E\u3060\u4F7F\u3063\u3066\u304A\u3089\u305A\u3001\u304B\u3064\u6B21\u306E\u79FB\u52D5(next)\u3067\u3082\u4F7F\u308F\u306A\u3044\u3082\u306E\u306F\u3001\u3082\u3046\u4E8C\u5EA6\u3068\u4F7F\u3048\u306A\u3044\u3002\n\t\t\tlet possible = true;\n\t\t\tfor (const otherEdge of adj[currIdx]) {\n\t\t\t\tif (otherEdge.isHexagon) {\n\t\t\t\t\t// \u3053\u306E\u30D8\u30AD\u30B5\u30B4\u30F3\u30A8\u30C3\u30B8\u304C\u30D1\u30B9\u306B\u542B\u307E\u308C\u3066\u3044\u306A\u3044\u304B\u30C1\u30A7\u30C3\u30AF\n\t\t\t\t\t// \u30D1\u30B9\u306B\u542B\u307E\u308C\u3066\u3044\u308B\u306A\u3089 otherEdge.next \u306F path[path.length-2] \u306E\u306F\u305A\n\t\t\t\t\tconst isAlreadyOnPath = path.length >= 2 && otherEdge.next === path[path.length - 2];\n\t\t\t\t\tconst isNextMove = otherEdge.next === edge.next;\n\t\t\t\t\tif (!isAlreadyOnPath && !isNextMove) {\n\t\t\t\t\t\tpossible = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!possible) continue;\n\n\t\t\tpath.push(edge.next);\n\t\t\tthis.findPathsOptimized(grid, edge.next, visitedMask | (1n << BigInt(edge.next)), path, hexagonsOnPath + (edge.isHexagon ? 1 : 0), totalHexagons, adj, endNodes, fingerprints, limit);\n\t\t\tpath.pop();\n\t\t\tif (fingerprints.size >= limit) return;\n\t\t}\n\t}\n\n\tprivate canReachEndOptimized(curr: number, visitedMask: bigint, adj: { next: number; isBroken: boolean }[][], endNodes: number[]): boolean {\n\t\tlet queue = [curr];\n\t\tlet localVisited = visitedMask;\n\n\t\tlet head = 0;\n\t\twhile (head < queue.length) {\n\t\t\tconst u = queue[head++];\n\t\t\tif (endNodes.includes(u)) return true;\n\n\t\t\tfor (const edge of adj[u]) {\n\t\t\t\tif (!edge.isBroken && !(localVisited & (1n << BigInt(edge.next)))) {\n\t\t\t\t\tlocalVisited |= 1n << BigInt(edge.next);\n\t\t\t\t\tqueue.push(edge.next);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate getFingerprint(grid: Grid, path: Point[]): string {\n\t\tconst regions = this.calculateRegions(grid, path);\n\t\tconst regionFingerprints = regions\n\t\t\t.map((region) => {\n\t\t\t\tconst marks = region\n\t\t\t\t\t.map((p) => grid.cells[p.y][p.x])\n\t\t\t\t\t.filter((c) => c.type !== CellType.None)\n\t\t\t\t\t.map((c) => `${c.type}:${c.color}`)\n\t\t\t\t\t.sort();\n\t\t\t\treturn marks.join(\",\");\n\t\t\t})\n\t\t\t.sort();\n\t\treturn regionFingerprints.filter((f) => f.length > 0).join(\"|\") || \"empty\";\n\t}\n}\n", "import { Grid } from \"./grid\";\nimport { CellType, Color, type EdgeConstraint, EdgeType, type GenerationOptions, NodeType, type Point } from \"./types\";\nimport { PuzzleValidator } from \"./validator\";\n\nexport class PuzzleGenerator {\n\t/**\n\t * \u30D1\u30BA\u30EB\u3092\u751F\u6210\u3059\u308B\n\t * @param rows \u884C\u6570\n\t * @param cols \u5217\u6570\n\t * @param options \u751F\u6210\u30AA\u30D7\u30B7\u30E7\u30F3\n\t */\n\tpublic generate(rows: number, cols: number, options: GenerationOptions = {}): Grid {\n\t\tconst targetDifficulty = options.difficulty ?? 0.5;\n\t\tconst validator = new PuzzleValidator();\n\n\t\tlet bestGrid: Grid | null = null;\n\t\tlet bestScore = -1;\n\n\t\t// \u30B0\u30EA\u30C3\u30C9\u30B5\u30A4\u30BA\u306B\u5FDC\u3058\u3066\u8A66\u884C\u56DE\u6570\u3092\u8ABF\u6574\n\t\tconst maxAttempts = rows * cols > 30 ? 30 : 60;\n\n\t\tfor (let attempt = 0; attempt < maxAttempts; attempt++) {\n\t\t\tconst grid = this.generateOnce(rows, cols, options);\n\n\t\t\t// \u5168\u3066\u306E\u8981\u6C42\u3055\u308C\u305F\u5236\u7D04\u30BF\u30A4\u30D7\u304C\u542B\u307E\u308C\u3066\u3044\u308B\u304B\u30C1\u30A7\u30C3\u30AF\n\t\t\tif (!this.checkAllRequestedConstraintsPresent(grid, options)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst difficulty = validator.calculateDifficulty(grid);\n\n\t\t\tif (difficulty === 0) continue;\n\n\t\t\tconst diffFromTarget = Math.abs(difficulty - targetDifficulty);\n\n\t\t\t// \u3088\u308A\u76EE\u6A19\u306B\u8FD1\u3044\u3082\u306E\u3092\u63A1\u7528\n\t\t\tif (bestGrid === null || diffFromTarget < Math.abs(bestScore - targetDifficulty)) {\n\t\t\t\tbestScore = difficulty;\n\t\t\t\tbestGrid = grid;\n\t\t\t}\n\n\t\t\t// \u975E\u5E38\u306B\u9AD8\u3044\u96E3\u6613\u5EA6\u304C\u6C42\u3081\u3089\u308C\u3066\u3044\u3066\u3001\u5341\u5206\u306A\u30B9\u30B3\u30A2\u304C\u5F97\u3089\u308C\u305F\u3089\u7D42\u4E86\n\t\t\tif (targetDifficulty > 0.8 && difficulty > 0.8) break;\n\t\t\t// \u5341\u5206\u306B\u8FD1\u3044\u3082\u306E\u304C\u5F97\u3089\u308C\u305F\u3089\u7D42\u4E86\n\t\t\tif (diffFromTarget < 0.05) break;\n\t\t}\n\n\t\treturn bestGrid || this.generateOnce(rows, cols, options);\n\t}\n\n\tprivate generateOnce(rows: number, cols: number, options: GenerationOptions): Grid {\n\t\tconst grid = new Grid(rows, cols);\n\n\t\t// 1. \u30B9\u30BF\u30FC\u30C8\u3068\u30B4\u30FC\u30EB\u306E\u8A2D\u5B9A (\u901A\u5E38\u306F\u5DE6\u4E0B\u30B9\u30BF\u30FC\u30C8\u3001\u53F3\u4E0A\u30B4\u30FC\u30EB\u306A\u3069)\n\t\tconst startPoint: Point = { x: 0, y: rows }; // \u5DE6\u4E0B\n\t\tconst endPoint: Point = { x: cols, y: 0 }; // \u53F3\u4E0A\n\n\t\tgrid.nodes[startPoint.y][startPoint.x].type = NodeType.Start;\n\t\tgrid.nodes[endPoint.y][endPoint.x].type = NodeType.End;\n\n\t\t// 2. \u6B63\u89E3\u30D1\u30B9\u3092\u751F\u6210 (\u30E9\u30F3\u30C0\u30E0\u30A6\u30A9\u30FC\u30AF / DFS)\n\t\tconst solutionPath = this.generateRandomPath(grid, startPoint, endPoint);\n\n\t\t// 3. \u30D1\u30B9\u306B\u57FA\u3065\u3044\u3066\u5236\u7D04\uFF08\u30EB\u30FC\u30EB\uFF09\u3092\u914D\u7F6E\n\t\t// \u30D1\u30B9\u304C\u901A\u904E\u3059\u308B\u30A8\u30C3\u30B8\u306B\u30D8\u30AD\u30B5\u30B4\u30F3\u3092\u7F6E\u3044\u305F\u308A\u3001\u5206\u5272\u3055\u308C\u305F\u9818\u57DF\u306B\u8272\u3092\u5857\u308B\n\t\tthis.applyConstraintsBasedOnPath(grid, solutionPath, options);\n\n\t\t// 4. \u5207\u65AD\uFF08Broken/Absent\uFF09\u3092\u914D\u7F6E\n\t\tif (options.useBrokenEdges) {\n\t\t\tthis.applyBrokenEdges(grid, solutionPath, options);\n\t\t}\n\n\t\t// 5. \u6D6E\u5CF6\u306E\u524A\u9664\u3068\u5916\u5468\u306E\u8ABF\u6574\n\t\tthis.cleanGrid(grid);\n\n\t\treturn grid;\n\t}\n\n\t/**\n\t * Randomized DFS\u3092\u7528\u3044\u3066Start\u304B\u3089End\u3078\u306E\u4E00\u672C\u9053\u3092\u751F\u6210\u3059\u308B\n\t */\n\tprivate generateRandomPath(grid: Grid, start: Point, end: Point): Point[] {\n\t\tconst visited = new Set<string>();\n\t\tconst path: Point[] = [];\n\n\t\tconst stack: Point[] = [start];\n\t\tconst parentMap = new Map<string, Point | null>();\n\t\tparentMap.set(`${start.x},${start.y}`, null);\n\n\t\t// \u5B8C\u5168\u306A\u30E9\u30F3\u30C0\u30E0\u3067\u306F\u306A\u304F\u3001\u30B4\u30FC\u30EB\u65B9\u5411\u3078\u5411\u304B\u3046\u30D0\u30A4\u30A2\u30B9\u3092\u304B\u3051\u308B\u3053\u3068\u3082\u53EF\u80FD\u3060\u304C\n\t\t// \u3053\u3053\u3067\u306F\u5358\u7D14\u306A\u30D0\u30C3\u30AF\u30C8\u30E9\u30C3\u30AD\u30F3\u30B0\u4ED8\u304DDFS\u3067\u63A2\u7D22\u3059\u308B\n\n\t\tconst findPath = (current: Point): boolean => {\n\t\t\tvisited.add(`${current.x},${current.y}`);\n\t\t\tpath.push(current);\n\n\t\t\tif (current.x === end.x && current.y === end.y) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// \u6B21\u306E\u5019\u88DC\u3092\u53D6\u5F97\n\t\t\tconst neighbors = this.getValidNeighbors(grid, current, visited);\n\t\t\t// \u30E9\u30F3\u30C0\u30E0\u306B\u30B7\u30E3\u30C3\u30D5\u30EB\n\t\t\tthis.shuffleArray(neighbors);\n\n\t\t\tfor (const next of neighbors) {\n\t\t\t\tif (findPath(next)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// \u884C\u304D\u6B62\u307E\u308A\u306A\u3089\u30D0\u30C3\u30AF\u30C8\u30E9\u30C3\u30AF\n\t\t\tpath.pop();\n\t\t\treturn false;\n\t\t};\n\n\t\t// \u78BA\u5B9F\u306B\u30D1\u30B9\u3092\u898B\u3064\u3051\u308B\u305F\u3081\u3001\u7C21\u6613\u7684\u306A\u5B9F\u88C5\u3068\u3057\u3066\u3044\u307E\u3059\u3002\n\t\t// \u672C\u683C\u7684\u306AWitness\u30D1\u30BA\u30EB\u3067\u306F\u300C\u9577\u304F\u86C7\u884C\u3059\u308B\u30D1\u30B9\u300D\u304C\u597D\u307E\u3057\u3044\u305F\u3081\u3001\n\t\t// \u5B9F\u969B\u306B\u306FPrim\u6CD5\u306A\u3069\u3067\u5168\u57DF\u6728\u3092\u4F5C\u3063\u3066\u304B\u3089\u30D1\u30B9\u3092\u5207\u308A\u51FA\u3059\u624B\u6CD5\u304C\u63A8\u5968\u3055\u308C\u307E\u3059\u3002\n\t\t// \u3053\u3053\u3067\u306F\u57FA\u672C\u7684\u306ADFS\u63A2\u7D22\u3092\u884C\u3044\u307E\u3059\u3002\n\t\tfindPath(start);\n\n\t\treturn path;\n\t}\n\n\tprivate getValidNeighbors(grid: Grid, p: Point, visited: Set<string>): Point[] {\n\t\tconst candidates: Point[] = [];\n\t\tconst directions = [\n\t\t\t{ x: 0, y: -1 }, // Up\n\t\t\t{ x: 1, y: 0 }, // Right\n\t\t\t{ x: 0, y: 1 }, // Down\n\t\t\t{ x: -1, y: 0 }, // Left\n\t\t];\n\n\t\tfor (const d of directions) {\n\t\t\tconst nx = p.x + d.x;\n\t\t\tconst ny = p.y + d.y;\n\n\t\t\tif (nx >= 0 && nx <= grid.cols && ny >= 0 && ny <= grid.rows) {\n\t\t\t\tif (!visited.has(`${nx},${ny}`)) {\n\t\t\t\t\tcandidates.push({ x: nx, y: ny });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn candidates;\n\t}\n\n\tprivate applyBrokenEdges(grid: Grid, path: Point[], options: GenerationOptions) {\n\t\tconst complexity = options.complexity ?? 0.5;\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tpathEdges.add(this.getEdgeKey(path[i], path[i + 1]));\n\t\t}\n\n\t\t// \u30D1\u30B9\u306B\u4F7F\u308F\u308C\u3066\u3044\u306A\u3044\u30A8\u30C3\u30B8\u3092\u53CE\u96C6\n\t\tconst unusedEdges: { type: \"h\" | \"v\"; r: number; c: number; p1: Point; p2: Point }[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tconst p1 = { x: c, y: r };\n\t\t\t\tconst p2 = { x: c + 1, y: r };\n\t\t\t\tif (!pathEdges.has(this.getEdgeKey(p1, p2))) {\n\t\t\t\t\tunusedEdges.push({ type: \"h\", r, c, p1, p2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tconst p1 = { x: c, y: r };\n\t\t\t\tconst p2 = { x: c, y: r + 1 };\n\t\t\t\tif (!pathEdges.has(this.getEdgeKey(p1, p2))) {\n\t\t\t\t\tunusedEdges.push({ type: \"v\", r, c, p1, p2 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.shuffleArray(unusedEdges);\n\n\t\t// \u6700\u5C0F\u9650\u306E\u8A2D\u7F6E (1\u301C3\u500B\u7A0B\u5EA6\u3001\u307E\u305F\u306F\u8907\u96D1\u5EA6\u306B\u5FDC\u3058\u3066)\n\t\tconst targetCount = Math.max(1, Math.floor(complexity * 4));\n\t\tlet placed = 0;\n\n\t\tfor (const edge of unusedEdges) {\n\t\t\tif (placed >= targetCount) break;\n\n\t\t\t// 80%\u306E\u78BA\u7387\u3067Broken(1), 20%\u306E\u78BA\u7387\u3067Absent(2)\n\t\t\tlet type = Math.random() < 0.8 ? EdgeType.Broken : EdgeType.Absent;\n\n\t\t\t// \u30DE\u30FC\u30AF\u304C\u542B\u307E\u308C\u308B\u30DE\u30B9\u306E\u5916\u5468\u3067Absent\u306F\u7981\u6B62\n\t\t\tif (type === EdgeType.Absent && this.isAdjacentToMark(grid, edge)) {\n\t\t\t\ttype = EdgeType.Broken;\n\t\t\t}\n\n\t\t\tif (edge.type === \"h\") {\n\t\t\t\tgrid.hEdges[edge.r][edge.c].type = type;\n\t\t\t} else {\n\t\t\t\tgrid.vEdges[edge.r][edge.c].type = type;\n\t\t\t}\n\t\t\tplaced++;\n\t\t}\n\n\t\t// \u5341\u5B57\u90E8\u5206\u30674\u65B9\u5411\uFF08\u307E\u305F\u306F\u9685\u306E\u5168\u65B9\u5411\uFF09\u5168\u3066\u304CBroken,Absent\u306E\u5834\u5408\u306F\u305D\u306E4\u65B9\u5411\u306FAbsent\u306B\u3059\u308B\n\t\t// \u305F\u3060\u3057\u3001\u30DE\u30FC\u30AF\u306E\u5468\u56F2\u306FAbsent\u7981\u6B62\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tconst edgesWithMeta: { e: EdgeConstraint; type: \"h\" | \"v\"; r: number; c: number }[] = [];\n\t\t\t\tif (c > 0) edgesWithMeta.push({ e: grid.hEdges[r][c - 1], type: \"h\", r, c: c - 1 });\n\t\t\t\tif (c < grid.cols) edgesWithMeta.push({ e: grid.hEdges[r][c], type: \"h\", r, c });\n\t\t\t\tif (r > 0) edgesWithMeta.push({ e: grid.vEdges[r - 1][c], type: \"v\", r: r - 1, c });\n\t\t\t\tif (r < grid.rows) edgesWithMeta.push({ e: grid.vEdges[r][c], type: \"v\", r, c });\n\n\t\t\t\tconst allCuts = edgesWithMeta.every((m) => m.e.type === EdgeType.Broken || m.e.type === EdgeType.Absent);\n\t\t\t\tif (allCuts) {\n\t\t\t\t\t// \u30DE\u30FC\u30AF\u306E\u5468\u56F2\u3067\u306A\u3044\u304B\u78BA\u8A8D\n\t\t\t\t\tconst noneNearMark = edgesWithMeta.every((m) => !this.isAdjacentToMark(grid, m));\n\t\t\t\t\tif (noneNearMark) {\n\t\t\t\t\t\tfor (const m of edgesWithMeta) {\n\t\t\t\t\t\t\tm.e.type = EdgeType.Absent;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate cleanGrid(grid: Grid) {\n\t\t// 1. \u6D6E\u5CF6\uFF08\u30B9\u30BF\u30FC\u30C8\u304B\u3089\u8FBF\u308C\u306A\u3044\u30CE\u30FC\u30C9\u30FB\u30A8\u30C3\u30B8\uFF09\u3092Absent\u306B\u5909\u63DB\n\t\tconst startNodes: { x: number; y: number }[] = [];\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tif (grid.nodes[r][c].type === NodeType.Start) {\n\t\t\t\t\tstartNodes.push({ x: c, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst reachableNodes = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [...startNodes];\n\t\tfor (const p of startNodes) reachableNodes.add(`${p.x},${p.y}`);\n\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.vEdges[curr.y - 1]?.[curr.x] }, // Up\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.vEdges[curr.y]?.[curr.x] }, // Down\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.hEdges[curr.y]?.[curr.x - 1] }, // Left\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.hEdges[curr.y]?.[curr.x] }, // Right\n\t\t\t];\n\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.edge && n.edge.type !== EdgeType.Absent) {\n\t\t\t\t\tif (!reachableNodes.has(`${n.nx},${n.ny}`)) {\n\t\t\t\t\t\treachableNodes.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// \u8FBF\u308C\u306A\u3044\u30A8\u30C3\u30B8\u3092Absent\u306B\n\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (!reachableNodes.has(`${c},${r}`) || !reachableNodes.has(`${c + 1},${r}`)) {\n\t\t\t\t\tgrid.hEdges[r][c].type = EdgeType.Absent;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\tif (!reachableNodes.has(`${c},${r}`) || !reachableNodes.has(`${c},${r + 1}`)) {\n\t\t\t\t\tgrid.vEdges[r][c].type = EdgeType.Absent;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// 2. \u5916\u5468\u304B\u3089\u30EA\u30FC\u30AF\u3057\u3066\u3044\u308B\u30BB\u30EB\u306E\u30DE\u30FC\u30AF\u3092\u524A\u9664\n\t\tconst external = this.getExternalCells(grid);\n\t\tfor (const cellKey of external) {\n\t\t\tconst [c, r] = cellKey.split(\",\").map(Number);\n\t\t\tgrid.cells[r][c].type = CellType.None;\n\t\t}\n\t}\n\n\tprivate getExternalCells(grid: Grid): Set<string> {\n\t\tconst external = new Set<string>();\n\t\tconst queue: { x: number; y: number }[] = [];\n\n\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\tif (grid.hEdges[0][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},0`)) {\n\t\t\t\t\texternal.add(`${c},0`);\n\t\t\t\t\tqueue.push({ x: c, y: 0 });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.hEdges[grid.rows][c].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${c},${grid.rows - 1}`)) {\n\t\t\t\t\texternal.add(`${c},${grid.rows - 1}`);\n\t\t\t\t\tqueue.push({ x: c, y: grid.rows - 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tif (grid.vEdges[r][0].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`0,${r}`)) {\n\t\t\t\t\texternal.add(`0,${r}`);\n\t\t\t\t\tqueue.push({ x: 0, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (grid.vEdges[r][grid.cols].type === EdgeType.Absent) {\n\t\t\t\tif (!external.has(`${grid.cols - 1},${r}`)) {\n\t\t\t\t\texternal.add(`${grid.cols - 1},${r}`);\n\t\t\t\t\tqueue.push({ x: grid.cols - 1, y: r });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (queue.length > 0) {\n\t\t\tconst curr = queue.shift()!;\n\t\t\tconst neighbors = [\n\t\t\t\t{ nx: curr.x, ny: curr.y - 1, edge: grid.hEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x, ny: curr.y + 1, edge: grid.hEdges[curr.y + 1][curr.x] },\n\t\t\t\t{ nx: curr.x - 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x] },\n\t\t\t\t{ nx: curr.x + 1, ny: curr.y, edge: grid.vEdges[curr.y][curr.x + 1] },\n\t\t\t];\n\n\t\t\tfor (const n of neighbors) {\n\t\t\t\tif (n.nx >= 0 && n.nx < grid.cols && n.ny >= 0 && n.ny < grid.rows) {\n\t\t\t\t\tif (!external.has(`${n.nx},${n.ny}`) && n.edge.type === EdgeType.Absent) {\n\t\t\t\t\t\texternal.add(`${n.nx},${n.ny}`);\n\t\t\t\t\t\tqueue.push({ x: n.nx, y: n.ny });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn external;\n\t}\n\n\tprivate isAdjacentToMark(grid: Grid, edge: { type: \"h\" | \"v\"; r: number; c: number }): boolean {\n\t\tif (edge.type === \"h\") {\n\t\t\t// \u4E0A\u306E\u30BB\u30EB\n\t\t\tif (edge.r > 0 && grid.cells[edge.r - 1][edge.c].type !== CellType.None) return true;\n\t\t\t// \u4E0B\u306E\u30BB\u30EB\n\t\t\tif (edge.r < grid.rows && grid.cells[edge.r][edge.c].type !== CellType.None) return true;\n\t\t} else {\n\t\t\t// \u5DE6\u306E\u30BB\u30EB\n\t\t\tif (edge.c > 0 && grid.cells[edge.r][edge.c - 1].type !== CellType.None) return true;\n\t\t\t// \u53F3\u306E\u30BB\u30EB\n\t\t\tif (edge.c < grid.cols && grid.cells[edge.r][edge.c].type !== CellType.None) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate hasIsolatedMark(grid: Grid): boolean {\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (grid.cells[r][c].type === CellType.None) continue;\n\n\t\t\t\t// Check 4 edges of this cell\n\t\t\t\tconst edges = [\n\t\t\t\t\tgrid.hEdges[r][c], // Top\n\t\t\t\t\tgrid.hEdges[r + 1][c], // Bottom\n\t\t\t\t\tgrid.vEdges[r][c], // Left\n\t\t\t\t\tgrid.vEdges[r][c + 1], // Right\n\t\t\t\t];\n\n\t\t\t\tconst passableCount = edges.filter((e) => e.type === EdgeType.Normal || e.type === EdgeType.Hexagon).length;\n\t\t\t\tif (passableCount === 0) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate getEdgeKey(p1: Point, p2: Point): string {\n\t\treturn p1.x < p2.x || (p1.x === p2.x && p1.y < p2.y) ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t}\n\n\tprivate applyConstraintsBasedOnPath(grid: Grid, path: Point[], options: GenerationOptions) {\n\t\tconst complexity = options.complexity ?? 0.5;\n\t\tconst useHexagons = options.useHexagons ?? true;\n\t\tconst useSquares = options.useSquares ?? true;\n\t\tconst useStars = options.useStars ?? true;\n\n\t\tlet hexagonsPlaced = 0;\n\t\tlet squaresPlaced = 0;\n\t\tlet starsPlaced = 0;\n\n\t\t// A. \u30D1\u30B9\u4E0A\u306E\u30D8\u30AD\u30B5\u30B4\u30F3 (Hexagon) \u914D\u7F6E\n\t\tif (useHexagons) {\n\t\t\tconst targetDifficulty = options.difficulty ?? 0.5;\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst p1 = path[i];\n\t\t\t\tconst p2 = path[i + 1];\n\n\t\t\t\tconst neighbors = this.getValidNeighbors(grid, p1, new Set());\n\t\t\t\tconst isBranching = neighbors.length > 2;\n\n\t\t\t\tlet prob = complexity * 0.4;\n\t\t\t\tif (isBranching) {\n\t\t\t\t\tprob = targetDifficulty < 0.4 ? prob * 1.0 : prob * 0.5;\n\t\t\t\t}\n\n\t\t\t\tif (Math.random() < prob) {\n\t\t\t\t\tthis.setEdgeHexagon(grid, p1, p2);\n\t\t\t\t\thexagonsPlaced++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// \u5F37\u5236\u914D\u7F6E\uFF1A\u4E00\u3064\u3082\u7F6E\u304B\u308C\u306A\u304B\u3063\u305F\u5834\u5408\n\t\t\tif (hexagonsPlaced === 0 && path.length >= 2) {\n\t\t\t\tconst idx = Math.floor(Math.random() * (path.length - 1));\n\t\t\t\tthis.setEdgeHexagon(grid, path[idx], path[idx + 1]);\n\t\t\t}\n\t\t}\n\n\t\t// B. \u9818\u57DF\u3054\u3068\u306E\u5236\u7D04\u914D\u7F6E (Squares & Stars)\n\n\t\tif (useSquares || useStars) {\n\t\t\tconst regions = this.calculateRegions(grid, path);\n\t\t\tconst availableColors = [Color.Black, Color.White, Color.Red, Color.Blue];\n\n\t\t\t// \u30B7\u30E3\u30C3\u30D5\u30EB\u3057\u3066\u3001\u5F37\u5236\u914D\u7F6E\u304C\u5FC5\u8981\u306A\u5834\u5408\u306B\u5099\u3048\u308B\n\t\t\tconst regionIndices = Array.from({ length: regions.length }, (_, i) => i);\n\t\t\tthis.shuffleArray(regionIndices);\n\n\t\t\tfor (const idx of regionIndices) {\n\t\t\t\tconst region = regions[idx];\n\t\t\t\t// \u96E3\u6613\u5EA6\u304C\u9AD8\u3044\u5834\u5408\u306F\u5236\u7D04\u3092\u30B9\u30AD\u30C3\u30D7\u3057\u306B\u304F\u304F\u3059\u308B\n\t\t\t\tconst skipProb = (options.difficulty ?? 0.5) > 0.7 ? 0.4 : 0.2;\n\n\t\t\t\t// \u5F37\u5236\u914D\u7F6E\u304C\u5FC5\u8981\u306A\u5834\u5408\uFF08\u6700\u5F8C\u306E\u65B9\u306E\u9818\u57DF\u3067\u307E\u3060\u4F55\u3082\u7F6E\u304B\u308C\u3066\u3044\u306A\u3044\u5834\u5408\uFF09\u306F\u30B9\u30AD\u30C3\u30D7\u3057\u306A\u3044\n\t\t\t\tconst forceOne = (useSquares && squaresPlaced === 0) || (useStars && starsPlaced === 0);\n\t\t\t\tconst isLastFew = idx === regionIndices[regionIndices.length - 1];\n\n\t\t\t\tif (!forceOne || !isLastFew) {\n\t\t\t\t\tif (Math.random() > skipProb + complexity * 0.5) continue;\n\t\t\t\t}\n\n\t\t\t\tconst potentialCells = [...region];\n\t\t\t\tthis.shuffleArray(potentialCells);\n\n\t\t\t\t// 1. \u3053\u306E\u9818\u57DF\u306E\u56DB\u89D2\u5F62(Square)\u306E\u8272\u3092\u6C7A\u5B9A (1\u8272\u306E\u307F)\n\t\t\t\tlet squareColor = availableColors[Math.floor(Math.random() * availableColors.length)];\n\n\t\t\t\t// \u30C8\u30B2\u304C\u306A\u304F2\u8272\u76EE\u304C\u5FC5\u8981\u306A\u5834\u5408\u3001\u9055\u3046\u8272\u3092\u9078\u3076\n\t\t\t\tif (useSquares && !useStars && isLastFew) {\n\t\t\t\t\tconst currentColors = new Set<number>();\n\t\t\t\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t\t\t\tif (grid.cells[r][c].type === CellType.Square) currentColors.add(grid.cells[r][c].color);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (currentColors.size === 1) {\n\t\t\t\t\t\tconst otherColors = availableColors.filter((c) => !currentColors.has(c));\n\t\t\t\t\t\tif (otherColors.length > 0) {\n\t\t\t\t\t\t\tsquareColor = otherColors[Math.floor(Math.random() * otherColors.length)];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet numSquares = 0;\n\n\t\t\t\t// \u56DB\u89D2\u5F62\u3092\u914D\u7F6E\u3059\u308B\u304B\u6C7A\u5B9A\n\t\t\t\tlet shouldPlaceSquare = useSquares && Math.random() < 0.5 + complexity * 0.3;\n\t\t\t\tif (useSquares && squaresPlaced === 0 && isLastFew) shouldPlaceSquare = true;\n\n\t\t\t\t// \u30C8\u30B2\u304C\u306A\u304F\u56DB\u89D2\u304C\u5FC5\u8981\u306A\u5834\u5408\u3001\u6700\u4F4E\u3067\u30822\u3064\u306E\u9818\u57DF\u306B\u56DB\u89D2\u3092\u7F6E\u304F\u3088\u3046\u306B\u8A98\u5C0E\n\t\t\t\tif (useSquares && !useStars && isLastFew) {\n\t\t\t\t\tconst currentColors = new Set<number>();\n\t\t\t\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t\t\t\tif (grid.cells[r][c].type === CellType.Square) currentColors.add(grid.cells[r][c].color);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (currentColors.size < 2 && squaresPlaced > 0) {\n\t\t\t\t\t\tshouldPlaceSquare = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (shouldPlaceSquare) {\n\t\t\t\t\tconst maxSquares = Math.min(potentialCells.length, 4);\n\t\t\t\t\tnumSquares = Math.floor(Math.random() * maxSquares);\n\t\t\t\t\tif (numSquares === 0 && squaresPlaced === 0) numSquares = 1;\n\n\t\t\t\t\tfor (let i = 0; i < numSquares; i++) {\n\t\t\t\t\t\tif (potentialCells.length === 0) break;\n\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Square;\n\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = squareColor;\n\t\t\t\t\t\tsquaresPlaced++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 2. \u5404\u8272\u306B\u3064\u3044\u3066\u30C8\u30B2(Star)\u3092\u914D\u7F6E\u3059\u308B\u304B\u6C7A\u5B9A\n\t\t\t\tif (useStars) {\n\t\t\t\t\tfor (const color of availableColors) {\n\t\t\t\t\t\tif (potentialCells.length < 1) break;\n\n\t\t\t\t\t\tlet shouldPlaceStar = Math.random() < 0.2 + complexity * 0.3;\n\t\t\t\t\t\tif (starsPlaced === 0 && isLastFew) shouldPlaceStar = true;\n\n\t\t\t\t\t\tif (!shouldPlaceStar) continue;\n\n\t\t\t\t\t\tif (color === squareColor) {\n\t\t\t\t\t\t\tif (numSquares === 1 && potentialCells.length >= 1) {\n\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\n\t\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\t} else if (numSquares === 0 && potentialCells.length >= 2) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < 2; i++) {\n\t\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\n\t\t\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (potentialCells.length >= 2) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < 2; i++) {\n\t\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\n\t\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\n\t\t\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// \u307E\u3060\u8DB3\u308A\u306A\u3044\u5834\u5408\u306E\u6700\u7D42\u624B\u6BB5 (1x1\u9818\u57DF\u306A\u3069\u3067\u661F\u304C\u7F6E\u3051\u306A\u304B\u3063\u305F\u5834\u5408\u306A\u3069)\n\t\t\tif (useStars && starsPlaced === 0) {\n\t\t\t\tfor (const region of regions) {\n\t\t\t\t\tif (region.length >= 2) {\n\t\t\t\t\t\tconst potentialCells = [...region].filter((p) => grid.cells[p.y][p.x].type === CellType.None);\n\t\t\t\t\t\tif (potentialCells.length >= 2) {\n\t\t\t\t\t\t\tconst color = availableColors[Math.floor(Math.random() * availableColors.length)];\n\t\t\t\t\t\t\tfor (let i = 0; i < 2; i++) {\n\t\t\t\t\t\t\t\tconst cell = potentialCells.pop()!;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].type = CellType.Star;\n\t\t\t\t\t\t\t\tgrid.cells[cell.y][cell.x].color = color;\n\t\t\t\t\t\t\t\tstarsPlaced++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * \u30D1\u30B9\u3092\u58C1\u3068\u898B\u306A\u3057\u3066\u3001\u30BB\u30EB\uFF08Block\uFF09\u306E\u9818\u57DF\u5206\u5272\u3092\u884C\u3046 (Flood Fill)\n\t */\n\tprivate calculateRegions(grid: Grid, path: Point[]): Point[][] {\n\t\tconst regions: Point[][] = [];\n\t\tconst visitedCells = new Set<string>();\n\n\t\t// \u30D1\u30B9\u3092\u691C\u7D22\u3057\u3084\u3059\u3044\u5F62\u5F0F\u306B\u5909\u63DB (\u30A8\u30C3\u30B8\u96C6\u5408)\n\t\tconst pathEdges = new Set<string>();\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst p1 = path[i];\n\t\t\tconst p2 = path[i + 1];\n\t\t\t// \u30A8\u30C3\u30B8\u3092\u4E00\u610F\u306A\u30AD\u30FC\u306B\u3059\u308B (\u5C0F\u3055\u3044\u5EA7\u6A19 -> \u5927\u304D\u3044\u5EA7\u6A19)\n\t\t\tconst k = p1.x < p2.x || p1.y < p2.y ? `${p1.x},${p1.y}-${p2.x},${p2.y}` : `${p2.x},${p2.y}-${p1.x},${p1.y}`;\n\t\t\tpathEdges.add(k);\n\t\t}\n\n\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\tif (visitedCells.has(`${c},${r}`)) continue;\n\n\t\t\t\tconst currentRegion: Point[] = [];\n\t\t\t\tconst queue: Point[] = [{ x: c, y: r }];\n\t\t\t\tvisitedCells.add(`${c},${r}`);\n\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst cell = queue.shift()!;\n\t\t\t\t\tcurrentRegion.push(cell);\n\n\t\t\t\t\t// 4\u65B9\u5411\u306E\u96A3\u63A5\u30BB\u30EB\u3092\u78BA\u8A8D\n\t\t\t\t\tconst neighbors = [\n\t\t\t\t\t\t{ dx: 0, dy: -1, boundary: { p1: { x: cell.x, y: cell.y }, p2: { x: cell.x + 1, y: cell.y } } }, // Up (Boundary is Top edge)\n\t\t\t\t\t\t{ dx: 0, dy: 1, boundary: { p1: { x: cell.x, y: cell.y + 1 }, p2: { x: cell.x + 1, y: cell.y + 1 } } }, // Down (Boundary is Bottom edge)\n\t\t\t\t\t\t{ dx: -1, dy: 0, boundary: { p1: { x: cell.x, y: cell.y }, p2: { x: cell.x, y: cell.y + 1 } } }, // Left (Boundary is Left edge)\n\t\t\t\t\t\t{ dx: 1, dy: 0, boundary: { p1: { x: cell.x + 1, y: cell.y }, p2: { x: cell.x + 1, y: cell.y + 1 } } }, // Right (Boundary is Right edge)\n\t\t\t\t\t];\n\n\t\t\t\t\tfor (const n of neighbors) {\n\t\t\t\t\t\tconst nx = cell.x + n.dx;\n\t\t\t\t\t\tconst ny = cell.y + n.dy;\n\n\t\t\t\t\t\t// \u76E4\u9762\u5185\u304B\n\t\t\t\t\t\tif (nx >= 0 && nx < grid.cols && ny >= 0 && ny < grid.rows) {\n\t\t\t\t\t\t\tif (!visitedCells.has(`${nx},${ny}`)) {\n\t\t\t\t\t\t\t\t// \u30D1\u30B9\uFF08\u58C1\uFF09\u307E\u305F\u306FAbsent\u30A8\u30C3\u30B8\u3067\u906E\u3089\u308C\u3066\u3044\u306A\u3044\u304B\u30C1\u30A7\u30C3\u30AF\n\t\t\t\t\t\t\t\tconst key = n.boundary.p1.x < n.boundary.p2.x || n.boundary.p1.y < n.boundary.p2.y ? `${n.boundary.p1.x},${n.boundary.p1.y}-${n.boundary.p2.x},${n.boundary.p2.y}` : `${n.boundary.p2.x},${n.boundary.p2.y}-${n.boundary.p1.x},${n.boundary.p1.y}`;\n\n\t\t\t\t\t\t\t\tif (!pathEdges.has(key) && !this.isAbsentEdge(grid, n.boundary.p1, n.boundary.p2)) {\n\t\t\t\t\t\t\t\t\tvisitedCells.add(`${nx},${ny}`);\n\t\t\t\t\t\t\t\t\tqueue.push({ x: nx, y: ny });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tregions.push(currentRegion);\n\t\t\t}\n\t\t}\n\n\t\treturn regions;\n\t}\n\n\tprivate isAbsentEdge(grid: Grid, p1: Point, p2: Point): boolean {\n\t\tif (p1.x === p2.x) {\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\treturn grid.vEdges[y][p1.x].type === EdgeType.Absent;\n\t\t} else {\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\treturn grid.hEdges[p1.y][x].type === EdgeType.Absent;\n\t\t}\n\t}\n\n\tprivate setEdgeHexagon(grid: Grid, p1: Point, p2: Point) {\n\t\tif (p1.x === p2.x) {\n\t\t\t// Vertical\n\t\t\tconst y = Math.min(p1.y, p2.y);\n\t\t\tgrid.vEdges[y][p1.x].type = EdgeType.Hexagon;\n\t\t} else {\n\t\t\t// Horizontal\n\t\t\tconst x = Math.min(p1.x, p2.x);\n\t\t\tgrid.hEdges[p1.y][x].type = EdgeType.Hexagon;\n\t\t}\n\t}\n\n\tprivate checkAllRequestedConstraintsPresent(grid: Grid, options: GenerationOptions): boolean {\n\t\tconst useHexagons = options.useHexagons ?? true;\n\t\tconst useSquares = options.useSquares ?? true;\n\t\tconst useStars = options.useStars ?? true;\n\t\tconst useBrokenEdges = options.useBrokenEdges ?? false;\n\n\t\tif (useBrokenEdges) {\n\t\t\tlet found = false;\n\t\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Broken || grid.hEdges[r][c].type === EdgeType.Absent) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (found) break;\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Broken || grid.vEdges[r][c].type === EdgeType.Absent) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (found) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) return false;\n\t\t}\n\n\t\tif (useHexagons) {\n\t\t\tlet found = false;\n\t\t\tfor (let r = 0; r <= grid.rows; r++) {\n\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t\tif (grid.hEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (found) break;\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\t\t\tfor (let c = 0; c <= grid.cols; c++) {\n\t\t\t\t\t\tif (grid.vEdges[r][c].type === EdgeType.Hexagon) {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (found) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) return false;\n\t\t}\n\n\t\tif (useSquares || useStars) {\n\t\t\tlet foundSquare = false;\n\t\t\tlet foundStar = false;\n\t\t\tconst squareColors = new Set<number>();\n\n\t\t\tfor (let r = 0; r < grid.rows; r++) {\n\t\t\t\tfor (let c = 0; c < grid.cols; c++) {\n\t\t\t\t\tif (grid.cells[r][c].type === CellType.Square) {\n\t\t\t\t\t\tfoundSquare = true;\n\t\t\t\t\t\tsquareColors.add(grid.cells[r][c].color);\n\t\t\t\t\t}\n\t\t\t\t\tif (grid.cells[r][c].type === CellType.Star) foundStar = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (useSquares && !foundSquare) return false;\n\t\t\tif (useStars && !foundStar) return false;\n\n\t\t\t// \u30C8\u30B2\u304C\u5B58\u5728\u3059\u308B\u5834\u5408\u3092\u9664\u304D\u3001\u56DB\u89D2\u304C1\u8272\u306E\u307F\u3067\u751F\u6210\u3055\u308C\u308B\u306E\u306F\u30D1\u30BA\u30EB\u3068\u3057\u3066\u7834\u7DBB\u3057\u3066\u3044\u308B\u306E\u30672\u8272\u4EE5\u4E0A\u5FC5\u8981\n\t\t\tif (foundSquare && !foundStar && squareColors.size < 2) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// \u30DE\u30FC\u30AF\u306E\u5468\u56F2\u5168\u3066\u304C\u901A\u884C\u4E0D\u53EF\u306E\u76E4\u9762\u306F\u975E\u63A8\u5968\n\t\tif (this.hasIsolatedMark(grid)) return false;\n\n\t\treturn true;\n\t}\n\n\tprivate shuffleArray(array: any[]) {\n\t\tfor (let i = array.length - 1; i > 0; i--) {\n\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t[array[i], array[j]] = [array[j], array[i]];\n\t\t}\n\t}\n}\n", "import { PuzzleGenerator } from \"./generator\";\nimport { Grid } from \"./grid\";\nimport type { GenerationOptions, PuzzleData, SolutionPath, ValidationResult } from \"./types\";\nimport { PuzzleValidator } from \"./validator\";\n\n// \u30E9\u30A4\u30D6\u30E9\u30EA\u306E\u30D5\u30A1\u30B5\u30FC\u30C9\u30AF\u30E9\u30B9\nexport { PuzzleGenerator } from \"./generator\";\nexport { Grid } from \"./grid\";\nexport { PuzzleValidator } from \"./validator\";\n\nexport class WitnessCore {\n\tprivate generator: PuzzleGenerator;\n\tprivate validator: PuzzleValidator;\n\n\tconstructor() {\n\t\tthis.generator = new PuzzleGenerator();\n\t\tthis.validator = new PuzzleValidator();\n\t}\n\n\t/**\n\t * \u65B0\u3057\u3044\u30D1\u30BA\u30EB\u3092\u751F\u6210\u3057\u3066\u30C7\u30FC\u30BF\u3092\u8FD4\u3059\n\t */\n\tpublic createPuzzle(rows: number, cols: number, options: GenerationOptions = {}): PuzzleData {\n\t\tconst grid = this.generator.generate(rows, cols, options);\n\t\treturn grid.export();\n\t}\n\n\t/**\n\t * \u89E3\u7B54\u3092\u691C\u8A3C\u3059\u308B\n\t */\n\tpublic validateSolution(puzzleData: PuzzleData, solution: SolutionPath): ValidationResult {\n\t\tconst grid = Grid.fromData(puzzleData);\n\t\treturn this.validator.validate(grid, solution);\n\t}\n\n\t/**\n\t * \u30D1\u30BA\u30EB\u306E\u96E3\u6613\u5EA6\u3092\u8A08\u7B97\u3059\u308B\n\t */\n\tpublic calculateDifficulty(puzzleData: PuzzleData): number {\n\t\tconst grid = Grid.fromData(puzzleData);\n\t\treturn this.validator.calculateDifficulty(grid);\n\t}\n}\n\n// \u30D6\u30E9\u30A6\u30B6/Node.js\u74B0\u5883\u4E21\u5BFE\u5FDC\u306E\u305F\u3081\u306E\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\nexport * from \"./types\";\n"],
  "mappings": "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",
  "names": ["Direction", "CellType", "EdgeType", "NodeType", "Color"]
}
