// Generated by dts-bundle-generator v9.5.1

export declare enum Direction {
	Up = 0,
	Right = 1,
	Down = 2,
	Left = 3
}
export declare enum CellType {
	None = 0,
	Square = 1,// 色分けが必要なブロック
	Star = 2,// 同じ色のペア作成 (星)
	Tetris = 3,// テトリス
	TetrisRotated = 4
}
export declare enum EdgeType {
	Normal = 0,
	Broken = 1,// 線の真ん中で断線 (通行不可)
	Absent = 2,// そもそも分岐もなし (通行不可)
	Hexagon = 3
}
export declare enum NodeType {
	Normal = 0,
	Start = 1,
	End = 2
}
export declare enum Color {
	None = 0,
	Black = 1,
	White = 2,
	Red = 3,
	Blue = 4
}
export interface Point {
	x: number;
	y: number;
}
export interface CellConstraint {
	type: CellType;
	color: Color;
	shape?: number[][];
}
export interface EdgeConstraint {
	type: EdgeType;
}
export interface NodeConstraint {
	type: NodeType;
}
/**
 * パズルの静的な定義データ
 */
export interface PuzzleData {
	rows: number;
	cols: number;
	cells: CellConstraint[][];
	vEdges: EdgeConstraint[][];
	hEdges: EdgeConstraint[][];
	nodes: NodeConstraint[][];
}
/**
 * ユーザーの入力（回答パス）
 */
export interface SolutionPath {
	points: Point[];
}
export interface ValidationResult {
	isValid: boolean;
	errorReason?: string;
}
/**
 * パズル生成のオプション
 */
export interface GenerationOptions {
	useHexagons?: boolean;
	useSquares?: boolean;
	useStars?: boolean;
	useTetris?: boolean;
	useBrokenEdges?: boolean;
	complexity?: number;
	difficulty?: number;
}
export declare class Grid {
	readonly rows: number;
	readonly cols: number;
	cells: CellConstraint[][];
	hEdges: EdgeConstraint[][];
	vEdges: EdgeConstraint[][];
	nodes: NodeConstraint[][];
	constructor(rows: number, cols: number);
	private initializeGrid;
	export(): PuzzleData;
	static fromData(data: PuzzleData): Grid;
}
export declare class PuzzleGenerator {
	/**
	 * パズルを生成する
	 * @param rows 行数
	 * @param cols 列数
	 * @param options 生成オプション
	 */
	generate(rows: number, cols: number, options?: GenerationOptions): Grid;
	private generateOnce;
	/**
	 * Randomized DFSを用いてStartからEndへの一本道を生成する
	 */
	private generateRandomPath;
	private getValidNeighbors;
	private applyBrokenEdges;
	private cleanGrid;
	private getExternalCells;
	private isAdjacentToMark;
	private hasIsolatedMark;
	private getEdgeKey;
	private TETRIS_SHAPES;
	private applyConstraintsBasedOnPath;
	/**
	 * パスを壁と見なして、セル（Block）の領域分割を行う (Flood Fill)
	 */
	private calculateRegions;
	private isAbsentEdge;
	private setEdgeHexagon;
	private checkAllRequestedConstraintsPresent;
	/**
	 * 領域を指定されたピース数以内でタイリングする。成功すればピースのリストを返す。
	 */
	private generateTiling;
	private tilingDfs;
	private getShapeArea;
	private isRotationallyInvariant;
	private getAllRotations;
	private rotate90;
	private canPlace;
	private placePiece;
	private shuffleArray;
}
export declare class PuzzleValidator {
	validate(grid: Grid, solution: SolutionPath): ValidationResult;
	private isBrokenEdge;
	private isAbsentEdge;
	private checkHexagonConstraint;
	private checkCellConstraints;
	private checkTetrisConstraint;
	private getShapeArea;
	private canTile;
	private canPlace;
	private placePiece;
	private getAllRotations;
	private rotate90;
	private calculateRegions;
	private getExternalCells;
	private getEdgeKey;
	/**
	 * パズルの難易度を計算する（0.0 - 1.0）
	 * 知的なアルゴリズム：探索空間の広さ、分岐数、強制手、解の数などを分析
	 */
	calculateDifficulty(grid: Grid): number;
	private exploreSearchSpace;
	/**
	 * 全ての有効な解答パスの個数をカウントする
	 */
	countSolutions(grid: Grid, limit?: number): number;
	private findPathsOptimized;
	private canReachEndOptimized;
	private getFingerprint;
}
export declare class WitnessCore {
	private generator;
	private validator;
	constructor();
	/**
	 * 新しいパズルを生成してデータを返す
	 */
	createPuzzle(rows: number, cols: number, options?: GenerationOptions): PuzzleData;
	/**
	 * 解答を検証する
	 */
	validateSolution(puzzleData: PuzzleData, solution: SolutionPath): ValidationResult;
	/**
	 * パズルの難易度を計算する
	 */
	calculateDifficulty(puzzleData: PuzzleData): number;
}

export {};
